\documentclass[12pt,a4paper]{article}
\usepackage{t1enc}
\usepackage[latin1]{inputenc}
\usepackage[german]{babel}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{graphicx}
\markboth{}{}

\setlength{\oddsidemargin}{-0.7cm}
\setlength{\evensidemargin}{-0.7cm}
\setlength{\textwidth}{17cm}
\setlength{\topmargin}{-1cm}
\setlength{\textheight}{23.5cm}

\title{Verkapselung von Tk-Objekten für HTk}
\author{ludi@tzi.de}
\date {}

\begin{document}

\maketitle

\tableofcontents

\section{Grundlegendes}

...


\section{Externe Repräsentation}

Zentral bei der Verkapselung eines Tk-Objekten für HTk ist der (abstrakt)
exportierte Datentyp. Dieser ist die externe Repräsentation des jeweiligen
Objektes, und dient später als Handle, u.a. um nachträglich
Konfigurationsoptionen zu setzen oder Events zu binden. Für das
Label-Widget sieht dieser z.B. so aus:

\begin{verbatim}
newtype Label a = Label GUIOBJECT deriving Eq
-- ein (Label String) enthält Text, ein (Label Image) ein Bild 
\end{verbatim}

Dieser Typ kann weitere Objekt-spezifische Felder haben, das ist eine
Frage der individuellen Implementierung. Er enthält jedoch immer ein Feld
des Typs \verb|GUIOBJECT|.


\section{Der Typ GUIOBJECT und die Klasse GUIObject}

Dieser Typ \verb|GUIOBJECT| ist die interne Repräsentation der
verschiedenen Oberflächen-Objekte (im wesentlichen Widgets,
Canvas-Objekte, Menüelemente, aber auch spezielleres wie z.B. Text-Tags
oder Canvas-Tags). Diese interne Repräsentation durch \emph{einen} Typen
ermöglicht z.B. Listen verschiedster Objekte im internen Status zu halten
oder als Funktions-Argumente zu übergeben.

Der \verb|GUIOBJECT|-Wert muß jedoch normalerweise nicht selbst
konstruiert werden, hierzu gibt es spezielle Funktionen
(z.B. \verb|createGUIObject| im Modul \verb|Core|,
\verb|createCanvasItem| im Modul \verb|CanvasItemAux|). Aussehen tut er
wie folgt:

\begin{verbatim}
data GUIOBJECT = GUIOBJECT ObjectID (Ref OST) | ROOT
\end{verbatim}

Den \verb|ROOT|-Konstruktor möchte ich hier nicht weiter erläutern. Er hat
eine spezielle Bedeutung und steht für die Wish-Instanz bzw. das
Hauptfenster, dies muß man aber jetzt nicht verstehen. Für ,,normale''
GUI-Objekte wird ein Wert entsprechend des ersten Konstruktors erzeugt.
Dieser enthält die \verb|ObjectID|, die dieses spezielle Objekt eindeutig 
identifiziert und eine Referenz auf das zu diesem Objekt gehörende
Statusobjekt (die \verb|ObjectID| und das Statusobjekte werden jedoch
von obiger Funktion automatisch erzeugt, daher will ich hier darauf nicht
weiter eingehen).

Der externe Typ muß immer eine Instanz der Klasse \verb|GUIObject| sein:

\begin{verbatim}
instance GUIObject (Label a) where 
  toGUIObject (Label w) = w
  cname _ = "Label"
\end{verbatim}

So kann bei Bedarf durch die Klassenmethode \verb|toGUIObject| der
externe Typ in die interne Repräsentation gewandelt werden. Die
\verb|cname|-Methode liefert lediglich eine Textuelle Repräsentation des
Objekttyps und kann z.B. für Debug-Ausgaben benutzt werden.


\section{Konfigurationsoptionen}

\subsection{Der Typ GUIVALUE und die Klasse GUIValue}
Eine ähnliche Verallgemeinerung wie beim Umgangs mit Objekten gibt es auch
für Werte, die die verschiedenen Konfigurationsoptionen der Tk-Objekte
annehmen können. Hierzu gibt es zunächst wieder \emph{einen} Typen, durch
den alle Werte dieser Art intern dargestellt werden. Dies ist der Typ
\verb|GUIVALUE|:
\begin{verbatim}
data Generator = HaskellTk | Tk
data GUIVALUE = GUIVALUE Generator String
\end{verbatim}
Entsprechend gibt es auch wieder eine Klasse \verb|GUIValue|, die im
wesentlichen zum Wandeln in die interne Repräsentation und Angabe von
default-Werten dient. Der Typ eines Konfigurationswertes muß also immer
eine Instanz der Klasse \verb|GUIValue| sein:
\begin{verbatim}
class (Show a, Read a) => GUIValue a where
        cdefault      :: a             -- default-Wert
        toGUIValue    :: a -> GUIVALUE -- wandeln in GUIVALUE
                                       -- für gängige Falle vordefiniert
        maybeGUIValue :: GUIVALUE -> (Maybe a) -- intern, vordefiniert
        fromGUIValue  :: GUIVALUE -> a         -- intern, vordefiniert
\end{verbatim}
Der Typ \verb|Generator| ist hier eigentlich uninteressant. Er wird nur
intern bei der Rückgabe von Tk-Werten, die ja immer als Strings von der
Wish gelesen werden, benutzt. Bei der Implementierung der Methode
\verb|toGUIValue| in der \verb|GUIVALUE|-Instanz wird man also immer
\verb|HaskellTk| als \verb|Generator| angeben. Das zweite Feld des
\verb|GUIVALUE|-Konstruktors muß die Tk-Repräsentation des entsprechenden
Wertes als String, genau so wie dieser auf die Wish ausgegeben werden
soll, enthalten. Diese Repräsentation sollte die \verb|Show|-Instanz, die
von der \verb|GUIValue|-Instanz vorausgesetzt wird liefern (falls dies aus
irgendwelchen Gründen einmal anders ist, reicht es allerdings, die
\verb|toGUIObject|-Methode entsprechend zu implementieren). Umgekehrt
\emph{muß} die ebenfalls vorausgesetzte \verb|Read|-Instanz die
Tcl-Repräsentation in den zugehörigen HTk-Wert wandeln.

Die \verb|toGUIValue| Methode muß man allerdings in der Regel nicht
überschreiben. Sie benutzt sonst einfach die vorausgesetzte \verb|Show|-
Instanz und liefert einen entsprechenden \verb|GUIVALUE| mit
\verb|HaskellTk| als \verb|Generator|. Zu beachten ist dabei allerdings,
daß gewisse Zeichen durch entsprechende Escape-Sequenzen ersetzt werden
und die Zeichenkette in Anführungszeichen gesetzt wird, damit keine
Probleme mit enthaltenen Leerzeichen auftreten. Normalerweise ist
dies so gewollt, kann aber in bestimmten Situation auch unerwünscht sein,
so daß dann die \verb|toGUIValue|-Methode überschrieben werden muß.

Die \verb|cdefault|-Methode liefert schließlich einen default-Wert für
diesen Typen. Normalerweise stehen hier die Tcl-Defaults. Soll ein
default-Wert abweichend davon gelten, muß dieser bei der Erzeugung mit
gesetzt werden (dazu siehe Objekt-Methoden $\rightarrow$
\verb|createCmd|).

\subsection{Interne Repräsentation}
\begin{verbatim}
type ConfigID   = String
type ConfigOption = (ConfigID, GUIVALUE)
\end{verbatim}

...


\subsection{Externe Repräsentation}
\begin{verbatim}
type Config w = w -> IO w
\end{verbatim}
...


\subsection{cset und cget}

...

\subsection{Vordefinierte Klassen}
Für Konfigurationsoptionen, die für mehrere Objekte benutzt werden,
gibt es im Modul \verb|Configuration| vordefinierte Klassen.

...


\section{Ein internes GUIOBJECT erzeugen}

\subsection{Widgets}
Der interne \verb|GUIOBJECT|-Wert wird für Widgets durch die Funktion
\begin{verbatim}
createGUIObject :: GUIOBJECT ->     -- Vaterobjekt
                   ObjectKind ->    -- Objekttyp
                   Methods ->       -- Objekt-spezifische Zugriffsmethoden
                   IO GUIOBJECT
\end{verbatim}
im Modul \verb|Core| erzuegt werden. Hierbei müssen die folgenden
Parameter angegeben werden:
\begin{itemize}
\item Das Vaterobjekt: Die interne Repräsentation (als \verb|GUIOBJECT|) 
des Containers, der das Widget enthalten soll. Obwohl Widgets erst später
gepackt werden,  muß dieser bereits bei der Konstruktion angegeben werden,
da der Tcl-Pfad zu dem erzeugten Objekt entsprechend (hierarchisch)
gesetzt werden muß.
\item Der Objekttyp: Um auch anhand der internen \verb|GUIOBJECT|-Werte
verschiedene Objekte unterscheiden zu können, gibt es den
\verb|ObjectKind|-Typ:
\begin{verbatim}
data ObjectKind =
    FRAME
  | LABEL
  | MESSAGE
  | BUTTON
...
\end{verbatim}
Für neue Widgets muß hier ein entsprechender Konstruktor hinzugefügt
werden. Er steht im Modul \verb|GUIObjectKind| in
\verb|kernel/GUIObjectKind.hs|.
\item Die Widget-Methoden: Der \verb|Methods|-Typ enthält eine Sammlung
verschiedener Zugriffs-Methoden auf Objekte. Da sich für unterschiedliche 
Objekte die Tcl-Syntax z.B. für das Setzen einer Konfigurationsoption oder
für die Zerstörung des Objektes unterschiedlich sein kann, liefern diese
Methoden eine einheitliche Schnittstelle für den Zugriff auf verschiedene
Objekte (dazu mehr im nächsten Abschnitt). Für einfache Widgets reichen
hier aber meist die Standard-Methoden in \verb|defMethods| im Modul
\verb|Core|. So wird man auch selten \emph{alle} Methoden selbst schreiben,
in der Regel reicht es, die \verb|defMethods| zu nehmen und evtl.
einzelne Methoden durch eigene zu überschreiben.
\end{itemize}

Will man keine der Default-Methoden überschreiben, reicht es, die Funktion
\begin{verbatim}
createWidget :: GUIOBJECT -> ObjectKind -> IO GUIOBJECT
\end{verbatim}
aufzurufen. Diese ruft dann \verb|createGUIObject| auf und setzt dabei die
Default-Methoden.

\subsection{Canvasitems}
Für die Erzeugung von Canvas-Objekten gibt es eine ähnliche Funktion im
Modul \verb|CanvasItemAux|:
\begin{verbatim}
createCanvasItem :: CanvasItem w =>
                    Canvas ->              -- Canvas-Container
                    CanvasItemKind ->      -- Objekttyp
                    (GUIOBJECT -> w) ->    -- Wrap
                    [Config w] ->          -- Konfigurationsoptionen
                    Coord ->               -- initiale Position
                    IO w
\end{verbatim}

...

\begin{verbatim}
data CanvasItemKind = 
    ARC
  | LINE 
...
\end{verbatim}

...


\subsection{Menüelemente}
Zur Erzeugung von Menüelementen gibt es schließlich die folgende Funktion:
\begin{verbatim}
createMenuItem :: MenuItem w =>
                  Menu ->                  -- Menü-Container
                  MenuItemKind ->          -- Objekttyp
                  (GUIOBJECT -> w) ->      -- Wrap
                  [Config w] ->            -- Konfigurationsoptionen
                  IO w
\end{verbatim}

...

\begin{verbatim}
data MenuItemKind =
    MENUCASCADE
  | MENUCOMMAND
...
\end{verbatim}

...

\section{Objekt-Methoden}


\subsection{Tcl-Syntax}
Wie bereits erwähnt dienen die Objekt-Methoden einem einheitlichen Umgang
mit verschiedenen Objekten bzw. deren unterschiedlicher Tcl-Syntax (bei 
Erzeugung, Packen usw.). Genauer gesagt erzeugen sie die jeweils
erforderlichen Tcl-Kommandos in Form eines \verb|TclScript|:

\begin{verbatim}
type TclCmd = String             -- ein einzelnes Kommando
type TclScript = [TclCmd]        -- eine Tcl-Befehlsfolge
\end{verbatim}

\subsection{Tcl-Skripte und Kommandos ausführen}
In bestimmten Situationen, z.B. bei der Implementierung
Objekt-spezifischer Konfigurationsoptionen, kann es sein, daß man solche
Tcl-Skripte oder Kommandos selbst ausführen muß. Hierzu können die
folgenden Funktionen aus dem Modul \verb|Wish| benutzt werden:
\begin{verbatim}
execTclScript :: TclScript -> IO () -- Ausführen eines Tcl-Skriptes
execCmd :: TclCmd -> IO ()          -- Ausführen eines einzelnen Kommandos
\end{verbatim}

... (auch speziellere Kommandos mit TclResponse ??)

\subsection{Der Methods-Typ}
Der \verb|Methods|-Typ hat die folgenden Felder:
\begin{verbatim}
data Methods =
  Methods { -- Konfigurationsoption abfragen
            cgetCmd     :: ObjectName -> ConfigID -> TclScript,

            -- eine List von Konfigurationen setzen
            csetCmd     :: ObjectName -> [ConfigOption] -> TclScript,

            -- das Objekt erzeugen
            createCmd   :: ObjectName -> ObjectKind -> ObjectName ->
                           ObjectID -> [ConfigOption] -> TclScript,

            -- das Objekt mit Tk's "pack geometry manager" packen
            -- für "nicht-Widgets" leer
            packCmd     :: ObjectName -> [PackOption] -> TclScript,

            -- das Objekt mit Tk's "grid geometry manager" packen
            -- für "nicht-Widgets" leer
            gridCmd     :: ObjectName -> [GridPackOption] -> TclScript,

            -- das Objekt zerstören
            destroyCmd  :: ObjectName -> TclScript,

            -- ein Event an dieses Objekt binden
            bindCmd     :: ObjectName -> BindTag -> [WishEvent] ->
                           EventInfoSet -> TclScript,

            -- Event-Bindung verwerfen
            unbindCmd   :: ObjectName -> BindTag -> [WishEvent] ->
                           TclScript,

             -- zum aufräumen bei der Zerstörung, i.d.R. leer
            cleanupCmd  :: ObjectID -> ObjectName -> TclScript }
\end{verbatim}
Auf den Typ \verb|ObjectName| möchte ich hier nicht weiter eingehen. Er
wird durch die oben erwähnten \verb|GUIOBJECT|-Konstruktoren automatisch
erzeugt und enthält den Tcl-Pfad des entsprechenden Objektes. Es reicht zu
wissen, daß er eine Instanz der Klasse \verb|Show| ist und so auf den
Tcl-Bezeichner des Objektes zugegriffen werden kann. Weiter wäre
anzumerken, daß nicht für jedes Objekt tatsächlich \emph{alle} obigen
Parameter gebraucht werden. Dies ist vor allem Abhängig von der Art
der Tk-Objekte (so braucht man z.B. das Vater-Objekte bei der Erzeugung
nur zum Zugriff auf Text-Items).
\begin{itemize}
\item \textbf{cgetCmd:} \newline
Erzeugt ein Tcl-Skript, daß den Wert einer Konfigurationsoption eines
Objektes abfragt. Da korrespondierende Wert immer eine Instanz der Klasse
GUIValue ist, die eine \verb|Show| und \verb|Read|-Instanz voraussetzt,
kann er immer parsiert und zurückgegeben werden. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkGetWidgetConfig :: ObjectName ->  -- Tcl-Pfad des Objektes
                     ConfigID ->    -- Tcl-Bezeichner der Konfiguration
                     TclScript
tkGetWidgetConfig name cid = [(show name) ++ " cget -" ++ cid]
\end{verbatim}
\item \textbf{csetCmd:} \newline
Erzeugt ein Tcl-Skript, das eine Liste von Konfigurationen setzt. Der Typ
\verb|ConfigOption| ist einfach ein Tupel aus \verb|ConfigID|
(= \verb|String|) und \verb|GUIVALUE|. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkSetWidgetConfigs :: ObjectName ->       -- Tcl-Pfad des Objektes
                      [ConfigOption] ->   -- Liste der Konfigurationen
                      TclScript
tkSetWidgetConfigs _ [] = []
tkSetWidgetConfigs name args =
  [show name ++ " configure " ++ showConfigs args]
\end{verbatim}
Die Funktion \verb|showConfigs| kann zur bequemen Ausgabe einer Liste
von Konfigurationen in den korrespondierenden Tcl-\verb|String| verwendet
werden:
\begin{verbatim}
showConfigs :: [(ConfigID, GUIVALUE)] -> String
\end{verbatim}
\item \textbf{createCmd:} \newline
Erzeugt ein Tcl-Skript, das das korrespondierende Tk-Objekt konstruiert.
Die dabei übergebene Liste von Konfigurationen kann benutzt werden, um
intern bestimmte vom Tk-Default abweichende Konfigurationen für dieses
Objekt vorzudefinieren. Die im HTk-Konstruktor übergebenen Konfigurationen
werden hier nicht verarbeitet (dies geht aus Gründen, die ich hier nicht
näher erläutern will auch gar nicht). \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkCreateWidget :: ObjectName ->   -- Tcl-Pfad des Vaterobjektes (noch nötig ???)
                  ObjectKind ->   -- Objekttyp
                  ObjectName ->   -- Tcl-Pfad des Objektes
                  ObjectID ->     -- ID des Objektes auf HTk-Seite
                  [ConfigOption] -> TclScript
tkCreateWidget _ kind name _ opts =
  [show kind ++ " " ++ show name ++ " " ++ showConfigs opts]
\end{verbatim}
\item \textbf{packCmd:} \newline
Erzeugt ein Tcl-Skript, das ein bereits auf Tk-Seite existierendes
\emph{Widget} mit dem \emph{pack geometry manager} packt. Diese Methode
wird man niemals überschreiben, denn das Packen eines Widgets ist auf
Tk-Seite einheitlich. Für nicht-Widgets sollte das erzuegte Skript leer
sein.\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkPack :: ObjectName ->     -- Tcl-Pfad des Objektes
          [PackOption] ->   -- Liste der Optionen für den geometry manager
          TclScript
tkPack name opts = ["pack " ++ show name ++ " " ++ showPackOptions opts]
\end{verbatim}
\item \textbf{gridCmd:} \newline
Erzeugt ein Tcl-Skript, das ein bereits auf Tk-Seite existierendes
\emph{Widget} mit dem \emph{grid geometry manager} packt. Auch diese Methode
wird man niemals überschreiben, denn das Packen eines Widgets ist auf
Tk-Seite einheitlich. Für nicht-Widgets sollte das erzeugte Skript leer
sein.\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkGrid :: ObjectName ->        -- Tcl-Pfad des Objektes
          [GridPackOption] ->  -- Liste der Optionen für den geometry manager
          TclScript
tkGrid name opts =
  ["grid " ++ show name ++ " " ++ showGridPackOptions opts]
\end{verbatim}
\item \textbf{destroyCmd:} \newline
Erzeugt ein Tcl-Skript, das ein Tk-Objekt zerstört. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkDestroyWidget :: ObjectName ->   -- Tcl-Pfad des Objektes
                   TclScript
tkDestroyWidget name = ["destroy " ++ show name]
\end{verbatim}
\item \textbf{bindCmd:} \newline
... \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkBindWidget :: ObjectName ->      -- Tcl-Pfad des Objektes
                BindTag ->         -- alt, rausnehmen ???
                [WishEvent] ->     -- ... 
                EventInfoSet ->    -- ...
                TclScript
tkBindWidget nm bindTag wishEvents eventInfoSet =
  let doBind = "bind " ++ show nm ++ " " ++
               delimitString (foldr (\ event soFar -> showP event soFar)
                                    "" wishEvents) ++ " " ++
               mkBoundCmdArg bindTag eventInfoSet
  in [doBind]
\end{verbatim}
\item \textbf{unbindCmd:} \newline
...
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkUnbindWidget :: ObjectName -> BindTag -> [WishEvent] -> TclScript
tkUnbindWidget nm bindTag wishEvents =
  let doUnBind = "bind " ++ show nm ++ " " ++
                 delimitString (foldr (\ event soFar -> showP event soFar)
                                      "" wishEvents) ++ " {}"
  in [doUnBind]
\end{verbatim}
\item \textbf{cleanupCmd:} \newline
... (wird bisher nicht benutzt, rausnehmen ??)

\end{itemize}

\end{document}