\documentclass[12pt,a4paper]{article}
\usepackage{t1enc}
\usepackage[latin1]{inputenc}
\usepackage[german]{babel}
\usepackage{epsfig}
\usepackage{wrapfig}
\usepackage{graphicx}
\markboth{}{}

\setlength{\oddsidemargin}{-0.7cm}
\setlength{\evensidemargin}{-0.7cm}
\setlength{\textwidth}{17cm}
\setlength{\topmargin}{-1cm}
\setlength{\textheight}{23.5cm}

\title{Verkapselung von Tk-Objekten für HTk}
\author{ludi@tzi.de}
\date {}

\begin{document}

\maketitle

\tableofcontents

\section{Grundlegendes}
Im folgenden gebe ich einen Überblick über die Verkapselung von
Tk-Objekten für HTk. Dies ist keine komplette Einführung in die
Funktionsweise von HTk, insbesondere wird man Informationen über die
Funktion des HTk-Kernels vermissen. Dennoch sollte es danach leichter
sein, sich weiter in die HTk-Interna einzuarbeiten, denn die wesentlichen
Typen und einige wichtige Funktionen werden hier erläutert. Vorausgesetzt
werden die grundlegende Kenntnis der Tcl/Tk-Syntax (z.B. zur
Objekterzeugung oder deren Konfiguration) und natürlich
Haskell-Kenntnisse. Außerdem wäre es gut, schon ein bißchen \emph{in} HTk
programmiert oder sich zumindest einige der Beispiele angesehen zu
haben.


\section{Externe Repräsentation der Objekte und Konstruktion}

\subsection{Typ}
Zentral bei der Verkapselung eines Tk-Objektes für HTk ist der (abstrakt)
exportierte Datentyp. Dieser ist die externe Repräsentation des jeweiligen
Objektes und dient später als Handle, u.a. um nachträglich
Konfigurationsoptionen zu setzen oder Events an ein Objekt zu binden.
Für das Label-Widget sieht dieser beispielsweise so aus:
\begin{verbatim}
newtype Label a = Label GUIOBJECT deriving Eq
-- ein (Label String) enthält Text, ein (Label Image) ein Bild 
\end{verbatim}
Dieser Typ kann weitere Objekt-spezifische Felder haben, das ist eine
Frage der individuellen Implementierung. Er enthält jedoch immer ein Feld
des Typs \verb|GUIOBJECT| (siehe übernächster Abschnitt).

\subsection{Container}
Objekte, die andere Objekte enthalten, die dann mittels \verb|pack| (d.h.
durch den \emph{pack geometry manager}) oder \verb|grid| (d.h. durch den
\emph{grid geometry manager}) gepackt werden, müssen Instanzen der
Klasse \verb|Container| sein. Diese Klasse enthält keine Methoden,
eine Instanz dieser Klasse wird jedoch immer vorausgesetzt, um ein solches
Objekt als Vaterobjekt bei der Erzeugung anderer Objekte angeben zu
können.
Instanzen dieser Klasse sind beispielsweise Fenster, Frames, aber auch
Canvases (denn diese können wieder Widgets in Embedded Windows enthalten.

\subsection{Konstruktor}
Desweiteren wird immer ein Konstruktor exportiert, der zur Erzeugung der
Objekte dient. Hier unterscheiden wir zwei Schreibweisen:
\begin{itemize}
\item Für Objekte, die nach der Erzeugung noch gepackt werden müssen
(das sind eigentlich nur Widgets), beginnt der Konstruktor mit \verb|new|,
z.B. für ein Label:
\begin{verbatim}
newLabel :: Container par => par ->                  -- Vaterobjekt
                             [Config (Label a)] ->   -- Konfigurationen
                             IO (Label a)
\end{verbatim}
\item Für Objekte, die nicht explizit gepackt werden müssen (z.B. 
Canvasitems oder Menüelemente) beginnt der Konstruktor mit \verb|create|,
z.B. für ein Rechteck auf einem Canvas:
\begin{verbatim}
createRectangle :: Canvas ->               -- enthaltender Canvas
                   [Config Rectangle] ->   -- Konfigurationen
                   IO Rectangle
\end{verbatim}
\end{itemize}
Bei der Erzeugung wird normalerweise ein Vaterobjekt angegeben (außer z.B.
bei Fenstern). Dieses muß für Widgets, die später mittels \verb|pack|
oder \verb|grid| gepackt werden, eine Instanz der Klasse \verb|Container|
sein (s.o.).
Weiter wird meist eine Liste von Objekt-Konfigurationen angegeben, um
deren Verarbeitung man sich im Konstruktor kümmern muß. Ein Beispiel für
einen Konstruktor gibt es später, zunächst jedoch etwas mehr zur internen
Repräsenatation der Objekte und deren Erzeugung und Konfiguration.


\section{Der Typ GUIOBJECT und die Klasse GUIObject}

Der Typ \verb|GUIOBJECT| ist die interne Repräsentation der
verschiedenen Oberflächen-Objekte (im wesentlichen Widgets,
Canvas-Objekte, Menüelemente, aber auch spezielleres wie z.B. Text-Tags
oder Canvas-Tags). Diese interne Repräsentation durch \emph{einen} Typen
ermöglicht z.B. Listen verschiedener Objekte im internen Status zu halten
oder als Funktions-Argumente zu übergeben.

Der \verb|GUIOBJECT|-Wert muß jedoch normalerweise nicht selbst
konstruiert werden, hierzu gibt es spezielle Funktionen
(z.B. \verb|createGUIObject| im Modul \verb|Core|,
\verb|createCanvasItem| im Modul \verb|CanvasItemAux|). Aussehen tut er
wie folgt:

\begin{verbatim}
data GUIOBJECT = GUIOBJECT ObjectID (Ref OST) | ROOT
\end{verbatim}

Den \verb|ROOT|-Konstruktor möchte ich hier nicht weiter erläutern. Er hat
eine spezielle Bedeutung und steht für die Wish-Instanz bzw. das
Hauptfenster, dies muß man aber jetzt nicht verstehen. Für ,,normale''
GUI-Objekte wird ein dem ersten Konstruktor entsprechender Wert erzeugt.
Dieser enthält die \verb|ObjectID|, die dieses spezielle Objekt eindeutig 
identifiziert und eine Referenz auf das zu diesem Objekt gehörende
Statusobjekt (die \verb|ObjectID| und das Statusobjekt werden jedoch
von obiger Funktion automatisch erzeugt, daher will ich hier auch darauf
nicht weiter eingehen).

Der externe Typ muß immer eine Instanz der Klasse \verb|GUIObject| sein:

\begin{verbatim}
class GUIObject w where
  toGUIObject     :: w -> GUIOBJECT  -- Wandeln in interne Repräsentation
  cname           :: w -> String     -- textelle Repräsentation
  cset            :: GUIValue a => w -> ConfigID -> a -> IO w   -- vordefiniert
  cget            :: GUIValue a => w -> ConfigID -> IO a        -- vordefiniert
\end{verbatim}

Die Instanz für ein Objekt sieht dann z.B. für ein Label aus wie folgt:
\begin{verbatim}
instance GUIObject (Label a) where 
  toGUIObject (Label w) = w
  cname _ = "Label"
\end{verbatim}

So kann bei Bedarf durch die Klassenmethode \verb|toGUIObject| der
externe Typ in die interne Repräsentation gewandelt werden. Die
\verb|cname|-Methode liefert lediglich eine textuelle Repräsentation des
Objekttyps und kann z.B. für Debug-Ausgaben benutzt werden. Die Methoden
\verb|cset| und \verb|cget| sind wichtig bei der Implementierung von
Objekt-Konfigurationen und werden im folgenden besprochen.


\section{Konfigurationsoptionen}

\subsection{Der Typ GUIVALUE und die Klasse GUIValue}
Eine ähnliche Verallgemeinerung wie beim Umgangs mit Objekten gibt es auch
für Werte, die die verschiedenen Konfigurationsoptionen der Tk-Objekte
annehmen können. Hierzu gibt es zunächst wieder \emph{einen} Typen, durch
den alle Werte dieser Art intern dargestellt werden. Dies ist der Typ
\verb|GUIVALUE|:
\begin{verbatim}
data Generator = HaskellTk | Tk
data GUIVALUE = GUIVALUE Generator String
\end{verbatim}
Entsprechend gibt es auch wieder eine Klasse \verb|GUIValue|, die im
wesentlichen zum Wandeln in die interne Repräsentation und Angabe von
default-Werten dient. Der Typ eines Konfigurationswertes muß also immer
eine Instanz der Klasse \verb|GUIValue| sein:
\begin{verbatim}
class (Show a, Read a) => GUIValue a where
        cdefault      :: a             -- default-Wert
        toGUIValue    :: a -> GUIVALUE -- wandeln in GUIVALUE
                                       -- für gängige Falle vordefiniert
        maybeGUIValue :: GUIVALUE -> (Maybe a) -- intern, vordefiniert
        fromGUIValue  :: GUIVALUE -> a         -- intern, vordefiniert
\end{verbatim}
Der Typ \verb|Generator| ist hier eigentlich uninteressant. Er wird nur
intern bei der Rückgabe von Tk-Werten, die ja immer als Strings von der
Wish gelesen werden, benutzt. Bei der Implementierung der Methode
\verb|toGUIValue| in der \verb|GUIVALUE|-Instanz wird man also immer
\verb|HaskellTk| als \verb|Generator| angeben. Das zweite Feld des
\verb|GUIVALUE|-Konstruktors muß die Tk-Repräsentation des entsprechenden
Wertes als String, genau so wie dieser auf die Wish ausgegeben werden
soll, enthalten. Diese Repräsentation sollte die \verb|Show|-Instanz, die
von der \verb|GUIValue|-Instanz vorausgesetzt wird liefern (falls dies aus
irgendwelchen Gründen einmal anders ist, reicht es allerdings, die
\verb|toGUIObject|-Methode entsprechend zu implementieren). Umgekehrt
\emph{muß} die ebenfalls vorausgesetzte \verb|Read|-Instanz die
Tcl-Repräsentation in den zugehörigen HTk-Wert wandeln.

Die \verb|toGUIValue| Methode muß man allerdings in der Regel nicht
überschreiben. Sie benutzt sonst einfach die vorausgesetzte \verb|Show|-
Instanz und liefert einen entsprechenden \verb|GUIVALUE| mit
\verb|HaskellTk| als \verb|Generator|. Zu beachten ist dabei allerdings,
daß gewisse Zeichen durch entsprechende Escape-Sequenzen ersetzt werden
und die Zeichenkette in Anführungszeichen gesetzt wird, damit keine
Probleme mit enthaltenen Leerzeichen auftreten. Normalerweise ist
dies so gewollt, kann aber in bestimmten Situation auch unerwünscht sein,
so daß dann die \verb|toGUIValue|-Methode überschrieben werden muß.

Die \verb|cdefault|-Methode liefert schließlich einen default-Wert für
diesen Typen. Normalerweise stehen hier die Tcl-Defaults. Soll ein
default-Wert abweichend davon gelten, muß dieser bei der Erzeugung mit
gesetzt werden (dazu siehe Objekt-Methoden $\rightarrow$
\verb|createCmd|).

\subsection{Interne Repräsentation}
Die interne Repräsentation einer Objekt-Konfiguration ist ein Wert vom
Typ \verb|ConfigOption|:
\begin{verbatim}
type ConfigID = String
type ConfigOption = (ConfigID, GUIVALUE)
\end{verbatim}
Dieser Typ ist ein Tupel aus \verb|ConfigID| und \verb|GUIVALUE|.
Die \verb|ConfigID| ist dabei der Tcl-Bezeichner der entsprechenden
Konfigurationsoption als \verb|String| (ohne das in Tcl beim Setzen von
Konfigurationen übliche Minus, z.B. \verb|font| für eine Schriftart), und
der \verb|GUIVALUE| der Wert der Konfiguration (s.o.).

\subsection{Externe Repräsentation}
Nach außen hin sind Konfigurationen einfach Aktionen, die auf das
entsprechende Objekt angewendet werden können. Sie werden somit wieder
durch \emph{einen} (Objekt-spezifischen) Typen dargestellt, so daß z.B.
eine Liste zu setzender Konfigurationen bei der Erzeugung eines Objektes
angegeben werden kann. Dies ist der folgende Typ:
\begin{verbatim}
type Config w = w -> IO w
\end{verbatim}
Somit ist z.B. eine Konfiguration für ein Canvas-Widget vom Typ
\verb|Config Canvas|.

\subsection{cset und cget}
Bei der Implementierung von Funktionen, die Objekt-Konfigurationen
erzeugen oder abfragen, können die Methoden \verb|cset| und \verb|cget|
der Klasse \verb|GUIObject| benutzt werden:
\begin{verbatim}
  cset :: GUIValue a => w -> ConfigID -> a -> IO w
  cget :: GUIValue a => w -> ConfigID -> IO a
\end{verbatim}
\verb|cset| dient dabei zum Setzen einer Konfiguration und \verb|cget|
zum Abfragen des Wertes einer Konfiguration. Die Benutzung sollte anhand
der obigen Ausführungen klar sein.

\subsection{Vordefinierte Klassen}
Für Konfigurationsoptionen, die für mehrere Objekte benutzt werden,
gibt es im Modul \verb|Configuration| vordefinierte Klassen. Dies
ermöglicht u.a. eine einheitliche Namensgebung und die mehrfache
Verwendung einmal implementierter Methoden. Manchmal ist es aber auch
sinnvoll trotz unterschiedlicher Tcl-Syntax die Methoden einer solchen
Klasse zu überschreiben, um zumindest auf HTk-Seite eine einheitliche
(möglicherweise sinnvollere) Namensgebung zu erreichen.
\\ \\
Ein Beispiel (die Klasse \verb|HasSize|, deren Instanz fast alle
Oberflächenobjekte sind):
\begin{verbatim}
class GUIObject w => HasSize w where
  width       :: Distance -> Config w   -- Breite setzen
  getWidth    :: w -> IO Distance       -- Breite abfragen
  height      :: Distance -> Config w   -- Höhe setzen
  getHeight   :: w -> IO Distance       -- Höhe abfragen
  size        :: Size -> Config w       -- Breite und Höhe setzen
  getSize     :: w -> IO Size           -- Breite und Höhe abfragen

  -- Implementierung der Klassenmethoden
  width s w    = cset w "width" s
  getWidth w   = cget w "width"
  height s w   = cset w "height" s
  getHeight w  = cget w "height"
  size (x,y) w = width x w >> height y w
  getSize w    = getWidth w >>= \ x -> getHeight w >>= \ y -> return (x,y)
\end{verbatim}


\subsection{Objekt-spezifische Konfigurationen}
Funktionen, die nur einfach verwendete Objekt-Konfigurationen setzen bzw.
deren Werte abfragen werden als einzelne Funktionen in den entsprechenden
Modulen implementiert. Da sie sich ansonsten nicht von den im vorigen
Abschnitt beschriebenen Klassenmethoden unterscheiden, wären Sie hier im
Prinzip gar nicht erwähnenswert, wenn nicht \emph{HDoc}, ein
javadoc-ähnliches Dokumentationstool das wir verwenden, leider ein
Problem mit dem oben beschriebenen Typ \verb|Config w| hätte.
Da aber HDoc aber ein Problem mit Funktionstypen hat, gibt es
leider mit obiger Schreibweise eine \emph{parse error}. Daher muß in diesem
Fall der Typ \verb|Config w| ausgeschrieben werden (also als
\verb|w -> IO w|), zumindest bis eine spätere Version hoffentlich
damit zurechtkommt.


\section{Ein internes GUIOBJECT erzeugen}

\subsection{Widgets}
Der interne \verb|GUIOBJECT|-Wert wird für Widgets durch die Funktion
\begin{verbatim}
createGUIObject :: GUIOBJECT ->     -- Vaterobjekt
                   ObjectKind ->    -- Objekttyp
                   Methods ->       -- Objekt-spezifische Zugriffsmethoden
                   IO GUIOBJECT
\end{verbatim}
im Modul \verb|Core| erzuegt werden. Hierbei müssen die folgenden
Parameter angegeben werden:
\begin{itemize}
\item Das Vaterobjekt: Die interne Repräsentation (als \verb|GUIOBJECT|) 
des Containers, der das Widget enthalten soll. Obwohl Widgets erst später
gepackt werden,  muß dieser bereits bei der Konstruktion angegeben werden,
da der Tcl-Pfad zu dem erzeugten Objekt entsprechend (hierarchisch)
gesetzt werden muß.
\item Der Objekttyp: Um auch anhand der internen \verb|GUIOBJECT|-Werte
verschiedene Objekte unterscheiden zu können, gibt es den
\verb|ObjectKind|-Typ:
\begin{verbatim}
data ObjectKind =
    FRAME
  | LABEL
  | MESSAGE
  | BUTTON
...
\end{verbatim}
Für neue Widgets muß hier ein entsprechender Konstruktor hinzugefügt
werden. Er steht im Modul \verb|GUIObjectKind| in
\verb|kernel/GUIObjectKind.hs|.
\item Die Widget-Methoden: Der \verb|Methods|-Typ enthält eine Sammlung
verschiedener Zugriffs-Methoden auf Objekte. Da sich für unterschiedliche 
Objekte die Tcl-Syntax z.B. für das Setzen einer Konfigurationsoption oder
für die Zerstörung des Objektes unterschiedlich sein kann, liefern diese
Methoden eine einheitliche Schnittstelle für den Zugriff auf verschiedene
Objekte (dazu mehr im nächsten Abschnitt). Für einfache Widgets reichen
hier aber meist die Standard-Methoden in den \verb|defMethods| im Modul
\verb|Core|. So wird man auch selten \emph{alle} Methoden selbst schreiben,
in der Regel reicht es, die \verb|defMethods| als Ausgangspunkt zu nehmen
und evtl. einzelne Methoden durch eigene zu überschreiben.
\end{itemize}

Will man keine der Default-Methoden überschreiben, reicht es, die Funktion
\begin{verbatim}
createWidget :: GUIOBJECT -> ObjectKind -> IO GUIOBJECT
\end{verbatim}
aufzurufen. Diese ruft dann \verb|createGUIObject| auf und setzt dabei die
Default-Methoden.
\\ \\
Ein Beispiel für einen einfachen Widget-Konstruktor (Label):
\begin{verbatim}
newLabel :: Container par => par -> [Config (Label a)] -> IO (Label a)
newLabel par cnf =
  do
    w <- createWidget (toGUIObject par) LABEL  -- GUIOBJECT erzeugen
    configure (Label w) cnf                    -- Konfigurationen setzen
\end{verbatim}
\verb|configure| aus dem Modul \verb|Computation| wendet dabei einfach
eine Liste von Konfigurationen auf ein Objekt an und hat die folgende
Funktionalität:
\begin{verbatim}
configure :: w -> [Config w] -> IO w
\end{verbatim}

\subsection{Canvasitems}
Für die Erzeugung von Canvas-Objekten gibt es eine ähnliche Funktion im
Modul \verb|CanvasItemAux|:
\begin{verbatim}
createCanvasItem :: CanvasItem w =>
                    Canvas ->              -- enthaltender Canvas
                    CanvasItemKind ->      -- Objekttyp
                    (GUIOBJECT -> w) ->    -- Wrap
                    [Config w] ->          -- Konfigurationsoptionen
                    Coord ->               -- initiale Position
                    IO w
\end{verbatim}
Diese Funktion gibt im Gegensatz zur oben erwähnten \verb|createGUIObject|
keinen \verb|GUIOBJECT|-Wert, sondern das ,,echte'' Canvas-Objekt zurück
(\verb|createGUIObject| ist allgemeiner, da es auch von den Funktionen
\verb|createCanvasItem| und \verb|createMenuItem|, s.u., benutzt wird).
Da diese Funktion somit auch die externe Repräsentation des Objektes
kennt, ist es hier auch möglich, die Liste der Konfigurationen mit zu
übergeben. Diese werden dann automatisch angewendet.
Parameter dieser Funktion sind:
\begin{itemize}
\item Der Canvas, der das Objekt enthalten soll.
\item Ein Wert, der für Typ des Objektes steht (ähnlich wie
\verb|ObjectKind| für Widgets). Der Typ \verb|CanvasItemKind| steht
ebenfalls im Modul \verb|GUIObjectKind| in \verb|kernel/GUIObjectKind.hs|:
\begin{verbatim}
data CanvasItemKind =
    ARC
  | LINE
...
\end{verbatim}
Für neue Objekttypen muß hier ebenfalls ein entsprechender Konstruktor
hinzugefügt werden.
\item Eine Funktion, die bei Eingabe des erzeugten GUIOBJECT-Wertes das
zu erzeugende Canvas-Objekt liefert. Dies ist meist ein partiell
parametrisierter Konstruktor des externen Typen des erzeugten
Canvas-Objektes.
\item Eine Liste von Konfigurationen für das zu erzeugende Canvas-Objekt.
\item Die initiale Position auf dem Canvas.
\end{itemize}
Ein Beispiel (der Linien-Konstruktor aus dem Modul \verb|Line|):
\begin{verbatim}
createLine :: Canvas -> [Config Line] -> IO Line
createLine cnv ol = createCanvasItem cnv LINE Line ol [(0,0),(0,0)]
\end{verbatim}


\subsection{Menüelemente}
Zur Erzeugung von Menüelementen gibt es schließlich die folgende Funktion:
\begin{verbatim}
createMenuItem :: MenuItem w =>
                  Menu ->                  -- Menü-Container
                  MenuItemKind ->          -- Objekttyp
                  (GUIOBJECT -> w) ->      -- Wrap
                  [Config w] ->            -- Konfigurationen
                  IO w
\end{verbatim}
Diese Funktion gibt ebenfalls das ,,echte'' Menüelement, bzw. dessen
externe Repräsentation, zurück. Sie funktioniert im Prinzip genau wie
\verb|createCanvasItem|. Die Parameter sind:
\begin{itemize}
\item Der enthaltende Menü-Container (dieser kann einem
\verb|MenuButton|-, \verb|MenuCascade|-, oder \verb|Window|-Objekt
zugeordnet werden).
\item Ein Wert, der für den Typ des Objektes steht (wie \verb|ObjectKind| 
für Widgets). Der Typ \verb|MenuItemKind| steht auch im Modul
\verb|GUIObjectKind| in \verb|kernel/GUIObjectKind.hs|:
\begin{verbatim}
data MenuItemKind =
    MENUCASCADE
  | MENUCOMMAND
...
\end{verbatim}
\item Ein ,,Wrapper'', der bei Eingabe des erzeugten
\verb|GUIOBJECT|-Wertes die externe Repräsentation des Menüelementes
liefert (siehe Canvasitems, dies ermöglicht wiederum das Verarbeiten
der Konfigurationen innerhalb dieser Funktion).
\item Die Liste der Konfigurationen.
\end{itemize}


\section{Objekt-Methoden}

\subsection{Tcl-Syntax}
Wie bereits erwähnt dienen die Objekt-Methoden einem einheitlichen Umgang
mit verschiedenen Objekten bzw. deren unterschiedlicher Tcl-Syntax (bei 
Erzeugung, Packen usw.). Genauer gesagt erzeugen sie die jeweils
erforderlichen Tcl-Kommandos in Form eines \verb|TclScript|:

\begin{verbatim}
type TclCmd = String             -- ein einzelnes Kommando
type TclScript = [TclCmd]        -- eine Tcl-Befehlsfolge
\end{verbatim}

\subsection{Tcl-Skripte und Kommandos ausführen}
In bestimmten Situationen, z.B. bei der Implementierung
Objekt-spezifischer Konfigurationsoptionen, kann es sein, daß man solche
Tcl-Skripte oder Kommandos selbst ausführen muß. Hierzu können die
folgenden Funktionen aus dem Modul \verb|Wish| benutzt werden:
\begin{verbatim}
execTclScript :: TclScript -> IO () -- Ausführen eines Tcl-Skriptes
execCmd :: TclCmd -> IO ()          -- Ausführen eines einzelnen Kommandos
\end{verbatim}
(Kompliziertere Methoden, die auch die Antwort der Wish in Form einer
\verb|Tcl-Response| liefern, findet man dort ebenfalls. Auf diese möchte
ich jedoch hier nicht weiter eingehen.)


\subsection{Der Methods-Typ}
Der \verb|Methods|-Typ hat die folgenden Felder:
\begin{verbatim}
data Methods =
  Methods { -- Konfigurationsoption abfragen
            cgetCmd     :: ObjectName -> ConfigID -> TclScript,

            -- eine List von Konfigurationen setzen
            csetCmd     :: ObjectName -> [ConfigOption] -> TclScript,

            -- das Objekt erzeugen
            createCmd   :: ObjectName -> ObjectKind -> ObjectName ->
                           ObjectID -> [ConfigOption] -> TclScript,

            -- das Objekt mit Tk's "pack geometry manager" packen
            -- für "nicht-Widgets" leer
            packCmd     :: ObjectName -> [PackOption] -> TclScript,

            -- das Objekt mit Tk's "grid geometry manager" packen
            -- für "nicht-Widgets" leer
            gridCmd     :: ObjectName -> [GridPackOption] -> TclScript,

            -- das Objekt zerstören
            destroyCmd  :: ObjectName -> TclScript,

            -- Events an dieses Objekt binden
            bindCmd     :: ObjectName -> BindTag -> [WishEvent] ->
                           EventInfoSet -> TclScript,

            -- Event-Bindung verwerfen
            unbindCmd   :: ObjectName -> BindTag -> [WishEvent] ->
                           TclScript,

             -- zum aufräumen bei der Zerstörung, i.d.R. leer
            cleanupCmd  :: ObjectID -> ObjectName -> TclScript }
\end{verbatim}
Auf den Typ \verb|ObjectName| möchte ich hier nicht weiter eingehen. Er
wird durch die oben erwähnten \verb|GUIOBJECT|-Konstruktoren automatisch
erzeugt und enthält den Tcl-Pfad des entsprechenden Objektes. Es reicht zu
wissen, daß er eine Instanz der Klasse \verb|Show| ist und so auf den
Tcl-Bezeichner des Objektes zugegriffen werden kann. Weiter wäre
anzumerken, daß nicht für jedes Objekt tatsächlich \emph{alle} obigen
Parameter gebraucht werden. Dies ist vor allem Abhängig von der Art
der Tk-Objekte (so braucht man z.B. das Vater-Objekte bei der Erzeugung
nur zum Zugriff auf Text-Items).
\begin{itemize}
\item \textbf{cgetCmd:} \newline
Erzeugt ein Tcl-Skript, daß den Wert einer Konfigurationsoption eines
Objektes abfragt. Da der korrespondierende Wert immer eine Instanz der
Klasse GUIValue ist, die eine \verb|Read|-Instanz voraussetzt,
kann er immer parsiert und zurückgegeben werden. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkGetWidgetConfig :: ObjectName ->  -- Tcl-Pfad des Objektes
                     ConfigID ->    -- Tcl-Bezeichner der Konfiguration
                     TclScript
tkGetWidgetConfig name cid = [(show name) ++ " cget -" ++ cid]
\end{verbatim}
\item \textbf{csetCmd:} \newline
Erzeugt ein Tcl-Skript, das eine Liste von Konfigurationen setzt. Der Typ
\verb|ConfigOption| ist einfach ein Tupel aus \verb|ConfigID|
(= \verb|String|) und \verb|GUIVALUE|. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkSetWidgetConfigs :: ObjectName ->       -- Tcl-Pfad des Objektes
                      [ConfigOption] ->   -- Liste der Konfigurationen
                      TclScript
tkSetWidgetConfigs _ [] = []
tkSetWidgetConfigs name args =
  [show name ++ " configure " ++ showConfigs args]
\end{verbatim}
Die Funktion \verb|showConfigs| kann zur bequemen Ausgabe einer Liste
von Konfigurationen in den korrespondierenden Tcl-\verb|String| verwendet
werden:
\begin{verbatim}
showConfigs :: [(ConfigID, GUIVALUE)] -> String
\end{verbatim}
\item \textbf{createCmd:} \newline
Erzeugt ein Tcl-Skript, das das korrespondierende Tk-Objekt konstruiert.
Die dabei übergebene Liste von Konfigurationen kann benutzt werden, um
intern bestimmte vom Tk-Default abweichende Konfigurationen für dieses
Objekt vorzudefinieren. Die im HTk-Konstruktor übergebenen Konfigurationen
werden hier nicht verarbeitet (dies geht aus Gründen, die ich hier nicht
näher erläutern will auch gar nicht). \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkCreateWidget :: ObjectName ->   -- Tcl-Pfad des Vaterobjektes
                  ObjectKind ->   -- Objekttyp
                  ObjectName ->   -- Tcl-Pfad des Objektes
                  ObjectID ->     -- ID des Objektes auf HTk-Seite
                  [ConfigOption] -> TclScript
tkCreateWidget _ kind name _ opts =
  [show kind ++ " " ++ show name ++ " " ++ showConfigs opts]
\end{verbatim}
\item \textbf{packCmd:} \newline
Erzeugt ein Tcl-Skript, das ein bereits auf Tk-Seite existierendes
\emph{Widget} mit dem \emph{pack geometry manager} packt. Diese Methode
wird man niemals überschreiben, denn das Packen eines Widgets ist auf
Tk-Seite einheitlich. Für nicht-Widgets sollte das erzuegte Skript leer
sein.\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkPack :: ObjectName ->     -- Tcl-Pfad des Objektes
          [PackOption] ->   -- Liste der Optionen für den geometry manager
          TclScript
tkPack name opts = ["pack " ++ show name ++ " " ++ showPackOptions opts]
\end{verbatim}
\item \textbf{gridCmd:} \newline
Erzeugt ein Tcl-Skript, das ein bereits auf Tk-Seite existierendes
\emph{Widget} mit dem \emph{grid geometry manager} packt. Auch diese Methode
wird man niemals überschreiben (das Packen eines Widgets ist auf
Tk-Seite einheitlich). Für nicht-Widgets sollte das erzeugte Skript leer
sein.\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkGrid :: ObjectName ->        -- Tcl-Pfad des Objektes
          [GridPackOption] ->  -- Liste der Optionen für den geometry manager
          TclScript
tkGrid name opts =
  ["grid " ++ show name ++ " " ++ showGridPackOptions opts]
\end{verbatim}
\item \textbf{destroyCmd:} \newline
Erzeugt ein Tcl-Skript, das ein Tk-Objekt zerstört. \newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkDestroyWidget :: ObjectName ->   -- Tcl-Pfad des Objektes
                   TclScript
tkDestroyWidget name = ["destroy " ++ show name]
\end{verbatim}
\item \textbf{bindCmd:} \newline
Erzeugt ein Tcl-Skript, das Events an ein Tk-Objekt bindet. Da auch
diese Methode niemals überschrieben werden muß, will ich hier
darauf nicht weiter eingehen. Wichtig ist nur, daß die Show-Instanz
des \verb|ObjectName| den Tcl-Pfad des Objektes liefert, aber dies
ist in HTk sowieso Konvention bzw. wird durch die Methoden zur Erzeugung
der internen \verb|GUIOBJECT|-Repräsentation sichergestellt. Zu bemerken
wäre höchstens noch, daß wir uns für HTk auf einen vereinfachten Umgang
mit den von Tcl zurückzugeben Event-Informationen (Position, Button, etc.)
geeinigt haben, so daß hier immer dasselbe Event-Info-Set verwendet wird
(auch dieser Typ muß daher hier nicht näher erläutert werden). Der
\verb|WishEvent|-Typ sollte von der Benutzerseite her bekannt sein.
\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkBindWidget :: ObjectName ->      -- Tcl-Pfad des Objektes
                BindTag ->         -- historisch, rausnehmen !!
                [WishEvent] ->     -- Liste der Events
                EventInfoSet ->    -- Liste der zurückzugebenden
                                   -- Event-Informationen
                TclScript
tkBindWidget nm bindTag wishEvents eventInfoSet =
  let doBind = "bind " ++ show nm ++ " " ++
               delimitString (foldr (\ event soFar -> showP event soFar)
                                    "" wishEvents) ++ " " ++
               mkBoundCmdArg bindTag eventInfoSet
  in [doBind]
\end{verbatim}
\item \textbf{unbindCmd:} \newline
Erzeugt ein Tcl-Skript, daß Event-Bindungen (s.o.) rückgängig macht, d.h.
auf Tcl-Seite für diese Events ein leeres Kommando bindet. Auch
diese Methode wird niemals überschrieben werden müssen.\newline
\textbf{Beispiel} (die Default-Methode):
\begin{verbatim}
tkUnbindWidget :: ObjectName ->
                  BindTag ->
                 [WishEvent] -> TclScript
tkUnbindWidget nm bindTag wishEvents =
  let doUnBind = "bind " ++ show nm ++ " " ++
                 delimitString (foldr (\ event soFar -> showP event soFar)
                                      "" wishEvents) ++ " {}"
  in [doUnBind]
\end{verbatim}
\item \textbf{cleanupCmd:} \newline
Dieses Kommando ist zur Freigabe auf Tcl-Seite benutzter Ressourcen
bei der Zerstörung eines Objektes vorgesehen. Bisher wird es jedoch nicht
benutzt. Die default-Methode ist daher leer.
\end{itemize}

\end{document}