\documentclass[a4paper,12pt]{article}

\usepackage{isolatin1}
\usepackage{verbatim}
\usepackage{palatino}
\usepackage{color}
\usepackage{xspace}
\usepackage{hyperref}
\usepackage{graphicx}


%%% -- Configuration ----------------------------------------------------

\hyperbaseurl{file://../hdoc/}

%
% Colour setup (to come?)
%

\definecolor{linkcol}{rgb}{0.1,0.1,0.4} % dark blue

\ifx\hypersetup\undefined\relax\else
 \hypersetup{%
    %breaklinks=true,
    colorlinks=true,
    %hyperindex=true,
    pdfpagemode=None,
    linkcolor=linkcol,
    citecolor=linkcol,
    %plainpages=false,
    hypertexnames=false
 }
\fi


%%% -- Useful macros ----------------------------------------------------

%% The code environment typesets its contents verbatim.
\def\code{\verbatim}
\def\endcode{\endverbatim}
%% Same typesetting as code, but different name; this is
%% for code you do not want to show up in literal scripts. 
%% (i.e. the code with syntax errors in it :-)
\def\xcode{\verbatim}
\def\endxcode{\endverbatim}
%% Code snippets in the text:
% \def\codetxt{\textcolor{codecol}\verb} %% hmm...
% \let\MMTextTT=\texttt{}
% \renewcommand{\texttt}[1]{\textcolor{codecol}{\MMTextTT{#1}}}


\title{A Short Introduction to \HTk \\
  Graphical User Interfaces for Haskell}

\author{Christoph Lüth \\ FB 3 -- Mathematik und Informatik,
  Universität Bremen}

\newcommand{\HTk}{\textsc{HTk}\xspace}

\newcommand{\ToBeDone}[1]{\textbf{TBD: #1}}

\begin{document}

\ifx\pdfoutput\undefined\maketitle
\else\includegraphics[width=\textwidth]{img/intro-title}\fi

\section{Getting Started}

This article is an introduction to the basics of \HTk, a toolkit to
build graphical user interfaces (GUIs) in Haskell. \HTk{} is based on
an encapsulation of Tcl/Tk \cite{Ousterhout,Welch}, but we will not
assume any previous knowledge of Tcl/Tk. The article is meant as a
rough guide and introduction to the structure of HTk; it is not meant
as a complete reference manual. Rather, it should give readers enough
information and background to get them started on their first HTk
programs, to know which parts of HTk might be potentially useful in
the applications they have in mind, what is feasible to build with HTk
and what not, and finally to enable them to find further information
quickly in the \href{index.html}{online reference material}. 

For maximum benefit, you should read this text in its PDF incarnation,
and enable your acrobat reader to display weblinks (menu
\texttt{File}, submenu \texttt{Preferences}, submenu
\texttt{Weblink}). If you have configured HTk correctly, then the
hyperlinks in this document should display the corresponding online
material; \href{index.html}{this should take you to the index page.}

\subsection{Basics}

When we design and implement a graphical user interface, we have to
take two aspects into account: the \emph{static} aspect, 
which is to specify its appearance (which buttons to place where, what
menues to display, etc.), and the \emph{dynamic} aspect, which
specifies its behaviour in reaction to the user's actions. 

In \HTk, these two aspects are modelled by \emph{monads}. The dynamic
aspect is modelled in the \texttt{IO} monad, where all of Haskell's
external interactions takes place. The dynamic aspect is modelled by
\emph{events}. For a more complete description of events, we refer to
\cite{ger:Events}. For the time being, events are an abstract datatype
with two main operations.

The central operation is \texttt{sync :: Event a-> IO a} which holds
the current thread until an event of type \texttt{Event a} occurs.
Further, \texttt{(>>>=) :: Event a-> (a-> IO b)-> Event b} takes an
event and an IO action, and returns an event, which when we sync on it
performs the IO action after successful synchronisation. As with the
monad composition, \texttt{(>>>)::Event a-> IO b-> Event b} is the
derived version where the second function throws away its argument.

We can thus prove $fmemoiemfoe$
\begin{itemize}
\item wergrewg
\begin{code}
f x y 
\end{code}
\end{itemize}

Moreover, events form a monad, which allows us to build complex
behaviour from basic behaviours in a compositional way by the monad's
composition.

Events are always embedded in the \texttt{IO} monad with the
\texttt{sync} operation. That the dynamic behaviour is not modelled
with \texttt{IO} actions directly reflects the fact that user
interaction in a graphical user interface is different from other
forms of IO, because it happens \emph{asynchronously}.

Further, events allow the user interface to be concurrent in a natural
and controlled way, which allows for a reasonable degree of
concurrency which is still tractable.

\input{Mainsimple1.lhs}

\input{Mainsimple2.lhs}

\subsection{Structure of this Paper}

The rest of this short paper is organized as follows: we will first
explain the organization of the datatypes modelling the static
behaviour of the graphical user interface. In
section~\ref{sec:events}, we will describe events and in particular
how to generate them from user input. After this, we will describe
every widget in detail.


\section{Elements of \HTk}

In general, \HTk has a couple of abstract datatypes used to model
elements of the graphical user interface, such as buttons, menues,
short text fields, longer text fields and so on. Let us examine the
buttons used in Section~\ref{ssec:ex1} above. There is an abstract
datatype \texttt{Button}, created with the following function
\begin{xcode}
newButton :: Container par=> par-> [Config Button]-> IO Button
\end{xcode}

Let us first examine the class \texttt{Container}. 

\subsection{The GUI element hierarchy and the \texttt{Container} class.}

The class \href{Packer.html#Container}{\texttt{Container}} designates
GUI elements into which other GUI elements may be packed.

Instances of \texttt{Container} include \texttt{Toplevel} (windows),
\texttt{HTk} (Tk's root window), and \texttt{Frame}; furthermore
\texttt{Canvas}, and and \texttt{Editor} (and a few Tix widgets).

The class \texttt{Container} is \emph{abstract} --- it has no class
functions, and only serves to structure the code. Abstract classes are
used frequently in HTk to impose a typing discipline onto Tk's untyped
GUI element structure, with the benefit that type checking can prevent
run time errors.

\subsection{Configurations and Resources}

Above, the text of the button was set with a \emph{configuration
  option}. Configuration options determine various attributes of a
widget. They can be given at the time of creation, or changed later
on. Not every widget supports all configurations, and this behaviour
is modelled in HTk by Haskell's type classes: configurations in
general are polymorphic over all widgets, but particular
configurations are restricted to certain classes of widgets.

For example, the text configuration is given by this class:
\begin{xcode}
class (GUIObject w, GUIValue v) => HasText w v where
  text :: HasText w v => v -> Config w
  getText :: HasText w v => w -> IO v
\end{xcode}
The class \texttt{GUIObject w} is one of HTk's most basic classes. Its
instances are widgets, and other interface elements we will encounter
later (canvas items, text tags). \texttt{GUIValue v} is another basic
class, the instances of which are all basic datatypes which can be
communicated to Tk: \texttt{Int}, \texttt{Double}, \texttt{Bool},
\texttt{String} and \texttt{[String]}. 

Widgets can be configured with a text are instances of the class
\texttt{HasText}, such as \texttt{Button}. 

The configuration classes can all be found in the module
\href{Configuration.html}{\texttt{Configuration}}.

The configuration type is just a type synonym\footnote{Type synonyms
  like that in class confusions confuse Hdoc, which is why they appear
  expanded at various places of HTk's source code--- just in case you
  happen to browse it, which you are more than welcome to.}
\begin{xcode}
type Config w = w -> IO w
\end{xcode}
As seen above, configurations can be given at the time of creation, or
later on. In the latter case, the helpful \texttt{(\#)} operator
provides useful syntactic sugar:
\begin{xcode}
( # ) :: a -> (a -> b) -> b
o # f = f o  
\end{xcode}

Note the difference between configuration options, which determine the
appearance, and behaviour of the widget, and packing options, which
determine the way it is packed. 

\subsubsection{Geometry}

The abstract data type \texttt{Distance}, implemented in the module
\href{Geometry.html}{\texttt{Geometry}}, represents distances in HTk.
Distances can be specified in \texttt{cm}, \texttt{mm}, \texttt{ic}
(inches) and \texttt{pp} (points), with functions  \texttt{cm:: Int->
  Distance}. Moreover, \texttt{Distance} is an instance of
\texttt{Num}, so we can specify the distance 3 (meaning 3 pixels)
directly. 

\subsubsection{Colours}

The abstract data type \texttt{Colour}, implemented in the module
\href{Geometry.html}{\texttt{Geometry}}, represents colours in
HTk. Just like distances, the type itself is abstract, but unlike
distances, there is a class \texttt{ColourDesignator}, the instances
of which give ways of describing colours, such as:
\begin{xcode}
instance ColourDesignator [Char]
instance ColourDesignator (Int, Int, Int)
instance ColourDesignator (Double, Double, Double)  
\end{xcode}
The strings are named colours (\texttt{red}, \texttt{white},
\texttt{black}, etc.), the tuples are RGB values. (The functions of
the type classes \texttt{Colour} and \texttt{ColourDesignator} are for
HTk's internal consumption only.)

\subsubsection{Fonts}

Fonts are implemented in the module
\href{Font.html}{\texttt{Font}}. The datatype \texttt{Font} represents
the specification of exactly one font in the usual (X-style) way,
by giving a family, slant, spacing, width and weight. For example, the
family is given by 
\begin{xcode}
data FontFamily = Lucida | Times | Helvetica 
                | Courier | Symbol | Other String  
\end{xcode}
where the five enumerated types are available on most systems. With
\texttt{Other}, you can directly give a more exotic family such as
\texttt{clearlyu alternate glyphs}. 

The class
\href{Font.html#Font.FontDesignator}{\texttt{FontDesignator}} allows
fonts to be specified in a flexible manner by overloading. This is
used whenever a font has to be specified, e.g. in a text tag or as a
configuration for a label widget. Its main instances are the following:
\begin{xcode}
instance FontDesignator FontFamily where
instance FontDesignator (FontFamily,Int) where
instance FontDesignator (FontFamily,FontWeight,Int) where
instance FontDesignator (FontFamily,FontSlant,Int) where
instance FontDesignator String where
instance FontDesignator XFont where
\end{xcode}
The first three allows fonts to be specified by the font family, plus
the size, plus the weight or the slant, respectively; the second from
last allows an X-style string
(e.g.
\texttt{-adobe-courier-bold-o-normal-*-14-*-*-*-*-*-iso8859-*-}), and
the last an X-style specification as an abstract datatype. 

Be warned that fonts are, in principle, not very portable under X,
since the available fonts are determined by the fonts of the X server
the programm is running on. It is best to stick to well-known font
families such as the above, and usual sizes. 

\subsection{Packing}

\label{sec:packing}

As mentioned above, after widgets have been created (with e.g.
\texttt{newButton}), they will not be displayed yet; this only happens
after they have been packed. One can use this effect by first creating
lots of widgets, and then packing them in one go, lessening the
unpleasant flicker effect occuring when the GUI is built one interface
at a time.\footnote{Unfortunately, this effect cannot be totally
  eliminated.}

Packing in particular determines the visual layout of the GUI by the
order in which the widgets are packed, and by packing options. Tk's
know different packing algorithms (or \emph{geometry managers}, in Tk
parlance); of these, HTk supports the standard packer, and the grid
packer.


\subsubsection{The Standard Packer}

The behaviour of the standard packer is easily explained, and hard to
understand. Widgets are packed with the function
\begin{xcode}
pack::Widget w => w -> [PackOption] -> IO ()  
\end{xcode}

The datatype
\href{PackOptions.html#PackOptions.PackOption}{PackOption}
is defined as 
\begin{xcode}
  data PackOption = Side SideSpec  | Fill FillSpec 
                  | Expand Toggle  | Anchor Anchor
                  | IPadX Distance | IPadY Distance
                  | PadX Distance  | PadY Distance
\end{xcode}
The first two constructors are most important here. The
\href{PackOptions.html#PackOptions.SideSpec}{SideSpec}
specifies where the widget is packed (top, bottom, left, right)e, and
\href{PackOptions.html#PackOptions.FillSpec}{FillSpec}
specifies in which direction it expands to fill the available space.
Bear in mind that widgets are packed as tight as possible (in
particular into windows), and that once packed, they are never
repacked. That is, if e.g. a widget is packed against the top, it will
sit in the middle (if no \texttt{Fill X} is specified), and will not
move if a widget is packed against the right-hand side.

\texttt{Expand} just means that the widget expands when the containing
element is expanded (i.e. the window is resized), and \texttt{Anchor}
specifies a gravity (a side to which the widgets stick). The rest
create a padding border around the widget in various directions.

It is quite normal that most of the times the packing will not look
like intended, and you will need to use frame widgets (see
\ref{ssec:frames}).

\subsubsection{The Grid Packer}

The grid packer divides the container widget into a grid, and allows
placement of widgets relative to that grid. To pack a single widget
use the 
\href{Packer.html#Packer.grid}
{following function:}
\begin{xcode}
grid :: Widget w => w -> [GridPackOption] -> IO ()
\end{xcode}

The datatype
\href{GridPackOptions.html#GridPackOptions.GridPackOption}
{\texttt{GridPackOptions}} specifies the packing options for the grid
packer.

Note that within the same container you cannot use different packing
algorithms. The first widget packed into a container defines the
packing for this container.

\section{Events}

\label{sec:events}

In general, events are an abstract datatype for communication and
synchronisation, much in the spirit of process algebras such as CCS
\cite{Milner:CommunicationConcurrency}, CSP \cite{Hoare,Roscoe} or
the $\pi$ calculus \cite{Milner:PiCalculus}. Here, an 
\href{Events.html}{\texttt{Event}} is
an abstract datatype with operations such as \texttt{sync},
\texttt{+>} and \texttt{>>>=}, which additionally form a monad; we
refer to \cite{ger:Events} for more information. 

In \HTk, events are mostly generated from user interactions by means
of the \emph{bind} commands. By binding a user interaction (such as
clicking a button), we set it up to produce an event, on which we can
synchronise and thus produce a reaction to the user's action.

One important caveat here is that once you set up a binding, you
\emph{must} eventually synchronise on the resulting events, since
otherwise the unused events will pile up and result in a memory leak.

Bindings are generated by calling one of \texttt{clicked},
\texttt{bindSimple} and \texttt{bind}, where \texttt{bind} is most
flexible, which shows up in the type.

\subsection{Simple Clicks}
Simple interface elements such as buttons and menu entries which
  are instances of the class
  \href{HTk.html#HTk.HasCommand}{\texttt{HasCommand}}. For these, we
  have a function
\begin{xcode}    
clicked :: HasCommand w => w -> IO (Event ())
\end{xcode} 
  The event here occurs when the element is clicked. The event does
  not have any additional information. 

\subsection{Simple Binds}
For all GUI elements, the function
  \href{HTk.html#HTk.bindSimple}{\texttt{bindSimple}} 
\begin{xcode}    
bindSimple::GUIObject wid => wid -> WishEventType -> IO (Event (), IO ())
\end{xcode}
where \href{HTk.html#HTk.WishEventType}{\texttt{WishEventType}} is an
algebraic data type describing the kind of event we would like to bind
to, much along the lines of Tk's events which in turn are given by X
events. Each constructor corresponds to a different event, such as
\begin{itemize}
\item mouse buttons pressed and released (\texttt{ButtonPress (Maybe
    Int)}, \texttt{ButtonRelease (Maybe Int)}),
\item mouse movements (\texttt{Motion}),
\item the mouse entering or leaving a GUI element (\texttt{Enter},
  \texttt{Leave}),
\item keys pressed or release (\texttt{KeyPress (Maybe KeySym)},
  \texttt{KeyRelease (Maybe KeySym)}),
\item and various window events (\texttt{Map}, \texttt{Unmap},
  \texttt{Expose}, \ldots).
\end{itemize}
Note that not every GUI element can generate every event. Obviously,
only windows can generate window events, but more subtly, only entry
widgets, editor widgets and windows can generate \texttt{Key} events.

The return value of \texttt{bind} is an event, and an IO action which
unbinds the event. You should use this action if you are not
interested in the event anymore (i.e. it will not be synchronised on
anymore), otherwise there will be a memory leak.

\subsection{Full Bindings}

In fact, \texttt{bind} is only a simplified version of the
  function \href{HTk.html#HTk.bind}{\texttt{bind}}
\begin{xcode}
bind::GUIObject wid => wid -> [WishEvent] 
                       -> IO (Event EventInfo, IO ())
data WishEvent = WishEvent [WishEventModifier] 
                           WishEventType
\end{xcode}
where
\href{HTk.html#HTk.WishEventModifier}{\texttt{WishEventModifier}}
desribes possible event modifiers such as \texttt{Shift},
\texttt{Alt}, \texttt{Meta} (corresponding to the Shift, Alt or Meta
key being held), \texttt{Button1}, \ldots, \texttt{Button5}
(corresponding to mouse button 1 thru 5 being pressed) or \texttt{Double} and
\texttt{Triple}. Again, not all combinations of modifiers and events
make sense; for example, double and triple pertain to mouse button
presses, and modifying a mouse button press with a different button is
not really helpful. Note that the argument of bind is a list of
events, meaning of course that each of the events generates in event
(not only their combination).

Here, the first component of the return value is an event of
\texttt{EventInfo}, which is a labelled record as
follows:\footnote{Unfortunately, HDoc chokes on the relevant part of
  the source right now, so this is not in the reference manual.}
\begin{xcode}
data EventInfo = EventInfo { x :: Distance,
                             y :: Distance,
                             xRoot :: Distance,
                             yRoot :: Distance,
                             button :: Int }
\end{xcode}
The information here is the x and y component of the mouse position,
both relative to the window in which the event occurs, and the root
window (i.e. the screen), and the button being pressed. 

\section{Widgets}

In the following, we give a brief tour around HTk's widgets. These are
essentially Tk's widgets. We have simple widgets which are explained
in short sentences of words with less than three syllables, menues,
text widgets, and canvasses, which require a sllightly longer
explanation. 

There are more widgets: if you can use Tix (you should anyway, it
looks slightly less clunky than plain Tcl/Tk), there are the useful
tab and pane widgets. And because HTk is an abstraction on top of Tk,
there are a variety of so-called \emph{mega-widgets} which are
implemented in Haskell; these can be found in the toolkit
(Sect.~\ref{sec:toolkit}).

\subsection{Basic Widgets}

  
\subsubsection{Frames}

\label{ssec:frames}

A \href{Frame.html}{frame} is just an invisible container into which
we can pack other widgets, grouping them together. The use of frames
is in packing: the grouping is necessary most of the time to achieve
the desired layout with the standard packer.

Moreover, when using a frame, we can use a different packer (see
Sect.~\ref{sec:packing}) than in the parent widget; for example, we
can use the grid packer inside a window using the standard packer.

\subsubsection{Boxes}
  
  \href{Box.html}{Boxes} are mega-widgets, implemented using frames.
  They allow simple horizontal or vertical packing (widgets are placed
  in the box side by side or on top of each other), and be flexible or
  rigid (expand when the parent window is resized, or not); e.g.
  \texttt{newVBox} creates a rigid box with vertical packing, and
  \texttt{newHFBox} creates a flexible box with horizontal packing.

\subsubsection{Buttons}

  A \href{Button.html}{button} is a simple widget which can be
  clicked. Buttons can have bitmaps, images (class \texttt{HasPhoto}),
  or text as labels. 

\subsubsection{Labels and Messages}
  
  A \href{Label.html}{label} is a simple widget for text, bitmaps or
  images. \href{Message.html}{Messages} are slightly more
  sophisticated widgets for longer text messages; messages linebreak
  the text. For both, the font of the text (class \texttt{HasFont})
  and the justification (class \texttt{HasJustified}) can be
  specified.

\input{Mainentry.lhs} %% Entry widgets.

\input{Mainlist.lhs} %% Scrollbars, List boxes.



\subsection{The Editor}

\label{ssec:textwidget}

A editor (also called a text widget). As opposed to labels
and messages, is scrollable (i.e. an instance of class
\href{ScrollBar.html#ScrollBar.HasScroller}{HasScroller}), but its
chief difference to labels and messages are that it can be
\emph{edited} and has \emph{text tags}, which make into one of Tk's
most powerful widgets.

Besides the usual configuration options, you can also
\begin{itemize}
\item set the spacing with the
  methods of the class
  \href{Editor.HasLineSpacing}{\texttt{HasLineSpacing}},
\item set the wrap mode (character, word, or no wrap) with the function
  \href{Editor.html#Editor.wrap}{\texttt{wrap}},
\item and set tabulators with the class
  \href{Editor.html#Editor.HasTabulators}{\texttt{HasTabulators}}. 
  \ToBeDone{How are tabulators specified?}
\end{itemize}

Text can be appended (\texttt{appendText}) or inserted at a specified
position into the editor with the function
\href{Editor.html#Editor.insertText}{\texttt{insertText}}: 
\begin{xcode}
insertText::(HasIndex Editor i BaseIndex, GUIValue a) => 
            Editor -> i -> a -> IO ()
\end{xcode}
The position where the text is inserted is specified by the class
\texttt{HasIndex}.

\subsubsection{Indices}

\label{ssec:indices}

The type \texttt{BaseIndex} also models indices into list boxes, entry
widgets \textit{etc.}, but for editors only the constructor
\texttt{IndexPos} is important:
\begin{xcode}
data BaseIndex =
  IndexNo Int | IndexPos Position | IndexText String 
\end{xcode}
The class \texttt{HasIndex} models which way of indexing a position
inside a widget is valid.\footnote{From an abstract point of view, the
  type class is unfortunate, since the last type parameter is only for
  internal consumption; it models the so-called base index of the
  widget, i.e. the type into which other ways of indexing will have to
  be translated. As a user, you can just disregard the last parameter
  of the class.} For text widgets, we have
\begin{xcode}
instance HasIndex Editor BaseIndex BaseIndex  
\end{xcode}
so we can just specify the index as a position (i.e. a row and column
number, starting from 0), but we can also specify the index by the constant
\texttt{EndOfText} (only constructor of the data type
\texttt{EndOfText}), or by its screen coordinates (\texttt{Pixels}),
or by \emph{modifying} one of the other indices:
\begin{xcode}
instance HasIndex Editor EndOfText BaseIndex
instance HasIndex Editor Pixels BaseIndex
instance HasIndex Editor i BaseIndex => 
         HasIndex Editor (i, [IndexModifier]) BaseIndex
instance HasIndex Editor i BaseIndex => 
         HasIndex Editor (i, IndexModifier) BaseIndex  
\end{xcode}

Index modifiers (only for editors) are modelled by type
\href{Editor.html#Editor.IndexModifier}{\texttt{IndexModifier}}, and
specify things like ''three words forward'', or a ''one line
backwards''.

\subsubsection{Selections}

\label{ssec:selections}

In an editor (and an entry widget), text can be \emph{selected} by
marking it with the mouse button. Similarly, in list boxes, entries
can be selected. Abstractly, these kind of selections are modelled
with the selection type classes (module
\href{Selection.html}{\texttt{Selection}}). There are five classes, of
which \texttt{HasSelection}, \texttt{HaseSelectionIndex} and
\texttt{HasSelectionIndexRang} let you set the selection, and
\texttt{HasSelectionBaseIndex} and \texttt{HasSelectionBaseIndexRange}
let you query the selection. The selected text, entries \textit{etc.}
are indexed with indices (see Sect.~\ref{ssec:indices}). The
\texttt{Range} classes have a pair of functions, which set or get the
start or end of the selection, respectively, whereas the
\textit{HasSelectionIndex} and \texttt{HasSelectionBaseIndex} classes
get or set the selection as list of indices.

This selection is Tk-internal, and should not be confused with
selection as implemented by X Windows. This selection is handled by
the class \texttt{HasXSelection}. Its instances are entries and
editors. For those, Tk's selection can also be the X selection. The
module \href{XSelection.html}{\texttt{XSelection}} allows access to
the X selection (get the current selection, selecting wether widgets
export their selection etc.)


\subsubsection{Text Tags}

A text tag is a way of marking a specified section of the text. One
text tag can mark a list of ranges, which are specified by a start and
an end index: 
\begin{xcode}
createTextTag :: (HasIndex Editor i1 BaseIndex,
                  HasIndex Editor i2 BaseIndex) =>
                 Editor -> i1 -> i2 -> [Config TextTag] -> IO TextTag  
\end{xcode}
Once we have a text tag, we can \href{TextTag.html}{configure
 it}. It has a font, colour, cursor, justification, line spacing,
wrapping, tabulators and so on. Moreover, you can bind events to a
text tag, making it active; so when the mouse moves over the text, or
the user clicks the text, something exciting happens. This allows you
very easily to implement hypertext, references and so on. 

When you insert into an editor, the text tags are accommodated
appropriately; i.e. if you insert into the middle of a text widget,
then the end of the tag is moved.

As mentioned above, a text widget can be edited, i.e. the user can
type text into the widget. This feature can be considered just as a
conveniently set up set of key bindings (e.g. the key \texttt{a} is
bound to the function which inserts an \texttt{a} at the current
cursor position). You can switch off the editing behaviour with the
function \texttt{disable} from the class
\href{Configuration.html#Configuration.HasEnable}{\texttt{HasEnable}},
but be warned: \emph{You can only change the text of enabled editors!}
Trying to insert text into a disabled editor is one of the most Tk
errors; it will not generate a run-time error but just silently fail
to change the text of the editor.

The example \texttt{simple/Maintexttag.hs} shows what you can do with
text tags, and how to use them. The module \texttt{MarkupText} allows
a more abstract approach to displaying text with differents fonts,
hyperreferences and so on (see below).

\subsubsection{Marks and More}

To keep track of positions within an editor, you can use marks (type
\href{Mark.html}{\texttt{Mark}}).\footnote{The first one to send us an
  email saying ``Shouldn't this type have been renamed to Euro?''
  will be forcefed Perl scripts until his mind explodes into a regular
  expression. You have been warned.} Essentially, you can put a mark
into an editor at a specified position (with \texttt{createMark}), and
query its position later (\texttt{getBaseIndex}). The gravity of the
mark specifies wether when text is inserted at the exact position of
the text, it should move to the left, or the right.

There's more you can do with an editor. For one, you can also insert
widgets into the text (this is called an embedded window), so you can
have buttons (and yes, even another editor) inside an editor. 

Further, you can search the text inside an editor (with the
\texttt{search} function), read and write the contents to and from a
file, scroll the contents to a specific position, and much more as
found in the module \texttt{Editor.html}{\texttt{Editor}}.

\subsection{The Canvas Widget}

A canvas is a widget to draw on, i.e. we can put graphical objects on
it (lines, polygons, circles and ellipses, wee images, and even whole
widgets) at a specified position. A canvas is scrollable, so its
drawing area can be far larger than the displayed area.

The graphical objects on a canvas are called \emph{canvas items}. Just
like for widgets, the different kinds of canvas items are represented
by different types. Canvas items can be configured, but of course the
configurations are mostly different from widget configurations.

\subsubsection{Canvas Item Configurations}

The most important configurations, provided by all canvas items, are: 

\begin{itemize}
\item \texttt{HasCoords} sets or returns the coordinates of the canvas
  item on the canvas.
\item \texttt{FilledCanvasItem} allows to configure the filling
  colour, outline colour, stipple and width of the outline of the
  canvas item. Note that for some canvas item (e.g. lines), setting
  the outline does nothing, but setting the filling colour sets the
  colour of the item. A stipple, incidentally, is a bitmap mask used
  to draw the item. 
\end{itemize}

\subsubsection{Canvas Items} 

The following are the types of canvas items:

\begin{itemize}
\item \texttt{Arc}: a section of an oval, given by the start angle and
  the length (configurations \texttt{start} and \texttt{extent}).
\item \texttt{BitmapItem} and \texttt{ImageItem}: canvas items given
  by bitmaps and images. The image of an image item is set with the
  \texttt{HasPhoto} class, just like for some widgets.
\item \texttt{LineItem}: a line item is given by a list of two or more
  points, which define a list of line segments. The segments can be
  joined in various ways (with the \texttt{joinstyle} configuration),
  you can draw splines (class
  \href{CanvasItem.SegmentedCanvasItem}{\texttt{SegmentedCanvasItem}}), and put arrows on the either (or both) ends (configurations \texttt{arrowshape} and \texttt{arrowstyle}). 
\item \texttt{Oval}: an oval is either given by defining its
  \emph{bounding box}, i.e. the smallest rectangle enclosing it. If
  the bounding box is a square, the oval is a circle.\footnote{Except
    it usually won't \emph{look} like a circle on the screen, because
    on most screens pixels are rectangularly-shaped.}
\item \texttt{Polygon}: a polygon is given by a list of
  vertices. Strangely, one cannot configure the join style of the
  polygon, but you can configure splines.
\item \texttt{Rectangle}: a rectangle is given by two points. 
\item \texttt{TextItem}: a text item is a text, possibly consisting of
  more than one line. It is an instance of \texttt{HasFont}. (Note
  that Htk does not support Tk's selection and insertion methods for
  text items; it should be easy to add, if you really require that.)
\item \texttt{EmbeddedCanvasWin}: an embedded canvas window is a
  widget embedded into a canvas. All instances of class
  \texttt{Widget} can be embedded into a canvas. Note that you don't
  need to pack embedded widgets; they appear as soon as the embedded
  canvas window is created.
\end{itemize}

\subsubsection{Canvas Tags}

A \emph{canvas tag} is a convenient way to refer
to canvas items. A canvas tag is an instance of the class
\texttt{CanvasItem} (but setting e.g. its filling colour will of
course have no effect). Canvas tags are in particular useful because
you can not only add canvas items explicitly to the tag, but also by
the so-called \texttt{search specification}. 


\subsection{Miscellenea}

\begin{itemize}
\item images
\item window managers
\item focus
\end{itemize}

\subsection{Tix Widgets}

Using tix.

Panes and notebooks.

\section{The Toolkit}

\label{sec:toolkit}

The toolkit contains a number of so-called \emph{mega-widgets}; these
are widgets which are implemented in Haskell rather than Tcl/Tk. We
just mention the these widgets here, without explaining them in
detail, and show some screen shots. For most of them, their usage is
pretty obvious. 

The examples mentioned below can be found in
\texttt{examples/toolkit}.

\begin{itemize}

\item The module \texttt{DialogWin} contains an abstraction for
  dialogue windows, and built on top of that, frequently used windows,
  such as error, warning, information, and confirmation windows. See
  the example in \texttt{Maindialog.hs}.

\item The module \texttt{MarkupText} provides an easier, more abstract
  and flexible way of filling an editor with markup text. For example,
  you can simply write 
\begin{xcode}
 [prose "This is ", bold [prose "BOLD"], 
  prose " and ", bgcolour [prose "yellow."]]
\end{xcode}
 without needing to count the indices for the text tags
 manually. Hypertext, embedded widgets, mathematical symbols and much
 more are also supported. See also the example in \texttt{Mainmarkup.hs}.
 
\item A \texttt{SpinButton} is a entry with two arrows which can
  increment or decrement the entry's value. See the example in
  \texttt{Mainspinbutton.hs}.

  
\item A \texttt{TreeList} is a graphical representation of a tree
  structure. It allows subtrees to be hidden or shown. One popular use
  of this is to display the file system (see example
  \texttt{Maintreelist}), but the possibilities are manyfold.
  
\item The \texttt{Notepad} is a canvas which displays \emph{items}. An
  item is given by the class \texttt{CItem}; it has a name and an
  icon. The notepad lets the user arrange the icons by dragging them
  around, and allows drag-and-drop between items.

\item The generic \texttt{GenGUI} interface allows the visualisation
  of items which are arranged in a hierarchical structure. It uses a
  tree list to display the hierarchy, a notepad to display all items,
  and an editor to display a single item selectable by
  double-clicking. See the examples in \texttt{examples/gengui}.

\item The module \texttt{LogWin} implements a log window, a scrolled
  toplevel in which text is displayed, to which the program can
  append. The user can clear the whole text, or save it to a file. 

\item \texttt{ModalDialog.hs} takes a toplevel (i.e. a window), and
  implement a modal dialogue with it. A window is called \emph{modal}
  if it has be answered before the program is allowed to proceed.


\item Small mega-widgets: 
  \begin{itemize}
  \item A \texttt{ScrollBox} is a scrollable widget inside a box scroll
    bars attached.
  \item A \texttt{Separator} is a frame with relief and borderwidth,
    to optically separate widgets.
  \item A \texttt{SelectBox} is a container for a group of buttons,
    one of which can be nominated as default button.
  \item An \texttt{IconBar} is a bar containing a row of buttons
    (ideally of the same size showing an image, but this is not
    enforced.) 
  \end{itemize}
  
\end{itemize}


\bibliography{intro}
\bibliographystyle{plain}

\appendix{}

\input{MainHsMines.lhs}



\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
