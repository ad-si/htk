\section{The hsMines Game}

As an example for more complex GUI programming, we will now develop a
GUI for a minesweeper like game called hsMines. Just in case you do
not know Minesweeper or some of its many clones I'll give a short
overview.

\subsection{What's that game?}
Playing Minesweeper you have a grid of about 20x20 similar
fields. Below any of this fields could be a mine or just an empty
field -- you wont know until you click at the field and are eventually
shred to pieces by some nasty mine. Goal of the game is to find all
the mines an mark them with tiny flags. An nearly impossible task. To
make the game any fun you are told the exact amount of mines around
the field you just opened. If this number is 0, it's safe to explore
all the adjacent fields. And because this is a stupid task the
machine does it for you. If you manage to explore all empty fields you
win, if you find one of the mines, you lost, best time gets the
highscore. Simple as that.

For this is not a course in haskell programming I will not spent any
words on the games code itself and will come straight to the very
heart of this section, the hsMines GUI.


\subsection{In the beginning\dots}
\dots, as you should have read, is the window. And for we are running
compiled code here, it's created in the \texttt{main} function.
\begin{code}
main = 
 do htk<- initHTk [withdrawMainWin]
    run htk normalSize 

run :: HTk-> (Int, Int)-> IO ()
run htk currentSize = 
 do main <- createToplevel [text "hsMines"]

finishHTk
\end{code}

Having only this, the GUI would look rather boring, but it's not bad
for just a few lines of code, isn't it? It looks a bit bent in a loop
but we will see later that this is needed to make the field
resizeable.\\
The last line is necessary to clean up all the events we've kicked
loose so far.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{img/Screenshot01}
\caption{The hsMines window}
\end{center}
\end{figure}

\subsection{Menus}

What would a GUI be without them? Somewhat empty as it seems. So let's
create some menus.

\begin{code}
    menubar <- createMenu main False []
    main # menu menubar

    fm <- createPulldownMenu menubar [text "File"]

    restb <- createMenuCommand fm [text "Restart"]
    qutib <- createMenuCommand fm [text "Quit"]

    pm <- createPulldownMenu menubar [text "Preferences"]
   
    pmc1 <- createMenuCascade pm [text "Size"]
    pmc1m <- createMenu main False []
    pmc1 # menu pmc1m
        
    pmc2 <- createMenuCascade pm [text "Difficulty"]
    pmc2m <- createMenu main False []
    pmc2 # menu pmc2m
\end{code}

To this point we create a number of menus and pulldowns. Let's go
through this step by step.
In line 1 we create an menu inside \emph{main} (our window) that was
created in \texttt{run}. In line 2 we tell \HTk to asign this new menu
we call \emph{menubar} to be the menu of \emph{main}.\\
In line 3 (we will not count the empty lines), we create our first
pulldown menu -- that is what actually is normaly called a menu. This
pulldown menu is created inside \emph{menubar}, is called \emph{fm}
and has the charming text "`File"'. For not leaving this menu (or
pulldown menu) empty, we create menu entrys so called menu commands
inside \emph{fm}. So by now we have \emph{restb} and \emph{quitb}
inside \emph{fm} inside \emph{menubar} inside \emph{main}.\\
This is quit nice but we will try to put some more functionality into
our menu besides restarting and quiting the game. And as we read
above, the game grid will be resizeable so we will need another menu
to have these commands in.\\
We create a second pulldown menu in \emph{menubar} called
\emph{pm}. In this menu we nest to submenus called menu
cascades. Each of the cascades has a name, \emph{pmc1} and
\emph{pmc2}, and a String set to it's text. The next step is a bit
tricky. One would expect now to fill the cascades directly with some
commands. But the menu cascades are only containers fit to hold a
menu. So we have to create another two menus inside main and asign
them to the two cascades. These two menus are called \emph{pmc1m} and
\emph{pmc2m} which should be an abreviation "`Prefernce Menu Cascade
1's Menu"' respectivly 2.\\
By now we have a menu which holds two pulldown menus. The
first contains two commands, the second contains two cascades which in
turn each contain a menu again. To make sense of these menus we have
to fill them of course. And finally we have to put some functions
behind those commands and what so ever or this would all be for
naught.

\begin{code}
    varSize <- createTkVariable currentSize
    sr1 <- createMenuRadioButton pmc1m [text "tiny (6x6)", value tinySize,
                                        variable varSize]
    sr2 <- createMenuRadioButton pmc1m [text "small (10x10)", value weeSize,
                                        variable varSize]
    sr3 <- createMenuRadioButton pmc1m [text "normal (15x15)", value normalSize,
                                        variable varSize]
    sr4 <- createMenuRadioButton pmc1m [text "large (20x20)", value bigSize,
                                        variable varSize]
    sr5 <- createMenuRadioButton pmc1m [text "huge (25x25)", value hugeSize,
                                        variable varSize]

    varDiff <- createTkVariable (6:: Int)
    dr1 <- createMenuRadioButton pmc2m [text "easy", value (8::Int),
                                        variable varDiff]
    dr2 <- createMenuRadioButton pmc2m [text "normal", value (6::Int),
                                        variable varDiff]
    dr3 <- createMenuRadioButton pmc2m [text "hard", value (4::Int),
                                        variable varDiff]
    dr4 <- createMenuRadioButton pmc2m [text "nuts", value (3::Int),
                                        variable varDiff]
\end{code}
In the code above we do several new things. First we create a new Tk
variable named \emph{varSize} and a few lines later one called
\emph{varDiff}. These are necessary to remember things we do to our
GUI like in this case switching a button.
Our next step is to create a menu radio button\footnote{
  A radio button is a button with several instances. Each of the
  instances is shown, can be selected and is bound to a different value
  but to the same variable. By selecting one of the instances the
  according value is asign to the variable. Because a variable can
  only have one value at a given time, only one of the instances can
  be selected.}
in each of the two submenus. The first radio button asigns tuples of
Int to the Variable \emph{varSize}, the actual values are given in a
couple of functions above in the code which can be fully seen in the
appendix.
% Hier beachten! Code muss in Appendix!
% Evtl. können die Funktionen auch wieder gelöscht und hier die
% konkreten Zahlen eingesetzt werden. Eigentlich müssten andernfalls
% die anderen Zahlen (für die Schwierigkeit) auch in Funktionen
% ausgelagert werden. So ist das inkonsequent.
As you we can see in the code above (in \texttt{main} and
\texttt{run}), currentSize holds the value of normalSize and so by
default the radio button is set to normalSize. Nearly the same happens
to \emph{varDiff} and it's radiobutton just without the hiding
functions.\\
The values of varDiff have to be explicitly casted because by default
TkVariables contain Strings. But still nothing happens besides setting
two varaibles.

\begin{code}
    restartClick <- clicked restb
    quitClick <- clicked quitb

    csr1 <- clicked sr1
    csr2 <- clicked sr2
    csr3 <- clicked sr3
    csr4 <- clicked sr4
    csr5 <- clicked sr5

\end{code}

This rather cryptic peace of codes allows us to bind the commands and
the size radio button(s) to a couple of events. These will occure now
whenever one of the buttons is selected -- "`clicked"'.

\begin{figure}[h]
\begin{center}
\includegraphics[scale=0.6]{img/Screenshot02}
\caption{The hsMines main window with an open Prefs/Size menu}
\end{center}
\end{figure}

\subsection{The field}

To make all the decoration perfect, wie need the little smiley atop
the playfield which can be used to restart the game.
\begin{code}
    sm <- newButton main [text ":-)"]
    restart2Click <- clicked sm

    pack sm [Side AtTop, PadY 20, PadX 20, Anchor North] 
\end{code}
So we create a Button called sm (from \textbf{sm}iley btw) and bind it
to another Event. And because the GUI does not automaticaly know where
and when to place the button we have to tell it to \texttt{pack sm at
  the top of the main window, pad it 20 pixels wide in any direction
  and keep it align to the upperside} (which is North on most maps).

% \begin{figure}[h]
% \begin{center}
% \includegraphics[scale=0.6]{Screenshot3}
% \caption{The hsMines main window with smiley}
% \end{center}
% \end{figure}

I also opened the second menu so you could see Huey, Dewey and
Louie\dots

\begin{code}
    restartCh <- newChannel

    let size= (20, 20)

    bfr <- newFrame main [width (cm 10)]
    allbuttons <- buttons bfr sm (receive restartCh) size 

    pack sm [Side AtTop, PadY 20, PadX 20, Anchor North]

    pack bfr [Side AtTop, PadX 15] 
    mapM_ (\(xy, b)-> grid b [GridPos xy]) allbuttons
    
    -- start the menu handler
    spawnEvent (forever (restartClick >>> sendIO restartCh ()
                      +> restart2Click >>> sendIO restartCh ()
                      +> quitClick >>> destroy main))

\end{code}
To get it realy started we create an IO-channel named restartCh. Then
we create a new Frame (a container widget) with a fixed width and do
somethin strange about allbuttons. Of course this is not that strange.
A function (buttons) is called with some complex arguments and the
result is asigned to allbuttons. We will cover this just some lines
later.

The Frame is packed below the smiley button. They both are told to be
at the top of main, but because only one of them can be there they're
placed below each other in packing order.

To have something to happen with the buttons an Event is spawned. This
single Event listens to some GUI Events we bound some of our buttons
to. Whenever (the Events last until the destruction of the main
thread) one of these three Events occurs, a function is called. The
smiley button and the restart command in the File menu both send an IO
command via the initialised IO channel, the quit command initiates the
destruction of the window and thereby the main thread. If this
happens, finishHTk at the end of the source is reached and the garbage
collection can free all used RAM. But if we don't press one of the
restart buttons, nothing will happen with the many buttons we created
and they all just show a question mark.

% \begin{figure}[h]
% \begin{center}
% \includegraphics[scale=0.2]{Screenshot4}
% \caption{The uninitialised playfield of hsMines}
% \end{center}
% \end{figure}

So all that is left to do in the main function is to initiate the game
for the first time.

\begin{code}
    sendIO restartCh ()
\end{code}

That's all so far. But as you allready know, something happens to
allbuttons in between.

\subsection{The buttons function}

This function has a rather complex signature.

\begin{code}
buttons :: Container par=> par-> Button-> Event() -> (Int, Int)
                           -> IO [((Int, Int), Button)]

\end{code}

For comparison lets have another look on how it's called:

\begin{code}
    allbuttons <- buttons bfr sm (receive restartCh) size   
\end{code}

We have a class restriction on the first argument, par, which has to
be a container. par happens to be just that, a Frame. Lucky us. The
next argument has to be a button as we can happily admit our smiley
buttons is. The third argument has to be an Event. This Event occurs,
when some IO() is send via the IO Channel restartCh and is received by
receive. The last argument is a 2-tuple of Int which is the size of
the game field. Because size is a function with no arguments (thereby
it's a constant value), the field's size can not be changed.

%An dieser Stelle könnte man doch eigentlich wunderbar das Menu
%Preferences ins Spiel bringen und eine Reihe von Auswahlgrößen (aka
%Schwierigkeitsleveln) einbauen, oder?

When buttons has done it's work, it will return an IO of a list auf
tuples of tuples of Int an a Button. As you see it is simpler to watch
the signature yourself than to try to puzzle out what I just told you.

The code of buttons is simple a start.


\subsubsection{Create an array of buttons,\dots}

\begin{code}
buttons par sb startEv (size@(xmax, ymax)) =
  do buttons <- mapM (\xy-> do b<- newButton par [text "?"]
                               return (xy, b)) [(x, y) | x <- [1.. xmax],
                                                         y <- [1.. ymax]]
\end{code}

This code is executed no matter what startEv might be! It creates all
the buttons and writes a quotationmark inside so the playfield looks
the way the Figure above shows it.%Verweis auf Figure?
But there is more to happen in the buttons function!


\subsubsection{bind them\dots}

\begin{code}
     let bArr = array ((1,1), size) buttons
         getButtonClick b n xy = 
            do (click, _) <- bindSimple b (ButtonPress (Just (BNo n)))
               return (click >> return xy)
     leCl <- mapM (\(xy, b)-> getButtonClick b 1 xy) buttons
     riCl <- mapM (\(xy, b)-> getButtonClick b 3 xy) buttons
\end{code}

This looks rather complicated but does nothing more than what we did,
when we bound the smiley button to the restart2Click Event. It's just
that we bind the whole Array of buttons we created via a slightly
adjusted Event (\texttt{getButtonClick b 1/3 xy})\footnote{
  As you could surely guess, 2 would be the modifier to get the center
  button bound.
} to two Events.


\subsubsection{and start\dots}

\begin{code}
     spawnEvent start
     return buttons
\end{code}

At the end, we spawn an Event called start and wait. But wait what
for? As you remember an Event is handed over to buttons. And this
event is used to get the game finaly running.

\begin{code}
         start :: Event ()
         start = startEv >>> do m <- createMines (snd (bounds bArr))
                                mapM_ (text " ") (elems bArr)
                                sb # (text ":-)")
                                sync (play m)
\end{code}

This says: If the Event start occurs (by being spawner for example)
and if startEv is the same kind of Event as start (and occurs at the
same time, that is), we execute some more code. Have a look on how we
create mines later, it's of no importance for the GUI. We map over all
elements in the button array and write `` '' to their text. Then we
asign a new smiley to the text of sb (mapM\_ does the same to all the
buttons) and synchronize the start Event to the play Event. No new
Event is created, start just changed into play.

\subsubsection{to play\dots}

\begin{code}
         play :: Mines-> Event ()
         play m = do r <- choose leCl >>>= open bArr m
                     case r of Nothing -> always gameLost >> gameOver
                               Just nu -> play nu
                  +>
                  do r<- choose riCl >>>= flag bArr m
                     play r
                  +>
                  start 
\end{code}

Playing is easy. To play with a set m of mines means to execute three
steps over and over again.

\begin{enumerate}
\item If the left mousebutton is pressed, execute open with the
  button array and the mines. If nothing is left, you loose. If there
  are mines left, you play on.
\item If the right mousebutton is pressed, execute glag with the
  button array and the mines. No evil may occur, just play on.
\item If thing go awry, goto start and wait for the startEv Event.
\end{enumerate}


\subsubsection{until it's over.}

gameLost is just an alert Window to open, to tell you that you've
lost that also changes your smiley into a freak. You are allowed to
kill the messenger.

\begin{code}
         gameLost :: IO ()
         gameLost = do createAlertWin "*** BOOM!***\nYou lost." []
                       sb # (text "X-(")
                       done
\end{code}

Only after you finished up the messenger, the game is realy over, the
\verb§>>§ operator takes care of that.

\begin{code}
         gameOver :: Event ()
         gameOver = start 
                    +> 
                    (choose (leCl++ riCl) >> gameOver) 
\end{code}

gameOver is the Event to take over. It leads you back to the start
event, waiting for the startEv Event to occur. If any of the ingame
Events occur, because some dumbhead did not understand the "`BOOM! You
lost."' message or what so ever, the game is still over and nothing
changes.

That's it, anything else is just plain haskell. Naugh, you're right,
there is some tiny tidbits left. Nobody explained how the numbers show
up when an non mine field is explored, right? Okay, we'll come to that
now.

\subsection{Fuzzing around on the play field}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "intro"
%%% End: 

