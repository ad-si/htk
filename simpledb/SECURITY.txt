This document describes the proposed security model for MMiSS, both at the
high level, as seen by the user, and at the low-level, as seen at the
interface to UniForM's (extremely basic) database model.
               George Russell 25th October 2002.

Users
-----

Each user has a user-id.  The user-id is a String.  The user "logs in" somehow
by obtaining an SSH connection (I don't know how this is done but I'm sure 
it's possible) with that user-id; after this the server knows who the user is.
We describe a user by the Haskell type User.

Groups
------

A group corresponds to a list [Either Group User].  Thus groups can include 
users and also recursively other groups, all of whose users themselves
inherit the privileges of the group.

Permissions
-----------

A permission describes the access a user may have to an object.  It corresponds
to the Haskell type

   data Permission = Permission {
      readAccess :: Maybe Bool,
      writeAccess :: Maybe Bool
      }

Just True means access is permitted; Just Nothing that it is forbidden.
Nothing is a don't know, meaning this permission is not applicable.

Access Classes
--------------

An Access Class corresponds to a collection of objects in the database; it
describes what access any user has to those objects.  The access class
corresponds to the Haskell type 

   data AccessClass = AccessClass {
      permissions :: [(Group,Permission)],
      parent :: Maybe AccessClass
      }

To determine the permission the user has for a particular access class
for reading, we scan down the permissions list looking for the first element 
such that (a) the user belongs to the Group; (b) readAccess is Just (True or 
False).  The value (True or False) is to determine whether access is granted 
or not.  If no such element is found, we look at the parent value.  If that
is Just accessClass we repeat with that accessClass (and if necessary, with
parents of that accessClass, and so on and so on).  If it is Nothing we
do not give permission.  Checking write access is exactly the same except we
check the writeAccess fields.

Groups and Access Classes as Objects
------------------------------------

Groups and Access Classes will be objects in the Workbench, just like anything
else.  Every object visible by the user (though not, for example, variants
of the same object) will have its own unique AccessClass object, which
will be displayed (at least, if requested) by daVinci.  When an object is
created in a folder, the "parent" access class will be the access class of
the folder.  An AccessClass object
can be edited (a special editor will be provided), assuming of course its
AccessClass permits.  An AccessClass object in turn references various
Groups.  Groups themselves will be objects and themselves will be editable.
There will (probably) be a special folder containing the top-level groups;
anyone creating a new group will need write access to this special folder.

Low-level Implementation
------------------------

This strategy is designed so that the server needs to know as little as 
possible about the structure of the objects themselves.  It needs to be
able to parse AccessClasses and Groups but that is straightforward.  It needs
to parse and control the list that specifies what versions of each object 
appear in a particular (global) version; at the moment that list is itself
a database object, but in view of this it should probably be transferred
to a server structure.  Anyway there is nothing much challenging here.

The most challenging problem will be integrating this with the Berkeley DB.
At the moment we use a standard BDB server program which has no security
features.  Although the BDB API allows you to establish a connection over
SSH, there is no server program that does this.  So we would need to write
a special server program (starting probably with the source to the BDB server
program) that does this, and also does the security checks.  This can be
written entirely in C, but it may be more convenient (and more secure!) to
call into Haskell to do some of the computation.

Limitations
-----------

Because we have (deliberately) avoided making the security policy depend on 
the structure of individual objects (apart from AccessClass and Group objects
themselves), this limits what we can do in some ways; for example we can't
set a policy for a folder that new items may be written to it, but old ones
may not be edited or deleted, nor can we set a policy for an MMiSS object
where variants in the same version have differing permissions.  The best way
to fix this might be to add an extra optional String field to the Permissions 
type permit different object types to process this in some way.  This would 
allow the server to run this code in the workbench.  However I recommend that 
we do not do this in the beginning.

I do not think users themselves should be MMiSS objects in the beginning,
since the user database will need to be accessible by SSH (however it does it)
and so is probably going to be something like a plain text file.  If we
can't find a public domain tool which makes it easy to update this database,
the administrator will have to do so via XEmacs.  (Like the CVS repository 
password file . . .)
