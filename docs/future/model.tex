\documentclass[a4paper]{article}
%% an environment for bits of the texts which have been changed
% \newenvironment{changed}{\chgbarbegin}{\chgbarend}

\setlength{\parindent}{0mm}
\setlength{\parskip}{.5ex}


\begin{document}

{\Large{The UniForM Object Model}}

\rule{\textwidth}{.2pt} 

%% \\[1ex]

\today 
\hfill
\begin{tabular}[t]{l}
George Russell \\
\end{tabular}\\[3ex]
NB.  Although we have used ``CVS'' throughout this document for the
system used to store files in the repository, our only interface to
CVS is a fairly small one, which only uses a few of its features;
it should therefore not be difficult to replace CVS by any other
system for efficiently storing versioned text files.
\section{Objects}
An Object is the main way things are stored in the repository.  It corresponds
to
a collection of attributes, files, links to other objects, and essentially
anything the implementor wants to put on it, provided it can be stored in the
CVS repository.  For example, we provide a simple sort of object, which is
a source file together with a collection of attributes.  Other objects may
correspond to no file in the repository at all (for example targets), but
still have attributes.  Folders (which correspond to directories) are objects,
consisting essentially of a list of pairs of (name,link) to other objects.

All objects possess an object type.  This contains things like instructions
for displaying the object.  Tools will also be defined as mapping one object
type to another.

There are no fixed types for objects or object types; instead, what is 
specified is the class interface these objects and object types must satisfy,
and some simple implementations.  However there is nothing to stop designers
of particular instances of the Workbench from adding new implementations which
all more complicated things to be done; for example, where objects contain
more than one file.

Thus, when talking about object types, we really have a two-level hierarchy.
Two object types can be different either because they have different Haskell
types, and so different object and object type implementations.  Or else
they may have the same Haskell type and implementation, but the values as
Haskell values may nonetheless differ.

\section{Attributes and Attribute Types}

Many if not all object implementations will equip them with a set of
attributes.  Such a set of attributes corresponds to a map from strings
to values in a large range of different types, including all the obvious
ones such as integers, booleans, characters, strings and so on, but also
arbitrary combinations of them.

These sets of attributes, are themselves considered as typed quantities,
and the types themselves are Haskell values.  These values specify what
strings should correspond to values in the set of attributes, and what types
those values should have.  They also specify the input method for the 
attributes.

Although sets of attributes are a useful way of grouping together values in
an object, they are not the only way.  For example, the contents of a folder
are not an attribute.

\section{Links}
An important sort of value which can be included in an object is
a link.  This is a pointer to any 
object in the repository.  Thus a folder object includes links to the objects 
contained in it, making it possible for two different folders to contain the
same object.

Links are made deliberately lightweight.  For example, they are not reversible.

\section{Versions and Views}
Each object goes through a number of different versions; however these versions
are not intended to be directly accessible to the user.  Instead we regard a
view as containing the complete state of everything at some particular moment.
The user is provided with a directed acyclic graph, in which the nodes are
checked-in views.  Checking out a particular one of these checked-in views
produces a checked-out view (a working version) 
which is local to the user's own machine.  When
a particular state of this checked-out view is committed back into the
repository, the result is a new node in the directed acyclic graph, the parent
of which is the most recent previously checked-in view to which this new
view corresponds.

Views are in some other systems called configurations or editions.

\section{Objects and Object Types}
Every object has a type.  We have subtyping of objects, and the subtype
graph is fairly general.  Our only requirements are that there is
a single unique supertype (called the Object type), and that the graph 
by acyclic.  It will be possible to view the graph of all object types, the 
so called object type graph.

The object type defines various things.  The main thing it defines is, for
any given display type, the display information. This gives the parameters
for objects displayed with this type.  These parameters include, for example,
such things as colour and shape of the object (or its icon) when displayed, 
drag-and-drop actions onto the object, and menus attached to the object. 
The display information also includes information about how to compute the
arcs to and from the object; this information is of course dynamically updated.

The set of object types is not fixed, but is stored in the repository.
Of course the implementations themselves are compiled and so included in the
Uniform library; providing new implementations is possible but requires us
to modify the binaries used.
\par
\section{Examples of objects}
We now describe some implementations of objects and object types.  Other
implementations will be provided as the need arises.
\subsection{Folders}
A particular object implementation is the folder.  
This contains a list of pairs (name,link)
corresponding to objects in the folder.  It also contains a set of attributes.
There is a top folder, which is like the Unix root directory.  The top folder
and all folders recursively contained in it give us a Unix-like filesystem,
giving us a map from file names (consisting of name elements separated by 
\slash\ characters) to objects.
\par
Folder types specify, in addition to the folder, an Attribute Types value
specifying the attributes which must be specified.
\par
\subsection{Source Files}
A source file is another object implementation, and corresponds to a pair of
an ordinary file (to be stored in the repository) and, like a folder type,
a set of attributes.
\subsection{Target Files}
A target file is any object which corresponds to a file which should not be 
stored in the repository.  Thus a target file essentially contains just a
file name and a set of attributes; the user's local version may of course
correspond to an actual file.

\section{Display Graph Types}
Displays of objects are parameterised by a display graph type.  This contains
the various parameters to describe the sort of display to use, for example
the title of the window, actions to be invoked when the user clicks in the
middle of the window, and so on.

The object types themselves decide how they should be displayed for any
given display graph type.

As for the object types, the set of available display graph types is not
fixed but is stored in the repository.

\section{Tools}
This is sadly not yet clear, as I have regarded the functionality described
before this section as quite enough to implement to start with.
\par
Tools are seen by the user in several ways.  The easiest sort of tool
is a {\em single-shot} tool, which is invoked by the user, either directly
(through an interface which lists the available single-shot tools,
and then prompts for the arguments), or (in most cases, one hopes) by being 
called up from one of the actions attached to an object in a particular 
display.  Thus the tool has two interfaces; the one available directly
to the user, and the one available to those constructing actions elsewhere
in UniForM. 
\par
Objects with target object type may not occur
as outputs to such tools, since the application of such tools is
arbitrary.
\par
The situation is more complicated with so-called {\em systematic}
tools.  These should be applied automatically to generate target
files, in a similar way to \texttt{make}.  One possibility would
be a set of \texttt{make}-file rules, each of which specifies, for
some object type, a way of making that object.  I think the nicest way
might be some kind of Prolog-style mini-language for rules, which provides
a way of answering both the question ``How do I make this object'' and
``What can I make from these objects''.  This obviously needs careful
thought.
\par
A third class of tools is that used for workbench operations.
Perhaps the only sort of this class consists of merging operations.
Namely, each source object type needs to specify a tool which trys to
merge two objects of that type. 
\par
In all cases a tool should specify the following things:
\begin{itemize}
\item The object types required for the files involved.  Each file
      is either just input, or just input, or both input and output.
      For example editing a text file would involve just one file,
      which must be a subtype of the set of text files, for both
      input and output.
\item The procedure for invoking the tool.
\end{itemize}
Like object types and display types, the set of available tools will be
described by a class, making it easy to add further implementations as
required, and store tools in the repository.  However it is hoped that
a simple implementation will suffice for many cases, in which we describe
the tool by an \texttt{fprintf}-style format which, given file names 
corresponding to the objects involved, produces a normal Unix command.
\end{document}
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
