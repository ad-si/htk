{- This module describes the types required for the MMiSS file type. -}

module MMiSSFileType where
{-
   module MMiSSFileType(
   
   ) where
   -}

import IO

import System.IO.Unsafe
import Data.FiniteMap

import WBFiles
import ICStringLen
import BinaryAll
import Dynamics
import Computation
import ExtendedPrelude
import AtomString

import GraphConfigure hiding (Menu)
import qualified GraphConfigure

import ViewType
import Link
import DisplayTypes(WrappedDisplayType)
import ObjectTypes
import LinkManager
import CodedValue
import MergeTypes
import MergePrune
import GlobalRegistry
import DisplayView(DisplayedView)

import Text.XML.HaXml.Xml2Haskell

import MMiSSVariantObject
import MMiSSVariant
import MMiSSFiles

-- ----------------------------------------------------------------------
-- Datatypes
-- ----------------------------------------------------------------------

data MMiSSFileType = MMiSSFileType {
   fileType :: FileType, -- ^ The type auto-generated by DtdToHaskell.
   typeId :: GlobalKey
   } deriving (Typeable)

data MMiSSFile = MMiSSFile {
   mmissFileType :: MMiSSFileType,
   title :: String,
   linkedObject :: LinkedObject,
   contents 
      :: VariantObject (Link MMiSSFileVersion) (Link MMiSSFileVersion)
   } deriving (Typeable)

newtype MMiSSFileVersion = MMiSSFileVersion {
   text :: ICStringLen
   } deriving (Typeable)

data MMiSSFilesState = MMiSSFilesState {
   -- ^ the result of reading the Files.xml file.
   fileTypes :: FiniteMap String MMiSSFileType,
   menus :: FiniteMap String Menu
   }

-- ----------------------------------------------------------------------
-- Functions for reading MMiSSFilesState
-- ----------------------------------------------------------------------

mmissFilesState :: MMiSSFilesState
mmissFilesState = unsafePerformIO getMMiSSFilesState
{-# NOINLINE mmissFilesState #-}

getMMiSSFilesState :: IO MMiSSFilesState
getMMiSSFilesState =
   do
      filePath <- getTOPPath ["mmiss","Files.xml"]
      handleEither <- IO.try (openFile filePath ReadMode)
      let
         handle = case handleEither of
            Left excep ->
               error ("Error opening list of MMiSS file types from "
                  ++ filePath ++ ":" ++ show excep
                  )
            Right handle -> handle
      fileTypes <- hGetXml handle
      return (toMMiSSFilesState fileTypes)
       

toMMiSSFilesState :: FileTypes -> MMiSSFilesState
toMMiSSFilesState (FileTypes []) =
   MMiSSFilesState {
      fileTypes = emptyFM,
      menus = emptyFM
      }
toMMiSSFilesState (FileTypes (fileType : fileTypes1)) =
   let
      filesState0 = toMMiSSFilesState (FileTypes fileTypes1)
   in
      case fileType of
         FileTypes_FileType fileType ->
            let
               tag = fileTypeTag fileType

               mmissFileType = MMiSSFileType {
                  fileType = fileType,
                  typeId = constructKey tag
                  }

               fileTypes0 = fileTypes filesState0
               fileTypes1 = addToFM fileTypes0 tag mmissFileType
            in
               filesState0 {
                  fileTypes = fileTypes1
                  }
         FileTypes_Menu (menu @ (Menu attrs _)) ->
            let
               menus0 = menus filesState0
               menus1 = addToFM menus0 (menuId attrs) menu
            in
               filesState0 {
                  menus = menus1
                  }


-- ----------------------------------------------------------------------
-- HasCodedValue instances
-- ----------------------------------------------------------------------

instance Monad m => HasBinary MMiSSFileType m where
   writeBin = mapWrite typeTag
   readBin = mapRead (\ tag ->
      lookupWithDefaultFM (fileTypes mmissFilesState)
         (error ("MMiSSFileType: unknown tag: " ++ tag))
         tag
       )

instance HasBinary MMiSSFile CodingMonad where
   writeBin = mapWriteIO
      (\ (MMiSSFile {
            mmissFileType = mmissFileType,
            title = title,
            linkedObject = linkedObject,
            contents = contents
            }) ->
         do
            contentsFrozen <- freezeVariantObject contents
            return (mmissFileType,title,linkedObject,contentsFrozen)
         )
   readBin = mapReadIO
      (\ (mmissFileType,title,linkedObject,contentsFrozen) ->
         do
            contents <- unfreezeVariantObject (return . id) contentsFrozen
            return (MMiSSFile {
               mmissFileType = mmissFileType,
               title = title,
               linkedObject = linkedObject,
               contents = contents
               })
         )

instance HasBinary MMiSSFileVersion CodingMonad where
   writeBin = mapWrite text
   readBin = mapRead (\ text0 -> MMiSSFileVersion {text = text0})

-- ----------------------------------------------------------------------
-- HasLinkedObject instance
-- ----------------------------------------------------------------------

instance HasLinkedObject MMiSSFile where
   toLinkedObject = linkedObject

-- ----------------------------------------------------------------------
-- HasMerging instances
-- ----------------------------------------------------------------------

instance HasMerging MMiSSFile where
   getMergeLinks =
      let
         fn :: View -> Link MMiSSFile 
            -> IO (ObjectLinks (MMiSSVariants,FileData))
         fn view link =
            do
               object <- readLink view link
               variantObjectObjectLinks
                  (\ link -> 
                     return (ObjectLinks [(WrappedMergeLink link,FileData)])
                     )
                  (contents object)
      in
         MergeLinks fn

   attemptMerge = (\ linkReAssigner newView newLink vlos0 ->
      addFallOutWE (\ break ->
         do
            -- (0) Prune the objects list
            vlos1 <- mergePrune vlos0

            -- (1) Get the type of the first object, and check that the
            -- other objects also have this type.
            let
               ((headView,headLink,headFile):vlosRest) = vlos1

               tag = typeTag . mmissFileType

               thisTag = tag headFile

            mapM_
               (\ (_,_,file) ->
                  if tag file /= thisTag
                     then
                        break ("Type mismatch attempting to merge MMiSS "
                              ++ "file "++ title file)
                     else
                        done
                  )
               vlosRest

            let
               mmissFileType1 = mmissFileType headFile

            -- (2) Merge linked objects
            linkedObject1WE <- attemptLinkedObjectMerge
               linkReAssigner newView newLink
                  (map 
                     (\ (view,link,folder) -> (view,toLinkedObject folder))
                     vlos1
                     )

            linkedObject1 <- coerceWithErrorOrBreakIO break linkedObject1WE

            -- (3) Merge dictionaries
            let
               -- This is the function passed to 
               -- MMiSSVariantObject.attemptMergeVariantObject.
               reAssign :: View -> Link MMiSSFileVersion 
                  -> IO (Link MMiSSFileVersion)
               reAssign oldView link0 =
                  return (mapLink linkReAssigner oldView link0)

            contents1 <- attemptMergeVariantObject
               (return . id)
               reAssign
               (map (\ (view,_,file) -> (view,contents file)) vlos1)

            canClone <- case vlosRest of
               [] ->
                  do
                     linkedsSame <- linkedObjectsSame linkedObject1 
                        (toLinkedObject headFile)
                     if linkedsSame
                        then
                           do
                              variantsSame <- variantObjectsSame
                                 (==)
                                 contents1 (contents headFile)
                              return variantsSame
                         else
                            return False
               _ -> return False 
                            

            if canClone
               then
                  cloneLink headView headLink newView newLink
               else
                  do
                     -- (4) Create the file, and put it in the view.
                     let
                        mmissFile1 = MMiSSFile {
                           mmissFileType = mmissFileType1,
                           title = title headFile,
                              -- these MUST be the same for all files,
                              -- since files with different titles will
                              -- have different names in the folder, and so
                              -- not be merged.
                           linkedObject = linkedObject1,
                           contents = contents1
                           }

                     setLink newView mmissFile1 newLink

                     done
         )
      )

   copyObject = Just (\ view0 mmissFile0 view1 getNewVersionInfo ->
      do
         let
            contents0 = contents mmissFile0
         contents1 <- copyVariantObject getNewVersionInfo contents0
         let
            mmissFile1 = mmissFile0 {contents = contents1}
         return mmissFile1
      )


data FileData = FileData deriving (Eq,Ord,Show,Typeable)

instance HasMerging MMiSSFileVersion where

   getMergeLinks = emptyMergeLinks

   attemptMerge = (\ linkReAssigner newView newLink vlos ->
      do
         vlosPruned <- mergePrune vlos
         case vlosPruned of
            [(oldView,oldLink,_)] ->
               do
                  cloneLink oldView oldLink newView newLink
                  return (hasValue ())
            _ ->
               return (hasError 
                  "Unexpected merge required of MMiSSFileVersion")
      )


-- ----------------------------------------------------------------------
-- ObjectType instance
-- ----------------------------------------------------------------------

instance ObjectType MMiSSFileType MMiSSFile where
   objectTypeTypeIdPrim _ = "MMiSSFileType"

   objectTypeIdPrim = typeId

   objectTypeGlobalRegistry _ = globalRegistry

   extraObjectTypes = return (eltsFM (fileTypes mmissFilesState))

   getObjectTypePrim = mmissFileType

   toLinkedObjectOpt object = Just (linkedObject object)

   nodeTitlePrim = title

   getNodeDisplayData = getFilesNodeDisplayData
 

getFilesNodeDisplayData :: 
   (GraphAllConfig graph graphParms node nodeType nodeTypeParms 
      arc arcType arcTypeParms)
   => View -> WrappedDisplayType -> MMiSSFileType 
   -> IO (DisplayedView graph graphParms node nodeType nodeTypeParms
      arc arcType arcTypeParms)
   -> IO (Maybe (NodeDisplayData graph node nodeTypeParms arcTypeParms 
         MMiSSFileType MMiSSFile))
getFilesNodeDisplayData view displayType fileType 
      (getDisplayedView :: IO (DisplayedView graph graphParms 
         node nodeType nodeTypeParms arc arcType arcTypeParms)) =
   do
      let
         theNodeType = fromString ""

         nodeTypeParms :: nodeTypeParms (Link MMiSSFile)
         nodeTypeParms = error "&&&"

         nodeDisplayData = NodeDisplayData {
            topLinks = [],
            arcTypes = [],
            nodeTypes = [(theNodeType,nodeTypeParms)],
            getNodeType = (\ _ -> theNodeType),
            getNodeLinks = (\ _ -> return emptyArcEnds),
            closeDown = done,
            specialNodeActions = emptySpecialNodeActions
            }

      return (Just nodeDisplayData)
 
      
  

-- ------------------------------------------------------------------
-- The globalRegistry (currently unused).
-- ------------------------------------------------------------------

globalRegistry :: GlobalRegistry MMiSSFileType
globalRegistry = System.IO.Unsafe.unsafePerformIO createGlobalRegistry
{-# NOINLINE globalRegistry #-}

-- ----------------------------------------------------------------------
-- Miscellaneous utilities
-- ----------------------------------------------------------------------

typeTag :: MMiSSFileType -> String
typeTag = fileTypeTag . fileType

---
-- Return the key in the global registry for objects with this tag
constructKey :: String -> GlobalKey
constructKey tag = oneOffKey "MMiSSFiles" tag
