%%%% input replacer: Start von root.tex %%%%
%\documentclass[light-hb,landscape,slides]{mmisslides}
%\documentclass[light-hb,landscape,slides]{mmiss}
\documentclass[light-hb,slides]{mmiss}

% \usepackage{times}
\usepackage{amssymb}
\usepackage{amsmath}
% \usepackage{epsfig}
\usepackage{isolatin1}
\usepackage{german}
\usepackage{supertabular}
\usepackage{diagrams}
\usepackage{verbatim}
%\usepackage{pdf-effects}
% wird durch mmiss.cls geladen - CK

%%%% input replacer: Start von ontology.tex %%%%
\DeclClass{Domain}{Domain}{}


\DeclClass{PROGLAN}{Programmiersprachen}{Domain}
     \DeclClass{DeclarPROGLAN}{Deklarative Programmiersprachen}
               {PROGLAN}
          \DeclClass{FunctPROGLAN}{Funktionale Programmiersprachen}
                    {DeclarPROGLAN}
               \DeclObject{Haskell}{Haskell}{FunctPROGLAN}
     \DeclClass{ImperatPROGLAN}{Imperative Programmiersprachen}
               {PROGLAN}


\DeclClass{FUN}{Funktionen}{Domain}
     \DeclClass{FUNDef}{Funktionsdefinitionen}{FUN}
          \DeclClass{PATTERN}{Muster}{FUNDef}
          \DeclClass{REC}{Rekursion}{FUNDef}
               \DeclClass{PREC}{Primitive Rekursion}{REC} 
               \DeclClass{GREC}{Allgemeine Rekursion}{REC}
          \DeclClass{LISTCOMPREHENSION}{Listenkomprehension}{FUNDef}
     \DeclClass{HOF}{Funktionen H\"{o}herer Ordnung}{FUN}
          \DeclClass{AnonymFUN}{Anonyme Funktionen}{HOF}
          \DeclClass{PartAPPL}{Partielle Applikation}{HOF}


\DeclClass{TYP}{Typen}{Domain}
     \DeclClass{BasDatTYP}{Basisdatentypen}{TYP}
          \DeclObject{BOOL}{Wahrheitswert}{BasDatTYP}
          \DeclClass{NUM}{Numerische Datentypen}{BasDatTYP}
               \DeclObject{NAT}{Nat\"{u}rliche Zahlen}{NUM}
               \DeclObject{INT}{Ganze Zahlen}{NUM}
               \DeclObject{INTEGER}{Ganze Zahlen}{NUM}
               \DeclObject{RAT}{Rationale Zahlen}{NUM}
               \DeclObject{DOUBLE}{Flie{\ss}kommazahlen}{NUM}
          \DeclClass{ALPHANUM}{Alphanumerische Datentypen}{BasDatTYP}
               \DeclObject{CHAR}{Zeichen}{ALPHANUM}
               \DeclObject{STRING}{Zeichenkette}{ALPHANUM}
     \DeclClass{StructDatTYP}{Strukturierte Datentypen}{TYP}
          \DeclClass{RECDat}{Rekursive Datentypen}{StructDatTYP}
               \DeclObject{LIST}{Liste}{RECDat}
          \DeclClass{POLYMORPH}{Polymorphie}{StructDatTYP}
               \DeclObject{LIST}{Liste}{POLYMORPH}
               \DeclObject{TUPEL}{Tupel}{POLYMORPH}
          \DeclClass{NonRECDat}{Nichtrekursive Datentypen}{StructDatTYP}
               \DeclClass{ENUM}{Aufz\"{a}hlungen}{NonRECDat}
               \DeclClass{PROD}{Produkte}{NonRECDat}
                   \DeclObject{TUPEL}{Tupel}{PROD}
               \DeclClass{PLUS}{Summentypen}{NonRECDat}
     \DeclClass{TYPClass}{Typklassen}{TYP}
          \DeclClass{CONSTRClass}{Konstruktorklassen}{TYPClass}
               \DeclObject{IO}{IO}{CONSTRClass}
          \DeclClass{DerivClassINST}{Abgeleitete Klasseninstanzen}
                    {TYPClass}
               \DeclObject{SHOW}{\texttt{Show}}{DerivClassINST}
               \DeclObject{EQ}{\texttt{Eq}}{DerivClassINST}



\DeclClass{FM}{Formale Methoden}{Domain}
     \DeclClass{VERIFICATION}{Verifikation}{FM}
          \DeclClass{PROOF}{Beweisprinzipien}{VERIFICATION}
               \DeclClass{INDUCT}{Induktion}{PROOF}
                    \DeclClass{NatINDUCT}{vollst\"{a}ndige Induktion}{INDUCT}
                    \DeclClass{StructINDUCT}{strukturelle Induktion}{INDUCT}
                    \DeclClass{FixedptINDUCT}{Fixpunktinduktion}{INDUCT}



\DeclClass{AbstrDatTYP}{Abstrakte Datentypen}{Domain}
     \DeclClass{MODULE}{Module}{AbstrDatTYP}
          \DeclObject{HaskellMODULE}{Modul in Haskell}{MODULE}
          \DeclObject{EXPORT}{Export}{MODULE}


\DeclClass{EVAL}{Auswertungen}{Domain}
     \DeclClass{LazyEVAL}{Verz\"{o}gerte Auswertung}{EVAL}
          \DeclClass{InfinitDatSTRUCT}{Unendliche Datenstrukturen}
                    {LazyEVAL}
     \DeclClass{ACTION}{Aktionen}{EVAL}


\Declare{sieve_finite}{Sieb des Erathostenes}
\Declare{def:striktheit}{Funktion \texttt{f} ist \emph{strikt}}
\Declare{ref:fib_stream}{Damit ergibt sich:}
\Declare{expr_grammar_alt}{Grammatik:}
\Declare{ref:draw}{Zeichenfunktion}
\Declare{ref:st_monad}{Ausführlicher}
\Declare{pexpr_alt}{Parsierung von \texttt{Expr}}



%%%% input replacer: Ende von ontology.tex %%%%

\clearpage %%%% input replacer: Start von mmiss-prelude.tex %%%%
%%
%% More MMiSS-related stuff.
%%

%% \MMdarklogo{\MMimgdir/uni-hb-logo-dark}
%% \MMlightlogo{\MMimgdir/uni-hb-logo-light}


%%
%% Experimental MMiSS extensions.
%%
\newcommand{\ShowFile}[2]{\MMlinkApplication{#2}{scripts/show-#1}}
\newcommand{\ShowFileAt}[3][0]{\MMlinkApplication{#3}{scripts/show-#2-#1}}
\newcommand{\RunFile}[2] {\MMlinkApplication{#2}{scripts/run-#1}}
\newcommand{\RunXTerm}[1] {\MMlinkApplication{#1}{scripts/xterm}}

%% Typesetting Literate Haskell

%% This has gone into the big colour scheme of things?
% \ifthenelse{\boolean{light}}
%  {\definecolor{codecol}{rgb}{0.05,0.05,0.3}} %% dark blue (for light)
%  {\definecolor{codecol}{rgb}{0.72,0.72,0.32}} %% orangeish (for dark)
%% The code environment typesets its contents verbatim,
%% but coloured in codecol. Also useful with e.g. literal Haskell
%% scripts, you can actually run your slides -- no more embarrassing
%% type errors :-)
\def\code{\color{codecol}\verbatim}
\def\endcode{\endverbatim{\color{txtcol}}}
%% For longer code, we need to typeset it a wee bit smaller
\def\scode{\color{codecol}\small\verbatim}
\def\endscode{\endverbatim{\color{txtcol}}}
%\def\code{\color{codecol}\renewcommand{\normalcolor}{\color{codecol}}\verbatim}
%\def\endcode{\endverbatim\renewcommand{\normalcolor}{\color{txtcol}}}
%% Same typesetting as code, but different name; this is
%% for code you do not want to show up in literal scripts. 
%% (i.e. the code with syntax errors in it)
\def\xcode{\color{codecol}\verbatim}
\def\endxcode{\endverbatim}
%% Code snippets in the text:
\def\codetxt{\textcolor{codecol}\verb} %% hmm...
\let\MMTextTT=\texttt{}
\renewcommand{\texttt}[1]{\textcolor{codecol}{\MMTextTT{#1}}}
%% Put code you want to run but not show up on your slides in a comment
%% environment, e.g.
%% \begin{comment}
%% \begin{code}
%%  import Prelude hiding (map)
%% \end{code} 
%% \end{comment}
%% This is clumsy, but defining a LaTeX environment here would be of
%% no use, since Haskell scans for \begin{code}/\end{code}

\include{prelude}

%\includeonly{slides-13}

\begin{document}

\begin{Package}[Title={Praktische Informatik 3}, Authors={Christoph
                Lüth}, Date={WS 02/03}, LevelOfDetail=Lecture,
                Language=de, Label={root}]


\scatterslidebody{}

\clearpage %%%% input replacer: Start von slides-1.tex %%%%
%%
%% Praktische Informatik 3 - First lecture
%%

\begin{Section}[Title={Vorlesung vom 21.10.2002: Einführung},
                Label={chapter1}]
% "\\" aus Title entfernt - CK

\begin{Section}[Title={Organisatorisches}, ShortTitle={Organisatorisches}, Label={section1_1_organisatorisches}]

\begin{Paragraph}[Title={Personal}, Label=para1_1_1_personal]
\begin{List}[ListType=itemize]
\ListItem Vorlesung: 
  \begin{tabular}[t]{l}
    Christoph Lüth \texttt{<cxl>} \\
    MZH 8120, Tel. 7585 \\[1ex]
  \end{tabular}
\ListItem Stud. Tutoren:
\begin{tabular}[t]{l}
Felix Beckwermert \texttt{<foetus>}\\
Michael Skibbe \texttt{<mskibbe>}\\
Dennis Walter \texttt{<dw>}\\
Rafael Trautmann \texttt{<pirate>}\\
Thomas Meyer \texttt{<mclee>}\\[2ex]
\end{tabular}

\ListItem Website: \texttt{www.informatik.uni-bremen.de/\~{ }cxl/pi3}.

\ListItem Newsgroup: \texttt{fb3.lv.pi3}.

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Termine}, Label=para1_1_2_termine]
\begin{List}[ListType=itemize]
\ListItem Vorlesung: 

  Mo 10-12, kleiner Hörsaal ("`Keksdose"')

\ListItem Tutorien: 

  \begin{tabular}{llll}
    Di & 10-12 & MZH 1380 & Dennis Walter \\
    Mi & 15-17 & MZH 6240 & Rafael Trautmann \\
    Mi & 15-17 & MZH 7250 & Thomas Meyer \\
    Mi & 17-19 & MZH 6240 & Felix Beckwermert \\
    Mi & 17-19 & MZH 1380 & Michael Skibbe \\
  \end{tabular}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Übungsbetrieb}, Label=para1_1_3_uebungsbetrieb]

\begin{List}[ListType=itemize]
\ListItem Ausgabe der Übungsblätter über die Website \emph{Montag nachmittag}

\ListItem Besprechung der Übungsblätter in den Tutorien;

\ListItem Bearbeitungszeit zwei Wochen ab Tutorium,\par{}
 Abgabe im Tutorium;

\ListItem Voraussichtlich sechs Übungsblätter.
\end{List}

\end{Paragraph}


\begin{Introduction}[Title={Inhalt der Veranstaltung}, Label=para1_1_4_veranst_inhalt]

\begin{List}[ListType=itemize]
\ListItem \emph{Deklarative} und \emph{funktionale} Programmierung 
  \begin{List}[ListType=itemize]
  \ListItem Betonung auf Konzepten und Methodik
  \end{List}
\ListItem Bis Weihnachten: Grundlagen 
  \begin{List}[ListType=itemize]
  \ListItem Funktionen, Typen, Funktionen höherer Ordnung, Polymorphie
  \end{List}
\ListItem Nach Weihnachten: Ausweitung und Anwendung 
  \begin{List}[ListType=itemize]
  \ListItem Prolog und Logik; Nebenläufigkeit/GUIs; Grafik und Animation
  \end{List}
\ListItem Lektüre: \\
    Simon Thompson: \textit{Haskell --- The Craft of Functional
      Programming} (Addison-Wesley, 1999)    
\end{List}

\end{Introduction}


\begin{Paragraph}[Title={Scheinrelevanz}, Label=para1_1_5_scheinrel]

\begin{quote}
\small{}
 "`Der in der DPO'93 aufgeführte prüfungsrelevante PI3-Schein kann nicht
 nur über das SWP sondern alternativ auch über PI3 abgedeckt werden.
 Die in der DPO zusätzlich aufgeführte Forderung der erfolgreichen
 Teilnahme am SWP bleibt davon unberührt."'
\end{quote} \pause{}
Mit anderen Worten:
\begin{List}[ListType=itemize]
\ListItem \emph{Entweder} prüfungsrelevante Studienleistung in PI3 sowie erfolgreiche
  Teilnahme an SWP
\ListItem \emph{oder} Prüfungsrelevante Studienleistung in SWP % (und \emph{kein} PI3)
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Scheinkriterien --- Vorschlag:}, Label=para1_1_6_scheinkrit]

\begin{List}[ListType=itemize]
\ListItem Ein Übungsblatt ist \emph{bearbeitet}, wenn mindestens 20\% der
  Punktzahl erreicht wurden.
\ListItem Alle Übungsblätter bearbeitet und mindestens 60\% der Punktzahl
  erreicht. 
\ListItem Individualität der Leistung wird sichergestellt durch:
  \begin{List}[ListType=itemize]
  \ListItem Vorstellung einer Lösung im Tutorium
  \ListItem Beteiligung im Tutorium
  \ListItem Ggf. Prüfungsgespräch (auch auf Wunsch)
  \end{List}
\end{List}

\end{Paragraph}


\end{Section} % end section 1_1 (Organisatorisches)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Einführung in die Funktionale Programmierung},
    ShortTitle={Einführung in die FP}, Label={section1_2_einfuehrung_fp}]

\begin{Paragraph}[Title={Einführung in FP}, Label=para1_2_1_einfuehrung_fp]

Warum funktionale Programmierung lernen?
\begin{List}[ListType=itemize]
\ListItem Abstraktion \\
  \begin{List}[ListType=itemize]
  \ListItem  Denken in Algorithmen, nicht in Programmiersprachen
  \end{List}

\ListItem FP konzentriert sich auf \emph{wesentlichen} Elemente moderner 
  Programmierung: \\
  \begin{List}[ListType=itemize]
  \ListItem Datenabstraktion
  \ListItem Modularisierung und Dekomposition
  \ListItem Typisierung und Spezifikation
  \end{List}

\ListItem Blick über den Tellerrand --- Blick in die Zukunft \\
  \begin{List}[ListType=itemize]
  \ListItem Studium $\neq$ Programmierkurs--- was kommt in 10 Jahren?
  \end{List}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Referentielle Transparenz}, Label=para1_2_2_ref_transp]

\begin{List}[ListType=itemize]
\ListItem Programme als \FUN 
  \eqn{P:\mathit{Eingabe} \rightarrow \mathit{Ausgabe}}

\ListItem Keine Variablen --- keine Zustände

\ListItem  Alle Abhängigkeiten explizit:

\ListItem Rückgabewert hängt
ausschließlich von Werten der Argumente ab, nicht vom Aufrufkontext:\\
{\flushright \emph{Referentielle Transparenz}} \\
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Geschichtliches}, Label=para1_2_3_geschichte]

\begin{List}[ListType=itemize]
\ListItem Grundlagen 1920/30 \\
  \begin{List}[ListType=itemize]
  \ListItem Kombinatorlogik und $\lambda$-Kalkül (Schönfinkel, Curry, Church)
  \end{List}
\ListItem Erste Sprachen 1960 \\
  \begin{List}[ListType=itemize]
  \ListItem LISP (McCarthy), ISWIM (Landin)
  \end{List}
\ListItem Weitere Sprachen 1970-- 80 \\
  \begin{List}[ListType=itemize]
  \ListItem FP (Backus); ML (Milner, Gordon), später SML und
  CAML; Hope (Burstall); Miranda (Turner)
  \end{List}
\ListItem 1990: \Haskell als \emph{Standardsprache}
\end{List}
%M. D.: LISP etc. als Objekte einführen (wie Haskell)?
\end{Paragraph}


\begin{Paragraph}[Title={\FUN\ als Programme}, Label=para1_2_4_funk_prg]

Programmieren durch Rechnen mit Symbolen:
\begin{eqnarray*}
5*(7-3)+4*3 & = & 5*4+12 \\
 & = & 20+12 \\
 & = & 32 \\
\end{eqnarray*}
Benutzt \emph{Gleichheiten} ($7-3= 4$ etc.), die durch Definition von
$+$, $*$, $-$, \dots gelten.

\end{Paragraph}


\begin{Paragraph}[Title={Programmieren mit \FUN}, Label=para1_2_5_prg_funk]

\begin{List}[ListType=itemize]
\ListItem  \emph{Programme} werden durch Gleichungen definiert:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
Label=prgxfrag_gleichungen]
\begin{xcode}
  inc x = x+ 1
  addDouble x y = 2*(x+ y)
\end{xcode}
\end{ProgramFragment}
\ListItem Auswertung durch \emph{Reduktion} von \emph{Ausdrücken}: \\[1ex]
    \texttt{addDouble 6 4} 
    \pause\Reduces \texttt{2*(6+ 4)}
    \pause\Reduces \texttt{20}

\ListItem Nichtreduzierbare Ausdrücke sind \emph{Werte}

  \begin{List}[ListType=itemize]
  \ListItem \RefClass[Zahlen]{NUM}, \RefObject[Zeichenketten]{STRING},
  \RefClass[Wahrheitswerte]{BOOL}, \ldots
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Auswertungsstrategie}, Label=para1_2_6_auswert_strat]
\begin{List}[ListType=itemize]
\ListItem Von \emph{außen} nach \emph{innen}, \emph{links} nach
  \emph{rechts}. 

  \texttt{inc (addDouble (inc 3) 4)}

  \Reduces\pause
  \texttt{(addDouble (inc 3) 4)+ 1} 

  \Reduces\pause
  \texttt{2*(inc 3+ 4)+ 1} 

  \Reduces\pause
  \texttt{2*(3+ 1+ 4)+ 1} 

  \Reduces\pause
  \texttt{2*8+1} \Reduces 17

\ListItem Entspricht \emph{call-by-need} (\RefClass[verzögerte
  Auswertung]{LazyEVAL})
  \begin{List}[ListType=itemize]
  \ListItem Argumentwerte werden erst ausgewertet, wenn sie benötigt
    werden.
  \end{List}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Nichtnumerische Werte}, Label=para1_2_7_nichtnum_werte]
\begin{List}[ListType=itemize]
\ListItem 
Rechnen mit \RefObject[Zeichenketten]{STRING}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_repeat]
\begin{xcode}
  repeat s = s ++ s 
\end{xcode}
\end{ProgramFragment}

  \verb!repeat (repeat "hallo ")! 

  \Reduces\pause
  \verb!repeat "hallo"++ repeat "hello"! \par

  \Reduces\pause
  \verb!("hallo "++ "hallo ")++("hallo "++ "hallo ")!

  \Reduces\pause
  \verb!"hallo hallo hallo hallo"!  

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Typisierung}, Label=para1_2_8_typisierung]

\emph{\TYP} unterscheiden Arten von Ausdrücken

\begin{List}[ListType=itemize]
\ListItem \BasDatTYP
\ListItem \StructDatTYP\ (\LIST, \RefClass[Tupel]{PROD}, etc)
\end{List}

Wozu \TYP?
\begin{List}[ListType=itemize]
\ListItem Typüberprüfung während Übersetzung erspart Laufzeitfehler
\ListItem Programmsicherheit
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Übersicht: \TYP\ in Haskell},
Label=para1_2_9_typen_in_haskell]

\begin{tabular}[t]{lll}
\INT & \texttt{Int} & {\tt 0} {\tt 94} {\tt -45} \\
Fließkomma & \texttt{Double} & {\tt 3.0} {\tt 3.141592} \\
\CHAR & \texttt{Char} & \verb!'a'! \verb!'x'! \verb!'\034'! \verb!'\n'! \\
\STRING & \texttt{String} & \verb!"yuck"! \verb!"hi\nho\"\n"! \\
\BOOL & \texttt{Bool} & {\tt True} {\tt False} \\[1em]
\LIST & \texttt{[a]} & \verb![6, 9, 20]!\\
 & & \verb!["oh", "dear"]! \\
\RefClass[Tupel]{PROD}  & \texttt{(a, b)} & \verb!(1, 'a')! \verb!('a', 4)! \\
\FUN & \texttt{a-> b} \\
\end{tabular}

\end{Paragraph}


\begin{Paragraph}[Title={Definition von \FUN}, Label=para1_2_10_def_funkt]
\begin{List}[ListType=itemize]
\ListItem Zwei wesentliche Konstrukte: 
\begin{List}[ListType=itemize]
\ListItem Fallunterscheidung
\ListItem Rekursion
\end{List}

\ListItem 
%Beispiel:
\begin{Example}[Title={}, Label=example_fac]
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_def_funkt]
\begin{code}
fac :: Int-> Int
fac n = if n == 0 then 1 
        else n * (fac (n-1))
\end{code}
\end{ProgramFragment}
\end{Example}

\ListItem 
Auswertung kann \emph{divergieren}!
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Haskell in Aktion: \texttt{hugs}}, Label=para1_2_11_hugs]

\begin{List}[ListType=itemize]
\ListItem \texttt{hugs} ist ein Haskell-Interpreter
  \begin{List}[ListType=itemize]
  \ListItem Klein, schnelle Übersetzung, gemächliche Ausführung.
  \end{List}

%\item \texttt{ghc} ist ein Haskell-\emph{Compiler}:
%  \begin{itemize}
%  \item Groß, braucht viel Platz, schnelle Ausführung.
%  \end{itemize}

\ListItem Funktionsweise:
\begin{List}[ListType=itemize]
\ListItem \texttt{hugs} liest \emph{Definitionen} (Programme, Typen,
  \dots) aus Datei (\emph{Skript})
\ListItem Kommandozeilenmodus: Reduktion von Ausdrücken
\ListItem Keine Definitionen in der Kommandozeile
\ListItem \MMstartApplication{Hugs in Aktion.}{scripts/xterm}
\end{List}

\end{List}

\end{Paragraph}

\end{Section} % end Einführung in die FP


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Zusammenfassung der äußeren Section (chapter), nicht der 2nd-level Sections!

\begin{Summary}[Title={Zusammenfassung}, ShortTitle={Zusammenfassung},
  Label=para1_0_1_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Haskell ist eine \emph{funktionale Programmiersprache}.
\ListItem \emph{Programme} sind \emph{\FUN}, definiert durch
Gleichungen.
  \SingleItem{Referentielle Transparenz --- keine Zustände oder Variablen}
\ListItem \emph{Ausführung} durch \emph{Reduktion} von Ausdrücken
\ListItem Typisierung: 
  \begin{List}[ListType=itemize]
    \ListItem \BasDatTYP: \NUM\ (Zahlen),
               \CHAR, \STRING, \BOOL
    \ListItem \StructDatTYP: \LIST, \RefClass[Tupel]{PROD} 
    \ListItem Jede Funktion \texttt{f} hat eine Signatur \verb!f :: a-> b!
  \end{List}
\end{List}

\end{Summary}



\end{Section} % end Vorlesung 1








%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-1.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-2.tex %%%%
%%
%% Praktische Informatik 3 - Second lecture
%%


\begin{Section}[Title={Vorlesung vom 28.10.2001: Funktionen und
      Typen}, ShortTitle={Funktionen und Typen}, Label={chapter2}]

\begin{Introduction}[Title={Inhalt}, ShortTitle={Inhalt},
    Label=para2_0_1_inhalt]
\begin{List}[ListType=itemize]
\ListItem Wie definiere ich eine Funktion?
  \begin{List}[ListType=itemize]
  \ListItem Syntaktische Feinheiten
  \ListItem Von der Spezifikation zum Programm    
  \end{List}
\ListItem Basisdatentypen: \\
  Wahrheitswerte, numerische und alphanumerische Typen
\ListItem Strukturierte Datentypen: \\
  Listen und Tupel
\end{List}

\end{Introduction}


\begin{Section}[Title={Funktionsdefinition},
  ShortTitle={Funktionsdefinition}, Label={section2_1_funk_def}]

\begin{Paragraph}[Title={\DefClass[Funktionsdefinition]{FUNDef}},
Label=para2_1_1_funk_def]

{Wie definiere ich eine Funktion?}

Generelle Form:
\begin{List}[ListType=itemize]
\ListItem \emph{Signatur:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_signatur]
\begin{xcode}
  max :: Int-> Int-> Int
\end{xcode}
\end{ProgramFragment}
\ListItem \emph{Definition}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_definition]
\begin{xcode}
  max x y = if x < y then y else x    
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Kopf, mit Parametern
\ListItem Rumpf (evtl. länger, mehrere Zeilen)
\ListItem Typisches Muster: Fallunterscheidung, dann rekursiver Aufruf
\end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Die Abseitsregel}, Label=para2_1_2_abseitsregel]
\begin{center}
$\mathtt{f} \mathtt{x}_1\;\mathtt{x}_2 \ldots \mathtt{x}_n = \mathtt{E}$  
\end{center}
\begin{List}[ListType=itemize]
\ListItem \emph{Gültigkeitsbereich} der Definition von \texttt{f}:\\
  alles, was gegenüber \texttt{f} eingerückt ist.
\ListItem
%Beispiel:
\begin{Example}[Title={}]
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_gueltbereich]
\begin{xcode}
f x = hier faengts an
  und hier gehts weiter 
      immer weiter
g y z = und hier faengt was neues an
\end{xcode}
\end{ProgramFragment}
\end{Example}
\ListItem Gilt auch verschachtelt.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Bedingte Definitionen}, Label=para2_1_3_bedingte_def]
\begin{List}[ListType=itemize]
\ListItem 
Statt verschachtelter Fallunterscheidungen \dots{}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_versch_fall]
\begin{xcode}
f x y = if B1 then P else 
        if B2 then Q else ...
\end{xcode}
\end{ProgramFragment}
\dots{}\emph{bedingte Gleichungen}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
Label=prgxfrag_bed_gleich]
\begin{xcode}
f x y
  | B1 = ...
  | B2 = ...
\end{xcode}
\end{ProgramFragment}

\ListItem Auswertung der Bedingungen von oben nach unten

\ListItem Wenn keine Bedingung wahr ist: \emph{Laufzeitfehler}! Deshalb: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_laufzeitfehler]
\begin{xcode}
  | otherwise = ...        
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kommentare}, Label=para2_1_4_kommentare]

\begin{List}[ListType=itemize]
\ListItem Pro Zeile: Ab \texttt{--} bis Ende der Zeile
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
Label=prgxfrag_kommentar1]
\begin{xcode}
f x y = irgendwas  -- und hier der Kommentar!
\end{xcode}
\end{ProgramFragment}
\ListItem Über mehrere Zeilen: Anfang \texttt{\{-}, Ende \texttt{-\}}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
Label=prgxfrag_kommentar2]
\begin{xcode}
{- 
   Hier fängt der Kommentar an 
   erstreckt sich über mehrere Zeilen
   bis hier                               -}
f x y = irgendwas
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Kann geschachtelt werden.
\end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Die Alternative: Literate Programming},
    Label=para2_1_5_lit_prog]

\begin{List}[ListType=itemize]
\ListItem Literate Haskell (\texttt{.lhs}):
Quellcode besteht hauptsächlich aus Kommentar, Programmcode
ausgezeichnet. 
\ListItem In Haskell zwei Stile:
  \begin{List}[ListType=itemize]
  \ListItem Alle Programmzeilen mit \texttt{>} kennzeichnen. 
  \ListItem Programmzeilen in \texttt{$\backslash$begin\{code\}} \ldots{}
    \texttt{$\backslash$end\{code\}} einschließen
  \end{List}
  \ListItem Umgebung \texttt{code} in \LaTeX{} definieren:
\begin{ProgramFragment}[Title={}, Formalism=Haskell, Label=prgsfrag_code_latex]
\begin{scode}
\def\code{\verbatim} 
\def\endcode{\endverbatim}
\end{scode}
\end{ProgramFragment}
  \ListItem Mit \LaTeX{} setzen, mit \Haskell ausführen. 
    \ShowFile{slides-2.tex}{(Beispiel)}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Funktionaler Entwurf und Entwicklung},
    Label=para2_1_6_funk_entwurf]

\begin{List}[ListType=itemize]
\ListItem Spezifikation: 
  \begin{List}[ListType=itemize]
  \ListItem Definitionsbereich (Eingabewerte)
  \ListItem Wertebereich (Ausgabewerte)
  \ListItem Vor/Nachbedingungen?
  \end{List}
  $\LeadsTo$ \emph{Signatur}
\pause{}
\ListItem Programmentwurf:
  \begin{List}[ListType=itemize]
  \ListItem Gibt es ein ähnliches (gelöstes) Problem? 
  \ListItem Wie kann das Problem in Teilprobleme zerlegt werden?
  \ListItem Wie können Teillösungen zusammengesetzt werden?
  \end{List}
  $\LeadsTo$ \emph{Erster Entwurf} 

% erzeuge neues slide ohne neuen Paragraph,
% da die beiden inhaltlich zusammengehören - CK
\newpage

\ListItem Implementierung:
  \begin{List}[ListType=itemize]
  \ListItem Termination?
  \ListItem Effizienz? Geht es besser? Mögliche Verallgemeinerungen?
  \ListItem Gibt es hilfreiche Büchereifunktionen?
  \ListItem Wie würde man die Korrektheitheit zeigen?
  \end{List}
  $\LeadsTo$ \emph{Lauffähige Implementierung}
\pause{}
\ListItem Test: 
  \begin{List}[ListType=itemize]
  \ListItem \emph{Black-box Test:} Testdaten aus der Spezifikation 
  \ListItem \emph{White-box Test:} Testdaten aus der Implementierung
  \ListItem Testdaten: hohe \emph{Abdeckung}, \emph{Randfälle} beachten.
  \end{List}
\end{List}
\end{Paragraph}


\begin{comment}

\begin{Paragraph}[Title={Ein Beispiel}, Label=para2_1_6_2_verstecktes_beispiel]
Zu berechnen: der größte gemeinsame Teiler.
\begin{List}[ListType=itemize]
\ListItem Eingabebereich: \texttt{Int}\quad{} Ausgabebereich: \texttt{Int}
\pause{}
\ListItem Analyse des Problems
  \begin{List}[ListType=itemize]
  \ListItem Reduktion auf kleineres Teilproblem?
  \end{List}
\pause{}
\ListItem 
\end{List}  
\end{Paragraph}

\end{comment}


\begin{Paragraph}[Title={Ein Beispiel: das Nim-Spiel}, Label=para2_1_7_nim_spiel]

\begin{List}[ListType=itemize]
\ListItem Zwei Spieler nehmen abwechselnd 1--3 Hölzchen.
\ListItem \emph{Verloren} hat derjenige, der das letzte Hölzchen nimmt.
\ListItem Ziel: Programm, das entscheidet, ob ein Zug gewinnt.
\pause{}
\ListItem Eingabe: Anzahl Hölzchen gesamt, Zug
\ListItem Zug = Anzahl genommener Hölzchen
\ListItem Ausgabe: Gewonnen, ja oder nein.
\begin{ProgramFragment}[Title={}, Formalism=Haskell,
    Label=prgfrag_nim_win_move]
\begin{code}
type Move= Int
winningMove :: Int-> Move-> Bool
\end{code}
\end{ProgramFragment}
\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Erste Verfeinerung}, Label=para2_1_8_verfeinerung]
\begin{List}[ListType=itemize]

\ListItem Gewonnen, wenn Zug legal \&
  Gegner kann nicht gewinnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_verfeinerung]
\begin{code}
winningMove total move = 
  legalMove total move && 
  mustLose (total-move)
\end{code}
\end{ProgramFragment}
\ListItem Überprüfung, ob Zug legal:
\pause{}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_move_legal]
\begin{code}
legalMove :: Int-> Int-> Bool
legalMove total m = 
   (m<= total) && (1<= m) && (m<= 3)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Gegner kann nicht gewinnen, wenn
  \begin{List}[ListType=itemize]
  \ListItem nur noch ein Hölzchen über, oder
  \ListItem kann nur Züge machen, bei denen es Antwort gibt, wo wir
            gewinnen \pause{}
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_must_loose]
\begin{code}
mustLose :: Int-> Bool
mustLose n
  | n == 1    = True
  | otherwise = canWin n 1 && 
                canWin n 2 && 
                canWin n 3
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Wir gewinnen, wenn es legalen, gewinnenden Zug gibt:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_win_move]
\begin{code}              
canWin :: Int-> Int-> Bool
canWin total move = 
  winningMove (total- move) 1 ||
  winningMove (total- move) 2 || 
  winningMove (total- move) 3
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Analyse:
  \begin{List}[ListType=itemize]
  \ListItem Effizienz: unnötige Überprüfung bei \texttt{canWin}
  \ListItem Testfälle: Gewinn, Verlust, Randfälle
  \end{List}

\ListItem Korrektheit: 
  \begin{List}[ListType=itemize]
  \ListItem Vermutung: Mit $4n+1$ Hölzchen verloren, ansonsten gewonnen.
  \ListItem Beweis durch Induktion $\LeadsTo$ später.
  \end{List}
\end{List}  

\end{Paragraph}
\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Der Basisdatentyp \RefObject[Bool]{BOOL}},
  ShortTitle={Basisdatentyp \texttt{Bool}}, Label={section2_2}]

\begin{Paragraph}[Title={Wahrheitswerte: \DefObject[Bool]{BOOL}}, Label={para2_2_1}]

\begin{List}[ListType=itemize]
\ListItem Werte \texttt{True} und \texttt{False}
\ListItem Funktionen:
  \begin{tabular}[t]{ll}
    \verb!not :: Bool-> Bool        ! & Negation \\
    \verb!&&  :: Bool-> Bool-> Bool ! & Konjunktion \\
    \verb!||  :: Bool-> Bool-> Bool ! & Disjunktion \\
  \end{tabular}
\ListItem Beispiel: ausschließende Disjunktion: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_bool]
\begin{xcode}
exOr :: Bool-> Bool-> Bool
exOr x y = (x || y) && (not (x && y))
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem Alternative: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_bool_alt]
\begin{xcode}
exOr x y 
  | x == True  = if y == False then True 
                               else False
  | x == False = if y == True  then True 
                               else False
\end{xcode}
\end{ProgramFragment}
\pause{}
\ListItem \emph{Igitt!} Besser: Definition mit \emph{pattern matching}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_bool_pat_match]
\begin{xcode}
exOr True  y = not y
exOr False y = y
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}
\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Numerische Basisdatentypen}, ShortTitle={Numerische Basisdatentypen}, Label={section2_3}]

\begin{Paragraph}[Title={Das Rechnen mit Zahlen},
    Label=para2_3_1_rechnen_zahlen]
% \SingleItem{Grundsätzliches Problem: es gibt so viele \dots{}} 
\[\begin{array}[c]{c}
\text{Beschränkte Genauigkeit,} \\
\text{konstanter Aufwand}
\end{array}
\longleftrightarrow 
\begin{array}[c]{c}
\text{beliebige Genauigkeit}, \\
\text{wachsender Aufwand}
\end{array}
\]
\pause{}
Haskell bietet die Auswahl:
  \begin{List}[ListType=itemize]
  \ListItem \RefObject[Int]{INT} - ganze Zahlen als Maschinenworte
($\geq$ 31 Bit)
  \ListItem \RefObject[Integer]{INTEGER} - beliebig große ganze Zahlen
  \ListItem \RefObject[Rational]{RAT} - beliebig genaue rationale Zahlen
  \ListItem \RefObject[Double]{DOUBLE} - Fließkommazahlen (reelle Zahlen) 
  \end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Ganze Zahlen: \DefObject[Int]{INT} und
  \DefObject[Integer]{INTEGER}}, Label=para2_3_2_ganze_zahlen]

\begin{List}[ListType=itemize]
\ListItem Nützliche Funktionen (\emph{überladen}, auch für \texttt{Integer}):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_integer_funkt]
\begin{xcode}
+, *, ^, - :: Int-> Int-> Int
abs   :: Int-> Int -- Betrag
div   :: Int-> Int-> Int 
mod   :: Int-> Int-> Int 
\end{xcode}
\end{ProgramFragment}
%Es gilt \texttt{x `div` y)*y + x `mod` y == x}
% `(' vor x eingefügt - CK
Es gilt \texttt{(x `div` y)*y + x `mod` y == x}
\ListItem Vergleich durch \texttt{==}, \texttt{/=}, \texttt{<=}, \texttt{<},
  \ldots{}
\ListItem \emph{Achtung:} Unäres Minus
  \begin{List}[ListType=itemize]
  \ListItem Unterschied zum Infix-Operator \texttt{-}
  \ListItem Im Zweifelsfall klammern: \texttt{abs (-34)}
  \end{List}
%\item Fallweise Definitionen möglich:
%\begin{xcode}
%fac 0 = 1
%fac n = n* (fac (n-1))
%\end{xcode}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Fließkommazahlen: \DefObject[Double]{DOUBLE}},
  Label=para2_3_3_fliesskommazahlen]

\begin{List}[ListType=itemize]
\ListItem Doppeltgenaue Fließkommazahlen (IEEE 754 und 854)
  \begin{List}[ListType=itemize]
  \ListItem Logarithmen, Wurzel, Exponentation, $\pi$ und $e$, trigonometrische Funktionen
  \ListItem siehe Thompson S. 44
  \end{List}
\ListItem Konversion in ganze Zahlen: 
  \begin{List}[ListType=itemize]
  \ListItem \texttt{fromInt :: Int-> Double}
  \ListItem \texttt{fromInteger :: Integer-> Double}
  \ListItem \texttt{round, truncate :: Double-> Int}, \texttt{Integer}
  \ListItem Überladungen mit Typannotation auflösen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_round]
\begin{xcode}
   round (fromInt 10) :: Int 
\end{xcode}
\end{ProgramFragment}
  \end{List}
\ListItem \emph{Rundungsfehler!}
\end{List}

\end{Paragraph}
\end{Section}


%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Strukturierte Datentypen: Tupel und Listen},
    Label={section2_4}]

\begin{Paragraph}[Title={Tupel und Listen}, Label=para2_4_1_tupel_listen] 

\begin{List}[ListType=itemize]
\ListItem \emph{\DefClass[Tupel]{PROD}} sind das kartesische Produkt: \par
\texttt{(t1, t2)} = alle möglichen Kombinationen von Werten aus
\texttt{t1} und \texttt{t2}. 

\ListItem 
\emph{\DefClass[Listen]{LIST}} sind Sequenzen: \par
\texttt{[t]} = endliche Folgen von Werten aus \texttt{t} 

%\begin{itemize}
%\item Sequenz ist wie eine Menge, aber mit einer Ordnung, mit
%  doppelten Elemente, und endlich.
%%% Eine Sequenz ist wie ein Auto, aber ohne Räder, ohne Motor, und
%%%  man auch nicht damit fahren ?!?
%\end{itemize} 

\ListItem 
\emph{\DefClass[Strukturierte Typen]{StrucDatTYP}}: konstruieren aus
bestehenden Typen neue Typen. 

\newpage

\ListItem Beispiel: Modellierung eines Einkaufswagens 
  \begin{List}[ListType=itemize]
  \ListItem Inhalt: Menge von Dingen mit Namen und Preis
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_bsp_tupel]
\begin{xcode}
type Item   = (String, Int)
type Basket = [Item]
\end{xcode}
\end{ProgramFragment}

\pause{}

\ListItem Beispiel: Punkte, Rechtecke, Polygone
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_bsp_geo_obj]
\begin{xcode}
type Point   = (Int, Int)
type Line    = (Point, Point)
type Polygon = [Point] 
\end{xcode}
\end{ProgramFragment}

\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Funktionen über Listen und Tupeln}, Label=para2_4_2_funk_tupel_listen]

\begin{List}[ListType=itemize]

\ListItem 
Funktionsdefinition durch \emph{pattern matching}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_kompweise_add]
\begin{xcode}
add :: Point-> Point-> Point
add (a, b) (c, d) = (a+ c, b+ d)
\end{xcode}
\end{ProgramFragment}
\ListItem Für Listen:
\begin{List}[ListType=itemize]
\ListItem entweder leer
\ListItem oder bestehend aus einem \emph{Kopf} und einem \emph{Rest}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_concat_list]
\begin{xcode}
sumList :: [Int]-> Int
sumList []     = 0
sumList (x:xs) = x + sumList xs
\end{xcode}
\end{ProgramFragment}
\ListItem Hier hat \texttt{x} den Typ \texttt{Int}, \texttt{xs} den Typ
  \texttt{[Int]}. 
\end{List}

\newpage

\ListItem Gesamtpreis des Einkaufs:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_einkauf]
\begin{xcode}
total :: Basket -> Int
total [] = 0
total ((name, price):rest) = price + total rest
\end{xcode}
\end{ProgramFragment}
\pause{}

\ListItem Translation eines Polygons:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_poly_transl]
\begin{xcode}
move :: Polygon-> Point-> Polygon
move [] p                 = []
move ((x, y):ps) (px, py) = (x+ px, y+ py):
                              (move ps (px, py))
\end{xcode}
\end{ProgramFragment}

\end{List}

\end{Paragraph}
\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass[Alphanumerische Basisdatentypen]{ALPHANUM}},
    ShortTitle={Alphanumerische Basisdatentypen}, Label={section2_5}]

\begin{Paragraph}[Title={Einzelne Zeichen: \DefClass[Char]{CHAR}},
    Label=para2_5_1_einz_zeichen]

\begin{List}[ListType=itemize]
\ListItem Notation für einzelne Zeichen: \verb!'a'!,\ldots{}
  \begin{List}[ListType=itemize]
  \ListItem NB. Kein Unicode.
  \end{List}
\ListItem Nützliche Funktionen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_nuetzl_funk]
\begin{xcode}
ord :: Char -> Int
chr :: Int -> Char

toLower :: Char-> Char
toUpper :: Char-> Char
isDigit :: Char-> Bool
isAlpha :: Char-> Bool
\end{xcode}
\end{ProgramFragment}
\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Zeichenketten: \texttt{String}},
    Label=para2_5_2_zeich_ketten]

\begin{List}[ListType=itemize]
\ListItem \DefClass[String]{STRING} sind Sequenzen von Zeichenketten:
\begin{ProgramFragment}[Title={}, Formalism=Haskell, Label=prgxfrag_string_type]
\begin{xcode}
type String = [Char] 
\end{xcode}
\end{ProgramFragment}

\ListItem Alle vordefinierten Funktionen auf Listen verfügbar.

\ListItem Syntaktischer Zucker zur Eingabe:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_string_zucker]
\begin{xcode}
['y','o','h','o'] == "yoho" 
\end{xcode}
\end{ProgramFragment}

\ListItem Beispiel:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_bsp_count]
\begin{xcode}
count :: Char-> String-> Int
count c []     = 0
count c (x:xs) = if (c== x) then 1+ count c xs
                 else count c xs
\end{xcode}
\end{ProgramFragment}
\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: Palindrome}, Label=para2_5_3_palindrome]

\begin{List}[ListType=itemize]
\ListItem \emph{Palindrom}: vorwärts und rückwärts
  gelesen gleich (z.B. Otto, Reliefpfeiler)
\pause{}

\ListItem Signatur: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_palindrom_signatur]
\begin{xcode}
palindrom :: String-> Bool
\end{xcode}
\end{ProgramFragment}
\pause{}

\ListItem Entwurf: 
  \begin{List}[ListType=itemize]
  \ListItem Rekursive Formulierung: \\
    erster Buchstabe = letzer Buchstabe, und Rest auch Palindrom
  \ListItem Leeres Wort und monoliterales Wort sind Palindrome
  \ListItem Hilfsfunktionen: \\
    \verb!last: String-> Char!, \verb!init: String-> String!
  \end{List}

\newpage

\ListItem Implementierung:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_palindrom_string_bool]
\begin{code}
palindrom :: String-> Bool
palindrom []     = True
palindrom [x]    = True
palindrom (x:xs) = (x == last xs) 
                   && palindrom (init xs)
\end{code}
\end{ProgramFragment}
\pause{}
\ListItem Kritik: 
  \begin{List}[ListType=itemize]
  \ListItem Unterschied zwischen Groß- und kleinschreibung
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_gross_klein]
\begin{xcode}
palindrom (x:xs) = (toLower x == toLower (last xs)) 
                   && palindrom (init xs)
\end{xcode}
\end{ProgramFragment}
  \ListItem Nichtbuchstaben sollten nicht berücksichtigt werden.
  \end{List}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Exkurs: Operatoren in \Haskell},
    Label=para2_5_4_operatoren]
\begin{List}[ListType=itemize]
\ListItem \emph{Operatoren}: Namen aus Sonderzeichen \verb"!$%&/?+^" \ldots
% $ ignore this - emacs fontify problem - CK
\ListItem Werden \emph{infix} geschrieben: \verb!x && y!
\ListItem Ansonsten normale Funktion.
\ListItem Andere Funktion infix benutzen: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_infix]
\begin{xcode}
x `exOr` y 
\end{xcode}
\end{ProgramFragment}
\SingleItem{In Apostrophen einschließen.}
\ListItem Operatoren in Nicht-Infixschreibweise (präfix): 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
Label=prgxfrag_nicht_infix]
\begin{xcode}
(&&) :: Bool-> Bool-> Bool
\end{xcode}
\end{ProgramFragment}
\SingleItem{In Klammern einschließen.}
\end{List}

\end{Paragraph}

\end{Section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Zusammenfassung ist die Zus.fas. der _äußeren_ Section (chapter 2)

\begin{Summary}[Title={Zusammenfassung}, ShortTitle={Zusammenfassung},
    Label=para2_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Funktionsdefinitionen:
  \begin{List}[ListType=itemize]
  \ListItem Abseitsregel, bedingte Definition, \textit{pattern matching}
  \end{List}
\ListItem Numerische Basisdatentypen:
  \begin{List}[ListType=itemize]
  \ListItem \texttt{Int}, \texttt{Integer}, \texttt{Rational} und \texttt{Double}
  \end{List}
\ListItem Funktionaler Entwurf und Entwicklung
  \begin{List}[ListType=itemize]
  \ListItem Spezifikation der Ein- und Ausgabe $\LeadsTo$ Signatur
  \ListItem Problem rekursiv formulieren $\LeadsTo$ Implementation
  \ListItem Test und Korrektheit
  \end{List}
\ListItem Strukturierte Datentypen: Tupel und Listen
\ListItem Alphanumerische Basisdatentypen: \texttt{Char} und
  \texttt{String}
  \begin{List}[ListType=itemize]
  \ListItem \texttt{type String = [Char]}
  \end{List}
\end{List}

\end{Summary}

\end{Section} % end Vorlesung 2


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-2.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-3.tex %%%%
%%
%% Praktische Informatik 3 - Third lecture
%%

\begin{Section}[Title={Vorlesung vom 04.11.2002: Listenkomprehension,
      Polymorphie und Rekursion}, ShortTitle={Definition von
      Funktionen}, Label={chapter3}]

%% code header
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
      Label=prgfrag_versteckt_slides3]
\begin{code}
module Slides3 where
import Prelude hiding (length, concat, zip, take)
import List (partition)
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Introduction}[Title={Inhalt}, Label=para3_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Letzte Vorlesung
  \begin{List}[ListType=itemize]
    \ListItem Basisdatentypen, strukturierte Typen Tupel und Listen
    \ListItem Definition von Funktionen durch rekursive Gleichungen
  \end{List}
\ListItem Diese Vorlesung: Funktionsdefinition durch
  \begin{List}[ListType=itemize]
  \ListItem Listenkomprehension
  \ListItem primitive Rekursion
  \ListItem nicht-primitive Rekursion
  \end{List}
\ListItem Neue Sprachkonzepte:
  \begin{List}[ListType=itemize]
  \ListItem Polymorphie --- Erweiterung des Typkonzeptes
  \ListItem Lokale Definitionen
  \end{List}
\ListItem Vordefinierte Funktionen auf Listen
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{LISTCOMPREHENSION}},
  Label={section3_1_listenkomp}] 


\begin{Paragraph}[Title={}, Label=para3_1_1_listenkomp]

\begin{List}[ListType=itemize]
\ListItem Ein Schema für Funktionen auf Listen:
  \begin{List}[ListType=itemize]
  \ListItem Eingabe \emph{generiert} Elemente,
  \ListItem die \emph{getestet} und 
  \ListItem zu einem Ergebns \emph{transformiert} werden \pause{}
  \end{List}
\ListItem Beispiel Palindrom: 
  \begin{List}[ListType=itemize]
  \ListItem alle Buchstaben im String \texttt{str} zu Kleinbuchstaben.    
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_lowercase]
\begin{xcode}
  [ toLower c | c <- str ]
\end{xcode}
\end{ProgramFragment}
\ListItem Alle Buchstaben aus \texttt{str} herausfiltern: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_filterchars]
\begin{xcode}
  [ c | c <- str, isAlpha c ]      
\end{xcode} 
\end{ProgramFragment}
\ListItem Beides zusammen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_lower_and_filter]
\begin{xcode}
  [ toLower c | c<- str, isAlpha c]      
\end{xcode}
\end{ProgramFragment}
\end{List}

\newpage

\ListItem Generelle Form:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_gen_form]
\begin{xcode}
  [E |c<- L, test1, ... , testn]    
\end{xcode}
\end{ProgramFragment}
\ListItem Mit pattern matching:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_pat_match]
\begin{xcode}
  addPair :: [(Int, Int)]-> [Int]
  addPair ls = [ x+ y | (x, y) <- ls ]
\end{xcode}
\end{ProgramFragment}

\ListItem Auch mehrere Generatoren möglich:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_mult_generat]
\begin{xcode}
  [E |c1<- L1, c2<- L2, ..., test1, ..., testn ]    
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem Beispiel Quicksort: 
  \begin{List}[ListType=itemize]
  \ListItem Zerlege Liste in  
    Elemente kleiner gleich und größer dem ersten,
  \ListItem sortiere Teilstücke, 
  \ListItem konkateniere Ergebnisse. \pause{}
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_qsort]
\begin{code}
qsort :: [Int]-> [Int]
qsort [] = []
qsort (x:xs) = qsort [ y | y <- xs, y<= x ] 
               ++ [x] ++
               qsort [ y | y <- xs, y > x ]
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: Eine Bücherei}, Label=para3_1_2_buecherei]
\begin{List}[ListType=itemize]
\ListItem Problem: Modellierung einer Bücherei

\ListItem Datentypen: 
  \begin{List}[ListType=itemize]
  \ListItem Ausleihende Personen
  \ListItem Bücher
  \ListItem Zustand der Bücherei: ausgeliehene Bücher, Ausleiher
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_buecherei]
\begin{code}
type Person   = String
type Book     = String
type DBase = [(Person, Book)] 
\end{code}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem Buch ausleihen und zurückgeben:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_leih_zurueck]
\begin{code}
makeLoan :: DBase -> Person -> Book -> DBase
makeLoan dBase pers bk = [(pers,bk)] ++ dBase
\end{code}
\end{ProgramFragment}
\SingleItem{Benutzt \texttt{(++)} zur Verkettung von \texttt{DBase}}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zureuck]
\begin{code}
returnLoan :: DBase -> Person -> Book -> DBase
returnLoan dBase pers bk
        = [ pair | pair <- dBase , 
                   pair /= (pers,bk) ]
\end{code}
\end{ProgramFragment}
\ListItem Suchfunktionen: Wer hat welche Bücher ausgeliehen
    \RunFile{slides-3.tex}{usw.}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_wer_leiht]
\begin{code}
books :: DBase -> Person -> [Book]
books db who = [ book | (pers,book)<- db,  
                        pers== who ]
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


%% \section[Polymorphie]{Polymorphie --- jetzt oder nie.}
\begin{Paragraph}[Title={Polymorphie --- jetzt
oder nie.},
    Label=para3_1_3_polymorphie]
\begin{List}[ListType=itemize]
\ListItem Definition von \texttt{(++)}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_poly_def_plusplus]
\begin{xcode}
(++) :: [DBase]->  [DBase]-> [DBase]
[] ++ ys     = ys
(x:xs) ++ ys = x:(xs++ ys) 
\end{xcode}
\end{ProgramFragment}
\ListItem Verketten von Strings: \pause{}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_string_concat]
\begin{xcode}
(++) :: String-> String-> String
[] ++ ys     = ys
(x:xs) ++ ys = x:(xs++ ys) 
\end{xcode} 
\end{ProgramFragment}
\ListItem \emph{Gleiche Definition}, aber \emph{unterschiedlicher Typ}!

$\Longrightarrow$ Zwei Instanzen einer allgemeineren Definition.

\newpage

\ListItem Polymorphie erlaubt \emph{Parametrisierung über \TYP}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_poly_param]
\begin{xcode}
  (++) :: [a]-> [a]-> [a]
  [] ++ ys     = ys
  (x:xs) ++ ys = x:(xs++ ys) 
\end{xcode}
\end{ProgramFragment}
\texttt{a} ist hier eine \emph{Typvariable}. 

\ListItem Definition wird bei Anwendung instantiiert:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_def_instant]
\begin{xcode}
  [3,5,57] ++ [39, 18]     "hi" ++ "ho"
\end{xcode}
\end{ProgramFragment}
aber \emph{nicht} 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_falsche_typen]
\begin{xcode}
  [True, False] ++ [18, 45]  
\end{xcode}
\end{ProgramFragment}

\ListItem Typvariable: vergleichbar mit Funktionsparameter

\newpage

\ListItem 
Weitere Beispiele:
\begin{List}[ListType=itemize]
  \ListItem Länge einer Liste:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_laenge]
\begin{code}
length :: [a] -> Int
length []     = 0
length (x:xs) = 1+ length xs    
\end{code}
\end{ProgramFragment}
%%  Inhalt der Liste irrelevant.
\ListItem Verschachtelte Listen ``flachklopfen'':
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_verschach_liste]
\begin{code}
concat :: [[a]]-> [a]
concat []     = []
concat (x:xs) = x ++ (concat xs)       
\end{code}
\end{ProgramFragment}
\ListItem Kopf und Rest einer nicht-leeren Liste:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_kopf_rest_list]
\begin{xcode}
head :: [a]-> a               tail :: [a]-> [a] 
head (x:xs) = x               tail (x:xs) = xs
\end{xcode}
\end{ProgramFragment}
\emph{Undefiniert} für leere Liste.
\end{List}  
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Übersicht: vordefinierte Funktionen auf
      Listen}, Label=para3_1_4_funk_auf_listen]

%% \tablecaptions{Vordefinierte Funktionen auf Listen (Auszug)}

{\small
\begin{supertabular}[t]{llp{12cm}}
\texttt{:} & \texttt{a-> [a]-> [a]      } & Element vorne anfügen \\
\texttt{++} & \texttt{[a]-> [a]-> [a]} & Verketten \\
\texttt{!!} & \texttt{[a]-> Int-> a} & \texttt{n}-tes Element selektieren \\
\texttt{concat} & \texttt{[[a]]-> [a]} & ``flachklopfen'' \\
\texttt{length} & \texttt{[a]-> Int} & Länge \\
\texttt{head}, \texttt{last} & \texttt{[a]-> a} & Erster/letztes Element \\
\texttt{tail}, \texttt{init} & \texttt{[a]-> [a]} & Rest (hinterer/vorderer) \\
\texttt{replicate} & \texttt{Int-> a-> [a]} & Erzeuge \texttt{n} Kopien \\
\texttt{take} & \texttt{Int-> [a]-> [a]} & Nimmt ersten \texttt{n} Elemente \\
\texttt{drop} & \texttt{Int-> [a]-> [a]} & Entfernt erste \texttt{n}
Elemente \\
\texttt{splitAt} & \texttt{Int-> [a]-> ([a], [a])} & Spaltet an \texttt{n}-ter
Position \\
\texttt{reverse} & \texttt{[a]-> [a]} & Dreht Liste um \\
\texttt{zip} & \texttt{[a]-> [b]-> [(a, b)]} & Macht aus Paar von Listen Liste
von Paaren \\
\texttt{unzip} & \texttt{[(a, b)]-> ([a], [b])} & Macht aus Liste
von Paaren Paar von Listen \\
\texttt{and}, \texttt{or} & \texttt{[Bool]-> Bool} & Konjunktion/Disjunktion \\
\texttt{sum} & \texttt{[Int]-> Int} (überladen) & Summe \\ 
\texttt{product} & \texttt{[Int]-> Int} (überladen) & Produkt \\ 
\end{supertabular}
}
\\[1ex]
Siehe Thompson S. 91/92. \\[1ex]
Palindrom zum letzten: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp_palin]
\begin{code}
palindrom xs = (reverse l) == l where
               l = [toLower c| c<- xs, isAlpha c]
\end{code}
\end{ProgramFragment}

\end{Paragraph}


\begin{Paragraph}[Title={Lokale Definitionen}, Label=para3_1_5_lokale_def]

\begin{List}[ListType=itemize]
\ListItem Lokale Definitionen mit \texttt{where} --- Syntax:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_lok_def_syntax]
\begin{xcode}
f x y
 | g1 = P
 | g2 = Q where
    v1 = M
    v2 x = N x   
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{v1}, \texttt{v2}, \dots{} werden \emph{gleichzeitig}
  definiert (Rekursion!);
\ListItem Namen \texttt{v1} und Parameter (\texttt{x}) \emph{überlagern}
  andere;
\ListItem Es gilt die \emph{Abseitsregel} (deshalb auf gleiche Einrückung
  der lokalen Definition achten);
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\PATTERN \textit{(pattern)}}, ShortTitle={Muster
  \textit{(pattern)}}, Label={section3_2_muster}]

\begin{Paragraph}[Title={\PATTERN \textit{(pattern)}}, Label=para3_2_1_muster]

\begin{List}[ListType=itemize]
\ListItem Funktionsparameter sind \emph{\PATTERN}: \quad{}
\texttt{head (x:xs) = x}
\ListItem \DefClass{PATTERN} sind:
  \begin{List}[ListType=itemize]
  \ListItem \emph{Wert} (\texttt{0} oder \texttt{True})
  \ListItem \emph{Variable} (\texttt{x}) - dann paßt alles
    \SingleItem{Jede Variable darf links nur einmal auftreten.}

  \ListItem \emph{namenloses Muster} (\texttt{\_}) - dann paßt alles.
    
    \SingleItem{\texttt{\_} darf links mehrfach, rechts \emph{gar
        nicht} auftreten.}
    
  \ListItem \emph{Tupel} \texttt{(p1, p2, ... pn)} (\texttt{pi} sind wieder
    Muster)

  \ListItem  \emph{leere \LIST}  \texttt{[]}
    
  \ListItem \emph{nicht-leere \LIST} \texttt{ph:pl} (\texttt{ph, pl} sind
    wieder Muster)
    
  \ListItem \texttt{[p1,p2,...pn]} ist syntaktischer Zucker für \texttt{p1:p2:...pn:[]}
  \end{List}
\end{List}  

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Primitive und allgemeine Rekursion},
    ShortTitle={Primitive und allgemeine Rekursion},
    Label={section3_3_prim_allg_rekursion}]

\begin{Paragraph}[Title={Primitive Rekursion auf Listen},
    Label=para3_3_1_rek_listen]

\begin{List}[ListType=itemize]
\ListItem \emph{Primitive} Rekursion vs. \emph{allgemeine} Rekursion

\ListItem \DefClass{PREC}: gegeben durch 
  \begin{List}[ListType=itemize]
  \ListItem eine Gleichung für die leere \LIST
  \ListItem eine Gleichung für die nicht-leere \LIST 
  \end{List}

\ListItem Beispiel: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_prim_rek]
\begin{xcode}
sum :: [Int]-> Int
sum []     = 0
sum (x:xs) = x+ sum xs 
\end{xcode}
\end{ProgramFragment}

\ListItem Weitere Beispiele:
  \texttt{length}, \texttt{concat}, \texttt{(++)}, \ldots{}

\newpage

\ListItem
 Auswertung:
 \begin{center}
   \begin{tabular}[l]{lcl}
     \texttt{sum [4,7,3]}      & \Reduces & \texttt{4 + 7 + 3 + 0} \\
     \texttt{concat [A, B, C]} & \Reduces & \texttt{A ++ B ++ C++ []}
   \end{tabular}   
 \end{center}

\ListItem Allgemeines Muster:
\eqn{
  \mathtt{f [x1,..., xn]} =
  \mathtt{x1} \otimes \mathtt{x2} \otimes \ldots \otimes \mathtt{xn}
  \otimes \mathtt{A}
}
\begin{List}[ListType=itemize]
\ListItem Startwert (für die leere Liste) \texttt{A :: b}
\ListItem Rekursionsfunktion \texttt{$\otimes$ :: a -> b-> b}
\end{List}

\ListItem Entspricht einfacher Iteration (\texttt{while}-Schleife).

\ListItem Vergleiche \texttt{Iterator} und \texttt{Enumeration} in
  \textsc{Java}.

\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Nicht-primitive Rekursion},
  Label=para3_3_2_nichtprim_rek]

\begin{List}[ListType=itemize]

\ListItem \DefClass{GREC}:
  \begin{List}[ListType=itemize]
  \ListItem Rekursion über mehrere Argumente
  \ListItem Rekursion über andere Datenstruktur
  \ListItem Andere Zerlegung als Kopf und Rest
  \end{List}

\ListItem Rekursion über mehrere Argumente:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mult_arg_rek]
\begin{code}
zip :: [a]-> [b]-> [(a, b)]
zip [] _ = []
zip _ [] = []
zip (x:xs) (y:ys) = (x,y):(zip xs ys)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Rekursion über ganzen Zahlen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_int_rek]
\begin{code}
take :: Int-> [a]-> [a]
take 0 _  = []
take _ [] = []
take n (x:xs) 
  | n > 0     = x: take (n-1) xs
  | otherwise = error "take: negative Argument"
\end{code}
\end{ProgramFragment}
\ListItem Quicksort: 
  \begin{List}[ListType=itemize]
  \ListItem zerlege Liste in   
    Elemente kleiner gleich und größer dem ersten,
  \ListItem sortiere Teilstücke, konkateniere Ergebnisse
  \end{List}
% \begin{code}
% qsort' :: [Int]-> [Int]
% qsort' [] = []
% qsort' (x:xs) = (qsort' lower) ++ [x]++ (qsort' higher)
%                 where (lower, higher)= partition (x <=) xs
% \end{code}

\newpage

\ListItem Mergesort: 
  \begin{List}[ListType=itemize]
  \ListItem teile Liste in der Hälfte, 
  \ListItem sortiere Teilstücke, füge ordnungserhaltend zusammen.
  \end{List}
{\small
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_sort_teile]
\begin{code}
msort :: [Int]-> [Int]
msort xs 
  | length xs <= 1 = xs
  | otherwise = merge (msort front) (msort back) where
    (front, back) = splitAt ((length xs) `div` 2) xs
    merge :: [Int]-> [Int]-> [Int]
    merge [] x = x
    merge y [] = y
    merge (x:xs) (y:ys) 
      | x<= y     = x:(merge xs (y:ys))
      | otherwise = y:(merge (x:xs) ys)
\end{code}
\end{ProgramFragment}
}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: das $n$-Königinnen-Problem},
    Label=para3_3_3_koeniginnen_problem]

\begin{List}[ListType=itemize]
\ListItem Problem: $n$ Königinnen auf $n \times n$-Schachbrett % sicher plazieren
\ListItem Spezifikation:
  \begin{List}[ListType=itemize]
  \ListItem Position der Königinnen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_pos_koenig]
\begin{code}
type Pos = (Int, Int)
\end{code}
\end{ProgramFragment}
  \ListItem Eingabe: Anzahl Königinnen, Rückgabe: Positionen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_eingabe_koenig]
\begin{code}
queens :: Int-> [[Pos]]
\end{code}
\end{ProgramFragment}
  \end{List}
\ListItem Rekursive Formulierung:
  \begin{List}[ListType=itemize]
  \ListItem Keine Königin--- kein Problem.
  \ListItem Lösung für $n$ Königinnen: Lösung für $n-1$ Königinnen, und
    $n$-te Königin so stellen, dass keine andere sie bedroht.
  \ListItem $n$-te Königin muß in $n$-ter Spalte plaziert werden. 
  \end{List}

\newpage

\ListItem Hauptfunktion:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_main_koenig]
\begin{code}
queens num = qu num where
  qu :: Int-> [[Pos]]
  qu n | n == 0  = [[]]
       | otherwise = 
     [ p++ [(n, m)] | p <- qu (n-1), 
                      m <- [1.. num], 
                      safe p (n, m)]
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
  \ListItem \texttt{[n..m]}: Liste der Zahlen von \texttt{n} bis \texttt{m}
  \ListItem Mehrere Generatoren in Listenkomprehension.
  \ListItem Rekursion über Anzahl der Königinnen.
\end{List}

\newpage

\ListItem Sichere neue Position:
  \begin{List}[ListType=itemize]
  \ListItem Neue Position ist sicher, wenn sie durch keine anderen bedroht
    wird:
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_sichere_pos_koenig]
\begin{code}
safe :: [Pos]-> Pos-> Bool
safe others nu = 
   and [ not (threatens other nu) 
         | other <- others ]
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Verallgemeinerte Konjunktion \texttt{and :: [Bool]-> Bool}
\end{List}
\ListItem Gegenseitige Bedrohung:
  \begin{List}[ListType=itemize]
  \ListItem Bedrohung wenn in gleicher Zeile, Spalte, oder Diagonale.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_bedroht_koenig]
\begin{code}
threatens :: Pos-> Pos-> Bool
threatens (i, j) (m, n) = 
   (j== n) || (i+j == m+n) || (i-j == m-n)
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem Test auf gleicher Spalte \texttt{i==m} unnötig.
    \hfill{} \RunFile{Testen.}{slides-3.tex}
  \end{List}
\end{List}
\end{Paragraph}

\end{Section}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para3_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Schemata für Funktionen über Listen:
  \begin{List}[ListType=itemize]
  \ListItem Listenkomprehension
  \ListItem primitive und nicht-rekursive Funktionen 
  \end{List}
\ListItem Polymorphie : 
  \SingleItem{Abstraktion über Typen durch \emph{Typvariablen}}
\ListItem Lokale Definitionen mit \texttt{where}
\ListItem Überblick: vordefinierte Funktionen auf Listen
\end{List}

\end{Summary}


\end{Section} % end Vorlesung 3


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root.tex"
%%% End: 
%%%% input replacer: Ende von slides-3.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-4.tex %%%%
%%
%% Praktische Informatik 3 - Fourth lecture
%%

\begin{Section}[Title={Vorlesung vom 12.11.2001: Formalisierung und
      Beweis -- Funktionen höherer Ordnung},
      ShortTitle={Funktionen höherer Ordnung}, Label={chapter4}]


%% code header
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
      Label=prgfrag_versteckt_slides4]
\begin{code}
module Slides4 where
import Prelude hiding (map,filter,foldr,takeWhile,dropWhile,span,sum,concat)
\end{code}
\end{ProgramFragment}
\end{comment}

\begin{Introduction}[Title={Inhalt}, Label=para4_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Formalisierung und Beweis
  \begin{List}[ListType=itemize]
  \ListItem Vollständige, strukturelle und Fixpunktinduktion
  \end{List}
\ListItem Verifikation
  \SingleItem{Tut mein Programm, was es soll?}
\ListItem Fallbeispiel: Verifikation von Mergesort
\ListItem Funktionen höherer Ordnung
  \begin{List}[ListType=itemize]
  \ListItem Berechnungsmuster (\textit{patterns of computation})
  \ListItem \texttt{map} und \texttt{filter}: Verallgemeinerte
    Listenkomprehension 
  \ListItem \texttt{fold}: Primitive Rekursion
  \end{List}
\end{List}

%\newslide{Warum Verifikation und Beweis?}

%\begin{itemize}
%\item Vertrauen in Korrektheit des Algorithmus erhöhen.
%\item Dokumentation
%\end{itemize}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{PROOF}},
  ShortTitle={Beweisprinzipien}, Label={section4_1_bew_prinz}]

\begin{Paragraph}[Title={Rekursive Definition, induktiver Beweis},
  Label=para4_1_1_rek_def_indukt_bew]

\begin{List}[ListType=itemize]
\ListItem Definition ist \emph{rekursiv}  
  \begin{List}[ListType=itemize]
  \ListItem Basisfall (leere Liste)
  \ListItem Rekursion (\texttt{x:xs})    
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bas_rek]
\begin{code}
rev :: [a]-> [a]
rev []     = []
rev (x:xs) = rev xs++ [x] 
\end{code}
\end{ProgramFragment}
  \ListItem Reduktion der Eingabe (vom größeren aufs kleinere)
  \end{List}
\ListItem \emph{Beweis} durch \DefClass{INDUCT}
  \begin{List}[ListType=itemize]
  \ListItem Schluß vom kleineren aufs größere
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beweis durch \DefClass{NatINDUCT}},
    Label=para4_1_2_vollst_indukt]

Zu zeigen: 
\[ \text{Für alle natürlichen Zahlen $x$ gilt $P(x)$.} \]

Beweis:
\begin{List}[ListType=itemize]
\ListItem Induktionsbasis: $P (0)$
\ListItem Induktionssschritt: 
  Annahme $P(x)$, zu zeigen $P(x +1)$.
\end{List}

% \newcommand{\MtList}{[]}
% \newcommand{\Cons}{:}

\end{Paragraph}


\begin{Paragraph}[Title={Beweis durch \DefClass{StructINDUCT}},
    Label=para4_1_3_strukt_indukt]

Zu zeigen: 
\[ \text{Für alle Listen $xs$ gilt $P(xs)$} \]

Beweis:
\begin{List}[ListType=itemize]
\ListItem Induktionssbasis: $P([])$
\ListItem Induktionssschritt: Annahme $P(xs)$, zu zeigen 
  $P(x:xs)$
\end{List}

\end{Paragraph}


\newcommand{\BinOp}[3]{\mathord{\mathtt{#1}}\:{#2}\:{#3}}
\newcommand{\UnOp}[2] {\mathord{\mathtt{#1}}\:{#2}}
\newcommand{\Cat}{\mathbin{\texttt{++}}}

\begin{Paragraph}[Title={Ein einfaches Beispiel}, Label=para4_1_4_bsp_lemma1]

%\newcommand{\BinOp}[3]{\mathord{\mathtt{#1}}\:{#2}\:{#3}}
%\newcommand{\UnOp}[2] {\mathord{\mathtt{#1}}\:{#2}}
%\newcommand{\Cat}{\mathbin{\texttt{++}}}
% ausserhalb der Paragraph-Umgebung verschoben, da sonst nur lokal
% definiert, was später zu `undef. control sequence' führt - CK

%\begin{Lemma}[Title={}, Label=lemma_einf_bsp]
% Lemma-Umgebung unbrauchbar, fügt zuviel vspace ein - zerstört Layout
% - CK
\textbf{Lemma:} 
$\UnOp{len}{(xs\Cat ys)}=
 \UnOp{len}{xs}+ \UnOp{len}{ys}$
%\end{Lemma}

% \textit{Beweis:} Induktion über $xs$.
\begin{List}[ListType=itemize]
\ListItem Induktionsbasis: $xs= []$ \\
  $\begin{array}[t]{rcl}
    \UnOp{len}{[]}+ \UnOp{len}{ys} 
    & = & 0+ \UnOp{len}{ys} \\
    & = & \UnOp{len}{ys} \\
    & = & \UnOp{len}{([] \Cat ys)}
  \end{array}$
\ListItem Induktionsschritt: \\
  Annahme: $\UnOp{len}{xs}+ \UnOp{len}{ys}= \UnOp{len}{(xs \Cat ys)}$,
  dann\\
  $\begin{array}[t]{rcl}
    \UnOp{len}{(x:xs)}+ \UnOp{len}{ys} 
    & = & 1+\UnOp{len}{xs}+ \UnOp{len}{ys} \\
    & = & 1+\UnOp{len}{(xs \Cat ys)}  \\
    & = & \UnOp{len}{(x:xs \Cat ys)} 
  \end{array}$
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Noch ein Beispiel}, Label=para4_1_5_bsp_lemma2]

\textbf{Lemma:} 
$\UnOp{rev}{(xs \Cat ys)} = \UnOp{rev}{ys} \Cat \UnOp{rev}{xs}$

% \textit{Beweis:} Induktion über $xs$.
\begin{List}[ListType=itemize]
\ListItem Induktionsbasis: \\
   $\begin{array}[t]{rcl}
     \UnOp{rev}{([] \Cat ys)} 
     & = & \UnOp{rev}{ys} \\
     & = & \UnOp{rev}{ys} \Cat \UnOp{rev}{[]} 
   \end{array}$
\ListItem Induktionsschritt: \\
  Annahme ist $\UnOp{rev}{(xs \Cat ys)} =
  \UnOp{rev}{ys} \Cat \UnOp{rev}{xs}$, dann\\
   $\begin{array}[t]{rcl@{\hspace{2ex}}l}
     \UnOp{rev}{(x:xs \Cat ys)} 
     & = & \UnOp{rev}{(xs \Cat ys)} \Cat [x] & \text{Def.} \\
     & = & (\UnOp{rev}{ys} \Cat \UnOp{rev}{xs}) \Cat [x] & \text{Ind.ann.} \\
     & = & \UnOp{rev}{ys} \Cat (\UnOp{rev}{xs}\Cat [x]) & \text{$\Cat$ assoz.}\\
     & = & \UnOp{rev}{ys} \Cat \UnOp{rev}{(x:xs)} \\
   \end{array}$
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\DefClass{FixedptINDUCT}}, Label=para4_1_6_fixp_indukt]
\begin{List}[ListType=itemize]
\ListItem 
Gegeben: rekursive Definition 
\eqn{f x = E \quad \text{$E$ enthält
  rekursiven Aufruf $f t$}}
\ListItem 
Zu zeigen: Für alle Listen $x$ gilt $P(f x)$

\ListItem 
Beweis: Annahme:$P (f t)$, zu zeigen: $P(E)$.

\begin{List}[ListType=itemize]
\ListItem d.h. ein Rekursionsschritt erhält $P$
\ListItem Ein Fall für jede rekursive Gleichung.
\ListItem Induktionsverankerung: nichtrekursive Gleichungen.   
\end{List}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\HOF\ I}, ShortTitle={Funktionen Höherer
        Ordnung I}, Label=section4_2_funkt_hoeherer_ord]

\begin{Paragraph}[Title={\RefClass[Berechnungsmuster]{PATTERN}},
    Label=para4_2_1_berechnungsmuster]

\begin{List}[ListType=itemize]
\ListItem \LISTCOMPREHENSION\ I: Funktion auf alle Elemente anwenden 
  \SingleItem{\texttt{toLower}, \texttt{move}, \dots }
\ListItem \LISTCOMPREHENSION\ II: Elemente herausfiltern
  \SingleItem{\texttt{books}, \texttt{returnLoan}, \dots}
\ListItem Primitive Rekursion 
  \SingleItem{\texttt{++}, \texttt{length}, \texttt{concat}, \dots}
\ListItem Listen zerlegen
  \SingleItem{\texttt{take}, \texttt{drop}}
\ListItem Sonstige 
  \SingleItem{\texttt{qsort}, \texttt{msort}}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\DefClass{HOF}},
  Label=para4_2_2_funkt_hoeherer_ord]

\begin{List}[ListType=itemize]
\ListItem Grundprinzip der funktionalen Programmierung
\ListItem Funktionen sind gleichberechtigt
  \SingleItem{d.h. Werte wie alle anderen}
\ListItem Funktionen als \emph{Argumente}: allgemeinere
\RefClass[Berechungsmuster]{PATTERN}
\ListItem Höhere Wiederverwendbarkeit
\ListItem Größere Abstraktion
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\FUN\ als Argumente},
    Label=para4_2_3_funkt_als_arg]
\begin{List}[ListType=itemize]
\ListItem Funktion auf alle Elemente anwenden: \texttt{map}
\ListItem Signatur: \pause{}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_als_arg_sig]
\begin{code}
map :: (a-> b)-> [a]-> [b]
\end{code}
\end{ProgramFragment}
\ListItem Definition
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_funkt_als_arg_def]
\begin{xcode}
map f xs = [ f x | x <- xs ]
\end{xcode}
\end{ProgramFragment}
\emph{- oder -}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_als_arg_alt_def]
\begin{code}
map f []     = []
map f (x:xs) = (f x):(map f xs)
\end{code}
\end{ProgramFragment}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Elemente filtern: \texttt{filter}
\ListItem Signatur: \pause{}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_als_arg_filter]
\begin{code}
filter :: (a-> Bool)-> [a]-> [a]
\end{code}
\end{ProgramFragment}
\ListItem Definition
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_funkt_als_arg_filter_def]
\begin{xcode}
filter p xs = [ x | x <- xs, p x ]    
\end{xcode}
\end{ProgramFragment}
\emph{- oder -}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_als_arg_filter_alt_def]
\begin{code}
filter p []   = []
filter p (x:xs) 
  | p x       = x:(filter p xs)
  | otherwise = filter p xs
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\PREC}, Label=para4_2_4_prim_rekur]
\begin{List}[ListType=itemize]
\ListItem Primitive Rekursion:
  \begin{List}[ListType=itemize]
  \ListItem Basisfall (leere Liste)
  \ListItem Rekursionsfall: Kombination aus Listenkopf und Rekursionswert
  \end{List}
\ListItem Signatur
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prim_rek_sig]
\begin{code}
foldr :: (a-> b-> b)-> b-> [a]-> b
\end{code}
\end{ProgramFragment}
\ListItem Definition
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prim_rek_def]
\begin{code}
foldr f e []     = e
foldr f e (x:xs) = f x (foldr f e xs)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Beispiel: Summieren von Listenelementen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_prim_rek_sum1]
\begin{code}
sum :: [Int]-> Int
sum xs = foldr (+) 0 xs
\end{code}
\end{ProgramFragment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_prim_rek_sum2]
\begin{xcode}
sum [3,12] = 3 + sum [12] 
           = 3+ 12+ sum []   
           = 3+ 12+ 0= 15
\end{xcode}
\end{ProgramFragment}
\pause{}
\ListItem Beispiel: Flachklopfen von Listen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_prim_rek_list_flach]
\begin{code}
concat :: [[a]]-> [a]
concat xs = foldr (++) [] xs
\end{code}
\end{ProgramFragment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_prim_rek_list_flach2]
\begin{xcode}
concat [l1,l2,l3,l4] = l1++ l2++ l3++ l4++ []
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Listen zerlegen}, Label=para4_2_5_listen_zerlegen]

\begin{List}[ListType=itemize]
\ListItem \texttt{take, drop}: $n$ Elemente vom Anfang
\ListItem Längster Präfix für den \emph{Prädikat} gilt 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_zerl1]
\begin{code}
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile p []          =  []
takeWhile p (x:xs) 
            | p x       =  x : takeWhile p xs
            | otherwise =  []
\end{code}
\end{ProgramFragment}
\ListItem Restliste des längsten Präfix
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_zerl2]
\begin{code}
dropWhile :: (a -> Bool) -> [a] -> [a]           
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_zerl3]
\begin{code}
dropWhile p []          =  []
dropWhile p xs@(x:xs')
            | p x       =  dropWhile p xs'
            | otherwise =  xs
\end{code}
\end{ProgramFragment}
\end{comment}
\ListItem Es gilt: \texttt{takeWhile p xs ++ dropWhile p xs == xs}
  \ListItem Kombination der beiden
\begin{ProgramFragment}[Title={}, Formalism=Haskell, Label=prgfrag_list_zerl4]
\begin{code}
span      :: (a -> Bool) -> [a] -> ([a],[a])
span p xs = (takeWhile p xs, dropWhile p xs)
\end{code}
\end{ProgramFragment}
\ListItem Ordnungserhaltendes Einfügen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_zerl5]
\begin{code}
ins :: Int-> [Int]-> [Int]  
ins x xs = lessx ++ [x] ++ grteqx where
  (lessx, grteqx) = span less xs
  less z = z < x
\end{code}
\end{ProgramFragment}
\ListItem Damit sortieren durch Einfügen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_list_zerl6]
\begin{code}
isort :: [Int]-> [Int]
isort xs = foldr ins [] xs
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beliebiges Sortieren}, Label=para4_2_6_belieb_sort]
\newcommand{\Rel}{\mathrel{\texttt{ord}}}
\begin{List}[ListType=itemize]
\ListItem Wieso eigentlich immer aufsteigend?\pause{}
\ListItem Ordnung als Argument \texttt{ord}
% \item Was ist mit Gleichheit? 
  \begin{List}[ListType=itemize]
  \ListItem Totale Ordnung: transitiv, \emph{antisymmetrisch}, reflexiv, total
  \ListItem Insbesondere: $x \Rel y \wedge y \Rel x \Implies x = y$
  \end{List}
%    \begin{itemize}
%    \item 
%      transitiv: $x \Rel y, y \Rel z \Implies x \Rel z$
%    \item 
%      antisymmetrisch: $x \Rel y, y \Rel x \Implies x= y$
%    \item 
%      reflexiv: $x \Rel x$
%    \item 
%      total: $x \Rel y \vee y \Rel x$
%    \end{itemize}    
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_belieb_sort]
\begin{code}
qsortBy :: (a-> a-> Bool)-> [a]-> [a]
qsortBy ord [] = []
qsortBy ord (x:xs) = 
     qsortBy ord [y| y<-xs, ord y x] ++ [x] ++
     qsortBy ord [y| y<-xs, not (ord y x)]
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para4_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Verifikation und Beweis
  \begin{List}[ListType=itemize]
  \ListItem Beweis durch strukturelle und Fixpunktinduktion
  \ListItem Verifikation eines nichttrivialen Algorithmus
  \end{List}
\ListItem Funktionen höherer Ordnung
  \begin{List}[ListType=itemize]
  \ListItem Funktionen als gleichberechtigte Werte
  \ListItem Erlaubt Verallgemeinerungen
  \ListItem Erhöht Flexibilität und Wiederverwendbarkeit
  \ListItem Beispiele: \texttt{map}, \texttt{filter}, \texttt{foldr}
  \ListItem Sortieren nach beliebiger Ordnung
  \end{List}
\end{List}

\end{Summary}


\end{Section} % end Vorlesung 4

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 



%%%% input replacer: Ende von slides-4.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-5.tex %%%%
%%
%% Praktische Informatik 3 - Fifth lecture
%%

%\begin{comment}
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
%    Label=prgfrag_versteckt_slides5]
%\begin{code}
%module Slides5 where
%import Prelude hiding ((.), id, any, all, curry, uncurry, elem, Word)
%import Slides4 (qsortBy)
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 18.11.2001: Funktionen Höherer
      Ordnung Typklassen}, ShortTitle={Funktionen Höherer Ordnung II},
    Label={chapter5}]


\begin{Introduction}[Title={Inhalt}, Label=para5_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Funktionen höherer Ordnung
  \begin{List}[ListType=itemize]
  \ListItem Letzte VL: verallgemeinerte Berechnungsmuster (\texttt{map},
    \texttt{filter}, \texttt{foldr}, \ldots)
  \ListItem Heute: Konstruktion neuer Funktionen aus alten
  \end{List}
\ListItem Nützliche Techniken:
  \begin{List}[ListType=itemize]
  \ListItem Anonyme Funktionen
  \ListItem Partielle Applikation
  \ListItem $\eta$-Kontraktion
  \end{List}
\ListItem Längeres Beispiel: Erstellung eines Index
\ListItem Typklassen: Überladen von Funktionen
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\FUN\ als Werte},
    Label={section5_1_funkt_als_werte}]

\begin{Paragraph}[Title={}, Label=para5_1_1_funkt_als_werte]

\begin{List}[ListType=itemize]

\ListItem Zusammensetzen neuer Funktionen aus alten. 

\ListItem Zweimal hintereinander anwenden:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_werte_1]
\begin{code}
twice :: (a-> a)-> (a-> a)    
twice f x = f (f x)
\end{code} 
\end{ProgramFragment}
\pause

\ListItem $n$-mal hintereinander anwenden:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_werte_2]
\begin{code}
iter :: Int-> (a-> a)-> a-> a
iter 0 f x = x
iter n f x | n > 0 = f (iter (n-1) f x) 
           | otherwise = x
\end{code}
\end{ProgramFragment}

 \newpage

\ListItem Funktionskomposition:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_komp_1]
\begin{code}
(.) :: (b-> c) -> (a-> b)-> a-> c
(f . g) x = f (g x)
\end{code}
\end{ProgramFragment}
\SingleItem{\texttt{f} \emph{nach} \texttt{g}.}
\ListItem Funktionskomposition vorwärts:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_komp_2]
\begin{code}
(>.>) :: (a-> b)-> (b-> c)-> a-> c
(f >.> g) x = g (f x)
\end{code}
\end{ProgramFragment}
\SingleItem{\emph{Nicht} vordefiniert!}

\ListItem Identität: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_komp_id]
\begin{code}
id :: a-> a
id x = x    
\end{code}
\end{ProgramFragment}
\SingleItem{Nützlicher als man denkt.}

\begin{comment}
\ListItem Prägnantere Schreibweise:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_funkt_komp_versteckt]
\begin{code}
twice':: (a-> a)-> a-> a
twice' f = f . f

iter' :: Int-> (a-> a)-> a-> a
iter' n f | 0 < n     = f . iter' (n-1) f
          | otherwise = id
\end{code}  
\end{ProgramFragment}
\end{comment}

\end{List}
\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{AnonymFUN}}, Label={section5_2_anon_funkt}]

\begin{Paragraph}[Title={}, Label=para5_2_1_anon_funkt]

\begin{List}[ListType=itemize]
\ListItem Nicht \emph{jede} Funktion muß einen Namen haben.
\ListItem Beispiel:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_anon_funkt1]
\begin{code}
ins x xs = lessx ++ [x] ++ grteqx where
  (lessx, grteqx) = span less xs
  less z = z < x
\end{code}
\end{ProgramFragment}
\ListItem Besser: statt \texttt{less} \emph{anonyome Funktion}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_anon_funkt2]
\begin{code}
ins' x xs = lessx ++ [x] ++ grteqx where 
  (lessx, grteqx) = span (\z-> z < x) xs
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
 \ListItem \texttt{\Backsl{}x-> E}\;=\;\texttt{f where f x= E} 
 \ListItem Auch pattern matching möglich
\end{List}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: Primzahlen}, Label=para5_2_2_bsp_primz]

\begin{List}[ListType=itemize]
\ListItem \Def{sieve_finite}{Sieb des Erathostenes}
  \begin{List}[ListType=itemize]
  \ListItem Für jede gefundene Primzahl \texttt{p} alle Vielfachen
    heraussieben
\pause{}
  \ListItem Dazu: filtern mit \verb!(\n-> n `mod` p /= 0)!
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erathos1]
\begin{code}
sieve :: [Integer]-> [Integer]
sieve []     = []
sieve (p:ps) = 
  p:(sieve (filter (\n-> n `mod` p /= 0) ps)) 
\end{code}
\end{ProgramFragment}

\ListItem Primzahlen im Intervall \texttt{[1..n]}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erathos2]
\begin{code}
primes :: Integer-> [Integer]
primes n = sieve [2..n]
\end{code}
\end{ProgramFragment}
% \SingleItem{NB: Mit \texttt{2} anfangen!}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={$\eta$-Kontraktion}, Label=para5_2_3_eta_kontrakt]

\begin{List}[ListType=itemize]
\ListItem Nützliche vordefinierte Funktionen:
  \SingleItem{Disjunktion/Konjunktion von Prädikaten über Listen}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_eta_kontrakt]
\begin{code}
all, any :: (a-> Bool)-> [a]-> Bool
any p      = or  . map p
all p      = and . map p
\end{code}
\end{ProgramFragment}
\ListItem \emph{Da fehlt doch was?!} \pause{}
% \begin{xcode}
% any p x = (or . map p) x     <-->  any p  =  or . map p
% \end{xcode}
% \begin{itemize}
\ListItem $\eta$-Kontraktion:
  \begin{List}[ListType=itemize]
  \ListItem Allgemein: $\texttt{\Backsl x-> E x} \Iff \texttt{E}$
  \ListItem Bei Funktionsdefinition: $\texttt{f x = E x} \Iff \texttt{f = E}$
  \ListItem Hier: Definition äquivalent zu \texttt{any p x = or (map p x)}
  \end{List}
\end{List}

\centerslidebody

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{PartAPPL}}, Label={section5_3_part_app}]

\begin{Paragraph}[Title={}, Label=para5_3_1_part_app]

\begin{List}[ListType=itemize]
\ListItem Funktionen können \emph{partiell} angewandt werden:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_part_app]
\begin{code}
double :: String-> String
double = concat . map (replicate 2)
\end{code}
\end{ProgramFragment}
\SingleItem{Zur Erinnerung: \texttt{replicate :: Int-> a-> [a]}}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Die Kürzungsregel bei Funktionsapplikation},
    Label=para5_3_2_kuerz_bei_funkt_app]

\newcommand{\Slashed}[1]{$\texttt{#1}\!\!\!/$}

Bei Anwendung der Funktion 
$$ \texttt{f :: t$_1$ -> t$_2$ -> \ldots{} -> t$_n$-> t} $$
auf $k$ Argumente mit $k\leq n$ 
$$\texttt{e$_1$ :: t$_1$, e$_2$ :: t$_2$, \ldots{}, e$_k$ :: t$_k$} $$
werden die Typen der Argumente \emph{gekürzt}:
$$ \begin{array}[t]{c}
 \texttt{f :: \Slashed{t}$_1$ -> \Slashed{t}$_2$ -> \ldots{} -> 
              \Slashed{t}$_k$ -> t$_{k+1}$ -> \ldots -> t$_n$ -> t} \\
 \texttt{f e$_1$ \ldots e$_k$ :: t$_{k+1}$ -> \ldots -> t$_n$ -> t}            
\end{array}$$

\newpage

\begin{List}[ListType=itemize]
\ListItem \PartAPPL\ von Operatoren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_part_anw_op]
\begin{xcode}
elem :: Int-> [Int]-> Bool
elem x = any (== x) 
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem \texttt{(== x)} \emph{Sektion} des Operators \texttt{==}
  (entspricht \texttt{\Backsl{}e-> e == x})
\end{List}
\end{List}

\scatterslidebody

\end{Paragraph}


\begin{Paragraph}[Title={Gewürzte Tupel: Curry}, Label=para5_3_3_curry]

\begin{List}[ListType=itemize]
\ListItem Unterschied zwischen\\
~~~~ \texttt{f :: a-> b-> c} und \texttt{f :: (a, b)-> c} ?
\begin{List}[ListType=itemize]
\ListItem Links partielle Anwendung möglich.
\ListItem Ansonsten äquivalent.
\end{List}
\ListItem Konversion:
  \begin{List}[ListType=itemize]
  \ListItem Rechts nach links:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_curry1]
\begin{code}
curry   :: ((a, b)-> c)-> a-> b-> c
curry f a b = f (a, b)
\end{code}
\end{ProgramFragment}
\ListItem Links nach rechts:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_curry2]
\begin{code}
uncurry :: (a-> b-> c)-> (a, b)-> c
uncurry f (a, b) = f a b
\end{code}
\end{ProgramFragment}
  \end{List}

% flip !?!

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: Der Index}, Label=para5_3_4_bsp_index]

\begin{List}[ListType=itemize]
\ListItem Problem: 
  \begin{List}[ListType=itemize]
  \ListItem Gegeben ein Text
\begin{verbatim}
brösel fasel\nbrösel brösel\nfasel brösel blubb
\end{verbatim}
   \ListItem Zu erstellen ein Index: für jedes Wort Liste der Zeilen, in
     der es auftritt
\begin{verbatim}
brösel [1, 2, 3]       blubb [3]       fasel [1, 3]
\end{verbatim}
  \end{List}
\ListItem Spezifikation der Lösung
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp_ind]
\begin{code}
type Doc = String
type Word= String
makeIndex :: Doc-> [([Int], Word)]
\end{code}
\end{ProgramFragment}

\newpage

\begin{List}[ListType=itemize]
\ListItem Zerlegung des Problems in einzelne Schritte \hfill{} Ergebnistyp
  \begin{List}[ListType=enumerate]
  \ListItem Text in Zeilen aufspalten: \hfill{} \texttt{[Line]} \\
    (mit \texttt{type Line= String})\pause{}
  \ListItem Jede Zeile mit ihrer Nummer versehen: \hfill{} \texttt{[(Int, Line)]} \pause{}
  \ListItem Zeilen in Worte spalten (Zeilennummer beibehalten): \\
    \hfill{}\texttt{[(Int, Word)]} \pause{}
  \ListItem Liste alphabetisch nach Worten sortieren: \hfill{} \texttt{[(Int,
      Word)]} \pause{}
  \ListItem Gleiche Worte in unerschiedlichen Zeilen zusammenfassen:\\
    \hfill{} \texttt{[([Int], Word)]} \pause{}
  \ListItem Alle Worte mit weniger als vier Buchstaben entfernen:\\
    \hfill{}\texttt{[([Int], Word)]} %\pause{} - CK
  \end{List}

\newpage

\ListItem Erste Implementierung:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_1st_impl]
\begin{code}
type Line = String
makeIndex =
  lines       >.> -- Doc -> [Line]
  numLines    >.> --     -> [(Int,Line)] 
  allNumWords >.> --     -> [(Int,Word)]
  sortLs      >.> --     -> [(Int,Word)]
  makeLists   >.> --     -> [([Int],Word)]
  amalgamate  >.> --     -> [([Int],Word)]
  shorten         --     -> [([Int],Word)]
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Implementierung der einzelnen Komponenten:

  \begin{List}[ListType=itemize]
  \ListItem In Zeilen zerlegen:
    
    \texttt{lines :: String-> [String]} aus dem Prelude
  \ListItem Jede Zeile mit ihrer Nummer versehen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zeil_num]
\begin{code}
numLines :: [Line]-> [(Int, Line)]
numLines lines = zip [1.. length lines] lines      
\end{code}
\end{ProgramFragment}

  \ListItem Jede Zeile in Worte zerlegen:

Pro Zeile: \texttt{words:: String-> [String]} aus dem Prelude. 

\begin{List}[ListType=itemize]
\ListItem Berücksichtigt nur Leerzeichen.
\ListItem Vorher alle Satzzeichen durch Leerzeichen ersetzen.
\end{List}

\newpage

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_split_words]
\begin{code}
splitWords :: Line-> [Word]
splitWords = words . map (\c-> if isPunct c then ' ' 
                               else c) where
   isPunct :: Char-> Bool
   isPunct c = c `elem` ";:.,\'\"!?(){}-\\[]"
\end{code}
\end{ProgramFragment}

Auf alle Zeilen anwenden, Ergebnisliste flachklopfen.

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_allnumwords]
\begin{code}
allNumWords :: [(Int, Line)]-> [(Int, Word)]
allNumWords = concat . map oneLine where
   oneLine :: (Int, Line)-> [(Int, Word)]
   oneLine (num, line) = map (\w-> (num, w)) 
                             (splitWords line)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Liste alphabetisch nach Worten sortieren:

Ordnungsrelation definieren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_ordrel_def]
\begin{code}
ordWord :: (Int, Word)-> (Int, Word)-> Bool
ordWord (n1, w1) (n2, w2) = 
  w1 < w2 || (w1 == w2 && n1 <= n2)      
\end{code}
\end{ProgramFragment}

Generische Sortierfunktion \texttt{qsortBy}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_qsort_alph]
\begin{code}
sortLs :: [(Int, Word)]-> [(Int, Word)]
sortLs = qsortBy ordWord
\end{code}
\end{ProgramFragment}

\ListItem Gleiche Worte in unerschiedlichen Zeilen zusammenfassen:

Erster Schritt: Jede Zeile zu (einelementiger) Liste von Zeilen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_makelists]
\begin{code}
makeLists :: [(Int, Word)]-> [([Int], Word)]
makeLists = map (\ (l, w)-> ([l], w))  
\end{code}
\end{ProgramFragment}

\newpage

Zweiter Schritt: Gleiche Worte zusammenfassen.
\SingleItem{Nach Sortierung sind gleiche Worte hintereinander!}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_amalgamate]
\begin{code}
amalgamate :: [([Int], Word)]-> [([Int],Word)]
amalgamate []  = []
amalgamate [p] = [p]
amalgamate ((l1, w1):(l2, w2):rest) 
  | w1 == w2  = amalgamate ((l1++ l2, w1):rest)
  | otherwise = (l1, w1):amalgamate ((l2, w2):rest)    
\end{code}
\end{ProgramFragment}

\ListItem Alle Worte mit weniger als vier Buchstaben entfernen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_shorten]
\begin{code}
shorten :: [([Int],Word)] -> [([Int],Word)]
shorten = filter (\ (_, wd)-> length wd >= 4)
\end{code}
\end{ProgramFragment}
Alternative Definition: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_shorten_alt_def]
\begin{xcode}
shorten = filter ((>= 4) . length . snd)  
\end{xcode}
\end{ProgramFragment}
\end{List}
\ListItem \RunFile{slides-5.tex}{Testen.}
\end{List}

\end{List}
% end List von Zeile 321:
% \begin{Paragraph}[Title={Beispiel: Der Index}, Label=para5_3_4_bsp_index]
% \begin{List}[ListType=itemize]
% etc... - CK

\end{Paragraph}


\begin{Paragraph}[Title={Der Programmentwicklungszyklus},
    Label=para5_3_5_prgzyklus]

\vspace*{3cm}

\begin{center}
\includegraphics[width=\textwidth]{fig/developmentcycle}  
%Bild fehlt - CK
\end{center}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\TYPClass}, Label={section5_4_typklassen}]
%\begin{Paragraph}

\begin{List}[ListType=itemize]
%% \item \emph{Fehler}: \texttt{isPunct c = c `elem` \ldots{}}
\ListItem Allgemeinerer Typ für \texttt{elem}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_typkl1]
\begin{xcode}
elem :: a-> [a]-> Bool
\end{xcode}
\end{ProgramFragment}
zu allgemein wegen \texttt{c ==} 
\begin{List}[ListType=itemize]
\ListItem \texttt{(==)} \emph{kann nicht} für \emph{alle} Typen definiert
    werden:
\ListItem z.B. \texttt{(==) :: (Int-> Int)-> (Int-> Int)-> Bool} ist
  \emph{nicht entscheidbar}.
\end{List}
\ListItem Lösung: \DefClass{TYPClass}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_typkl2]
\begin{code}
elem :: Eq a=> a-> [a]-> Bool
elem c = any (c ==)
\end{code} 
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Für \texttt{a} kann jeder Typ eingesetzt werden, für den
  \texttt{(==)} definiert ist.
\ListItem \DefObject{EQ} ist eine \emph{Klasseneinschränkung}
  (\textit{class constraint})
\end{List}
\ListItem Standard-\TYPClass: 
  \begin{List}[ListType=itemize]
  \ListItem \texttt{Eq a} für \texttt{== :: a-> a-> Bool} (Gleichheit)
  \ListItem \texttt{Ord a} für \texttt{<= :: a-> a-> Bool} (Ordnung)
    \begin{List}[ListType=itemize]
    \ListItem Alle Basisdatentypen
    \ListItem Listen, Tupel
    \ListItem \emph{Nicht} für Funktionsräume
    \end{List}
  \ListItem \texttt{Show a} für \texttt{show :: a-> String}
    \begin{List}[ListType=itemize]
    \ListItem Alle Basisdatentypen
    \ListItem Listen, Tupel
    \ListItem \emph{Nicht} für Funktionsräume
    \end{List}
  \ListItem \texttt{Read a} für \texttt{read :: String-> a}   
    \SingleItem{Siehe \texttt{Show}}
  \end{List}
% \item Typklassen erlauben des \emph{Überladen} von Funktionsnamen
%   (\texttt{(==)} etc.)
\end{List}

%\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Typüberprüfung}, Label={section5_5_typpruef}]
%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Ausdrücke in Haskell: Anwendung von Funktionen
\ListItem Deshalb Kern der Typüberprüfung: Funktionsanwendung
  \begin{diagram}[w=2em,h=1em]
    \texttt{s -> t} & & & & \texttt{s} \\
    & \rdTo{} & & \ldTo{} \\
    & & \textbf{\texttt{f e}} \\
    & & \dTo{} \\
    & & \texttt{t}
  \end{diagram}
\ListItem Einfach solange \TYP\ \emph{monomorph} 
  \begin{List}[ListType=itemize]
  \ListItem d.h. keine freien Typvariablen
  \ListItem Was passiert bei \emph{polymorphen} Ausdrücken?
  \end{List}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={Polymorphe Typüberprüfung},
  Label=para5_5_1_typpruef_poly]

\begin{List}[ListType=itemize]
\ListItem Bei polymorphen \FUN: \emph{Unifikation}.
\ListItem Beispiel: 
\eqn{
\begin{array}{cccccc}
\texttt{f(x,y)} & \texttt{=} & \texttt{(x,} & \texttt{['a'} & 
\texttt{..} & \texttt{y])} \\[.5em]
\pause
& & & \texttt{Char} \\ \pause
& & & & & \texttt{Char} \\ \pause
& & & & \texttt{[Char]} \\ \pause
& & \texttt{a} \\ \pause
& & \multicolumn{3}{c}{\texttt{(a, [Char])}} \\[.5em] 
\multicolumn{5}{l}{\texttt{f :: (a, Char)-> (a, [Char])}} 
\end{array}
}

\newpage

\ListItem Zweites Beispiel:
\eqn{%
\begin{array}{cccccc}
\texttt{g(m, zs)} & \texttt{=} & \texttt{m} & \texttt{+} &
\texttt{length} & \texttt{zs} \\[1em] \pause{}
& & & & \texttt{[b]-> Int} \\ \pause{}
& & & & & \texttt{[b]} \\ \pause{}
& & & & \multicolumn{2}{c}{\texttt{Int}} \\ \pause{}
& & \texttt{Int} \\ \pause{}
& & & \texttt{Int} \\[1em] 
\multicolumn{5}{l}{\texttt{g :: (Int, [b])-> Int}} 
\end{array}
}

\newpage

\ListItem Drittes Beispiel:
\eqn{\texttt{h = g . f}}
\begin{List}[ListType=itemize]
\ListItem \texttt{(.) ::(y-> z)-> (x-> y)-> x-> z} \pause{}
\ListItem \texttt{g :: (Int, [b])-> Int} \pause{}
\ListItem \texttt{f :: (a, Char)-> (a, [Char])} \pause{}
\end{List}
\ListItem Hier \emph{Unifikation} von
\texttt{(a, [Char])} und \texttt{(Int, [b])} zu
\eqn{\texttt{(Int, [Char]}}
\pause{}
\ListItem Damit 
\eqn{\texttt{h :: (Int, [Char])-> Int}}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Typunifikation}, Label=para5_5_2_typunif]

\begin{List}[ListType=itemize]
\ListItem Allgemeinste Instanz zweier Typausdrücke \texttt{s} und
  \texttt{t}
    \begin{List}[ListType=itemize]
      \ListItem Kann undefiniert sein.
    \end{List}
  \ListItem Berechnung rekursiv:
    \begin{List}[ListType=itemize]
      \ListItem Wenn beides Listen, Berechnung der Instanz der
        Listenelememente;
      \ListItem Wenn beides Tupel, Berechnung der Instanzen der Tupel;
      \ListItem Wenn eines Typvariable, zu anderem Ausdruck instanziieren;
      \ListItem Wenn beide unterschiedlich, undefiniert;
      \ListItem Dabei \emph{Vereinigung} der Typeinschränkungen
    \end{List}
\ListItem Anschaulich: Schnittmenge der Instanzen.
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para5_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Funktionen als Werte
\ListItem Anonyme Funktionen: \texttt{\Backsl{}x-> E}
\ListItem $\eta$-Kontraktion: $\texttt{f x = E x} \Rightarrow \mathtt{f =
    E}$
\ListItem Partielle Applikation und Kürzungsregel
\ListItem Indexbeispiel:
  \begin{List}[ListType=itemize]
  \ListItem Dekomposition in Teilfunktionen
  \ListItem Gesamtlösung durch Hintereinanderschalten der Teillösungen
  \end{List}
\ListItem Typklassen erlauben \emph{überladene Funktionen}.
\ListItem Typüberprüfung 
\end{List}

\end{Summary}

\end{Section} % end Vorlesung 5

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-5.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-6.tex %%%%
%%
%% Praktische Informatik 3 - Sixth lecture
%%

%\begin{comment}
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
%    Label=prgfrag_versteckt_slides6]
%\begin{code}
%module Slides6 where
%import Prelude hiding (print)
%import Maybe (fromMaybe)
%-- import Slides4 (qsortBy)
%-- import IOExts(trace)
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 25.11.2001: Algebraische
      Datentypen}, ShortTitle={Algebraische Datentypen},
    Label={chapter6}]


\begin{Introduction}[Title={Inhalt}, Label=para6_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Letzte VL: Funktionsabtraktion durch Funktionen höherer Ordnung.
\ListItem Heute: Datenabstraktion durch algebraische Datentypen.
\ListItem Einfache Datentypen: Aufzählungen und Produkte
\ListItem Der allgemeine Fall
\ListItem Bekannte Datentypen: \texttt{Maybe}, Bäume
\ListItem Geordnete Bäume 
\ListItem Abgeleitete Klasseninstanzen

\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Nichtrekursive Algebraische Datentypen},
    Label={section6_1_nichtrek_alg_dattyp}]

\begin{Paragraph}[Title={Was ist Datenabstraktion?},
    Label=para6_1_1_nichtrek_alg_dattyp]

\begin{List}[ListType=itemize]
\ListItem Typsynonyme sind \emph{keine} Datenabstraktion
  \begin{List}[ListType=itemize]
  \ListItem \texttt{type Dayname = Int} wird textuell expandiert.
  \ListItem Keinerlei Typsicherheit: 
    \begin{List}[ListType=itemize]
    \ListItem \texttt{Freitag + 15} ist kein Wochentag;
    \ListItem \texttt{Freitag * Montag} ist kein Typfehler.
    \end{List}
  \ListItem Kodierung \texttt{0 = Montag} ist willkürlich und nicht eindeutig.
  \end{List}
\ListItem Deshalb: 
  \begin{List}[ListType=itemize]
  \ListItem Wochentage sind nur Montag, Dienstag, \ldots{}, Sonntag.
  \ListItem Alle Wochentage sind unterschiedlich.
  \end{List}
\ListItem $\Longrightarrow$ Einfachster algebraischer Datentyp:
  \emph{Aufzählungstyp}.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\DefClass{ENUM}}, Label=para6_1_2_aufzaehlungen]

\begin{List}[ListType=itemize]
\ListItem Beispiel: Wochentage
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_aufzaehl1]
\begin{code}
data Weekday = Mo | Tu | We | Th | Fr | Sa | Su
\end{code}
\end{ProgramFragment}
\ListItem \emph{Konstruktoren}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_aufzaehl2]
\begin{xcode}
Mo :: Weekday, Tu :: Weekday, We :: Weekday, ...
\end{xcode}
\end{ProgramFragment}
\SingleItem{Konstruktoren werden nicht deklariert.}
\ListItem Funktionsdefinition durch pattern matching:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_aufzaehl3]
\begin{code}
isWeekend :: Weekday -> Bool
isWeekend Sa = True
isWeekend Su = True
isWeekend _  = False    
\end{code}
\end{ProgramFragment}

\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={\PROD}, Label=para6_1_3_produkte]
\begin{List}[ListType=itemize]

\ListItem Beispiel: \emph{Datum} besteht aus Tag, Monat, Jahr:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prod1]
\begin{code}
data Date  = Date Day Month Year    
type Day   = Int
data Month = Jan | Feb | Mar | Apr | May | Jun 
           | Jul | Aug | Sep | Oct | Nov | Dec
type Year  = Int
\end{code}
\end{ProgramFragment}

\ListItem Beispielwerte: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prod2]
\begin{code}
today     = Date 26 Nov 2001
bloomsday = Date 16 Jun 1904
fstday    = Date 1 Jan 1
\end{code}
\end{ProgramFragment}

\ListItem \emph{Konstruktor:} 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_prod3]
\begin{xcode}
Date :: Day-> Month-> Year-> Date
\end{xcode}
\end{ProgramFragment}

\ListItem Funktionsdefinition: 
\SingleItem{Über pattern matching Zugriff auf Argumente der Konstruktoren:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prod4]
\begin{code}
day  :: Date-> Day
year :: Date-> Year
day  (Date d m y) = d
year (Date d m y) = y
\end{code}
\end{ProgramFragment}
\SingleItem{\texttt{day}, \texttt{year} sind \emph{Selektoren}:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_prod5]
\begin{xcode}
day  today     = 26
year bloomsday = 1904
\end{xcode}
\end{ProgramFragment}

\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Alternativen}, Label=para6_1_4_alternativen]
\begin{List}[ListType=itemize]

\ListItem Beispiel: Eine \emph{geometrische Figur} ist 
  \begin{List}[ListType=itemize]
  \ListItem eine \emph{Kreis}, gegeben durch Mittelpunkt und Durchmesser, 
  \ListItem oder ein \emph{Rechteck}, gegeben durch zwei Eckpunkte,
  \ListItem oder ein \emph{Polygon}, gegeben durch Liste von Eckpunkten.\pause{}
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_alter1]
\begin{code}
type Point = (Double, Double)
data Shape = Circ Point Int 
           | Rect Point Point
           | Poly [Point]
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_alter2]
\begin{code}
           deriving (Show)
\end{code}  
\end{ProgramFragment}
\end{comment}
\ListItem Ein Konstruktor pro \emph{Variante}.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_alter3]
\begin{xcode}
Circ :: Point-> Int-> Shape
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Funktionen auf Geometrischen Figuren},
    Label=para6_1_5_funkt_geom_fig]

\begin{List}[ListType=itemize]
\ListItem Funktionsdefinition durch \emph{pattern matching}.
\ListItem Beispiel: Anzahl Eckpunkte.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig1]
\begin{code}
corners :: Shape-> Int
corners (Circ _ _)       = 0
corners (Rect _ _)       = 4
corners (Poly ps)        = length ps 
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Konstruktor-Argumente werden in ersten Fällen nicht gebraucht.
\end{List}

\newpage

\ListItem Translation um einen Punkt (Vektor):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig2]
\begin{code}
move :: Shape-> Point-> Shape
move (Circ m d) p   = Circ (add p m) d
move (Rect c1 c2) p = Rect (add p c1) (add p c2)
move (Poly ps) p    = Poly (map (add p) ps) 
\end{code}
\end{ProgramFragment}
\ListItem Translation eines Punktes:
\SingleItem{Durch Addition}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig3]
\begin{code}
add :: Point-> Point-> Point
add (x, y) (u, v) = (x+ u, y+ v)
\end{code}
\end{ProgramFragment}
% \end{itemize}

\newpage

\ListItem Berechung der Fläche:
  \begin{List}[ListType=itemize]
  \ListItem Einfach für Kreis und Rechteck.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig4]
\begin{code}
area :: Shape-> Double
area (Circ _ d) = pi* (fromInt d)
area (Rect (x1, y1) (x2, y2)) = 
      abs ((x2- x1)* (y2- y1))       
\end{code}
\end{ProgramFragment}
\vfill{}
\begin{center}
  \includegraphics[width=9cm]{fig/area-rechteck}  
  %Bild fehlt
\end{center}

\newpage

\ListItem Fläche für Polygone:
  \begin{List}[ListType=itemize]
  \ListItem Vereinfachende Annahme: Polygone konvex
  \ListItem Reduktion auf einfacheres Problem und Rekursion:\\[1em]
    \begin{center}
      \includegraphics[width=15cm]{fig/area-polygon}
      %Bild fehlt
    \end{center}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig5]
\begin{code}
area (Poly ps) | length ps < 3  = 0
area (Poly (p1:p2:p3:ps)) = 
           triArea p1 p2 p3 + 
           area (Poly (p1:p3:ps))
\end{code}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem Fläche für Dreieck mit Seitenlängen $a, b, c$ (Heron):
  \eqn{A = \sqrt{s(s-a)(s-b)(s-c)} 
       \quad\text{mit}\quad s= \frac{1}{2}(a+b+c)}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig6]
\begin{code}
triArea :: Point-> Point-> Point-> Double
triArea p1 p2 p3 = 
  let s= 0.5*(a+ b+ c) 
      a= dist p1 p2
      b= dist p2 p3
      c= dist p3 p1
  in  sqrt (s*(s- a)*(s- b)*(s- c))
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Distanz zwischen zwei Punkten (Pythagoras):
    \begin{center}
      \includegraphics[width=12cm]{fig/area-dist}
      %Bild fehlt
    \end{center}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geofig7]
\begin{code}
dist :: Point-> Point-> Double
dist (x1, y1) (x2, y2) = 
  sqrt((x1-x2)^2+ (y2- y1)^2)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass[Rekursive Algebraische Datentypen]{RECDat}},
    Label={section6_2_rek_algbr_dattyp}]

\begin{Paragraph}[Title={Das allgemeine Format},
    Label=para6_2_1_rek_algbr_dattyp]

\newcommand{\TT}[1]{\texttt{#1}}
\newcommand{\TTC}{\texttt{C}}
\newcommand{\TTt}{\texttt{t}}
\newcommand{\TTx}{\texttt{x}}
\newcommand{\TTy}{\texttt{y}}

Definition von \texttt{T}:
$\displaystyle
\texttt{data T}
\begin{array}[t]{cl}
= & \TTC_1\; \TTt_{1,1} \ldots \TTt_{1,k_1} \\
%%  & \TTC_2 \; \TTt_{2,1} \ldots \TTt_{2,k_2} \\
  & \ldots\\
| & \TTC_n\;  \TTt_{n,1} \ldots \TTt_{n,k_n} \\
\end{array}
$

\begin{List}[ListType=itemize]
\ListItem Konstruktoren (und Typen) werden groß geschrieben.
\ListItem Konstruktoren $\TTC_1,\ldots,\TTC_n$ sind \emph{disjunkt}:
\eqn{\TTC_i\;  \TTx_1 \ldots \TTx_n = \TTC_j\;  \TTy_1 \ldots \TTy_m \Implies i= j}

\ListItem Konstruktoren sind \emph{injektiv}:
\eqn{\TTC\; \TTx_1 \ldots \TTx_n = \TTC\; \TTy_1 \ldots \TTy_n 
     \Implies \TTx_i= \TTy_i}
\ListItem Konstruktoren \emph{erzeugen} den Datentyp:
\eqn{\forall x\in T.\: x= \TTC_i\; \TTy_1 \ldots \TTy_m}
\end{List}

% Hier

\end{Paragraph}


\begin{Paragraph}[Title={\RECDat}, Label=para6_2_2_rek_dattyp]

Der definierte Typ \texttt{T} kann rechts benutzt werden.
\begin{List}[ListType=itemize]
\ListItem Beispiel: einfache arithmetische Ausdrücke sind
  \begin{List}[ListType=itemize]
  \ListItem Zahlen (Literale), oder
  \ListItem Addition zweier Ausdrücke, oder
  \ListItem Multiplikation zweier Ausdrücke.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp1]
\begin{code}
data Expr = Lit Int 
          | Add Expr Expr
          | Sub Expr Expr
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp2]
\begin{code}
          deriving (Eq,Read,Show)    
\end{code}
\end{ProgramFragment}
\end{comment}
\ListItem Funktion darauf meist auch rekursiv.

\newpage

\ListItem Ausdruck auswerten: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp3]
\begin{code}
eval :: Expr-> Int
eval (Lit n)= n
eval (Add e1 e2) = eval e1+ eval e2
eval (Sub e1 e2) = eval e1- eval e2
\end{code}
\end{ProgramFragment}
\ListItem Ausdruck ausgeben:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp4]
\begin{code}
print :: Expr-> String 
print (Lit n) = show n
print (Add e1 e2) = "("++ print e1++ "+"++ print e2++ ")"
print (Sub e1 e2) = "("++ print e1++ "-"++ print e2++ ")"
\end{code}
\end{ProgramFragment}
\ListItem \RunFile{slides-6.tex}{Testen.}

\newpage

\ListItem Primitive Rekursion auf Ausdrücken
  \begin{List}[ListType=itemize]
  \ListItem Einen Wert für Rekursionsverankerung
  \ListItem Eine binäre Funktion für Addition
  \ListItem Eine binäre Funktion für Subtraktion
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp5]
\begin{code}
foldE :: (Int-> a)-> (a-> a-> a)-> (a-> a-> a)
            -> Expr-> a
foldE b a s (Lit n)     = b n
foldE b a s (Add e1 e2) = a (foldE b a s e1)
                            (foldE b a s e2)
foldE b a s (Sub e1 e2) = s (foldE b a s e1)
                            (foldE b a s e2)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Damit Auswertung und Ausgabe:
\begin{comment}    
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp6]
\begin{code}
eval' :: Expr-> Int
print':: Expr-> String    
\end{code}
\end{ProgramFragment}
\end{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rek_dattyp7]
\begin{code}
eval'  = foldE id (+) (-)
print' = 
  foldE show 
        (\s1 s2-> "("++ s1++ "+"++ s2++ ")")
        (\s1 s2-> "("++ s1++ "-"++ s2++ ")")
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{POLYMORPH}},
    Label={section6_3_poly_rek_dattyp}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Algebraische Datentypen parametrisiert über \TYP:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_poly_rek_dattyp1]
\begin{code}
data Pair a = Pair a a    
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_poly_rek_dattyp2]
\begin{code}
              deriving (Show, Read)    
\end{code}
\end{ProgramFragment}
\end{comment}
\ListItem Paar: zwei beliebige Elemente \emph{gleichen} Typs. \hfill{}\RunFile{slides-6.tex}{Zeigen.}
\pause{}
\ListItem Elemente vertauschen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_poly_rek_dattyp3]
\begin{code}
twist :: Pair a-> Pair a
twist (Pair a b) = Pair b a
\end{code}
\end{ProgramFragment}
\ListItem Map für Paare:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_poly_rek_dattyp4]
\begin{code}
mapP :: (a-> b)-> Pair a-> Pair b
mapP f (Pair a b)= Pair (f a) (f b)
\end{code}
\end{ProgramFragment}

\end{List}
%\end{Paragraph}


\begin{Paragraph}[Title={Listen!}, Label=para6_3_1_listen]

\begin{List}[ListType=itemize]

\ListItem Eine \LIST\ von \texttt{a} ist
\begin{List}[ListType=itemize]
\ListItem entweder leer
\ListItem oder ein Kopf \texttt{a} und eine Restliste \texttt{List a}
\end{List}

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_listen1]
\begin{code}
data List a = Mt | Cons a (List a)  
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_listen2]
\begin{code}
              deriving (Eq, Show)
\end{code}  
\end{ProgramFragment}
\end{comment}

\ListItem Syntaktischer Zucker der eingebauten Listen: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_listen3]
\begin{xcode}
data [a] = [] | a : [a]
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Geht so \emph{nicht}!
\ListItem Bei benutzerdefinierten Typen Operatoren als
  binäre Konstruktoren möglich.
\end{List}

\newpage

\ListItem Funktionsdefinition:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_listen4]
\begin{code}
fold :: (a-> b-> b)-> b-> List a-> b
fold f e Mt          = e
fold f e (Cons a as) = f a (fold f e as)
\end{code}
\end{ProgramFragment}
\ListItem Mit \texttt{fold} alle primitiv rekursiven Funktionen, wie:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_listen5]
\begin{code}
map' f    = fold (Cons . f) Mt
length'   = fold ((+).(const 1)) 0 
filter' p = fold (\x-> if p x then Cons x 
                       else id) Mt 
\end{code}
\end{ProgramFragment}
\SingleItem{Konstante Funktion \texttt{const:: a-> b-> a} aus dem Prelude.}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Modellierung von Fehlern: \texttt{Maybe a}},
    Label=para6_3_2_model_fehler]

\begin{List}[ListType=itemize]
\ListItem Typ \texttt{a} plus \emph{Fehlerelement}
\SingleItem{Im Prelude vordefiniert.}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_mod_fehler1]
\begin{xcode}
data Maybe a = Just a | Nothing 
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{Nothing} wird im "`Fehlerfall"' zurückgegeben. Bsp:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_fehler2]
\begin{code}
find :: (a-> Bool)-> [a]-> Maybe a
find p []     = Nothing
find p (x:xs) = if p x then Just x 
                else find p xs
\end{code}
\end{ProgramFragment}

\begin{comment}
\ListItem Anwendung von Funktion mit Default-Wert für Fehler
\SingleItem{Im Prelude vordefiniert.}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_mod_fehler3]
\begin{xcode}
maybe :: b -> (a -> b) -> Maybe a -> b
maybe n f Nothing  = n
maybe n f (Just x) = f x
\end{xcode}  
\end{ProgramFragment}
\ListItem Liften von Funktionen ohne Fehler:
  \begin{List}[ListType=itemize]
  \ListItem Wenn Fehler, dann Fehler;
  \ListItem Wenn kein Fehler, dann nicht.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_mod_fehler4]
\begin{xcode}
fmap :: (a-> b)-> Maybe a-> Maybe b
fmap f Nothing = Nothing
fmap f (Just x)= Just (f x)    
\end{xcode}
\end{ProgramFragment}
\end{comment}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Binäre Bäume}, Label=para6_3_3_bin_baeume]

\begin{List}[ListType=itemize]
\ListItem Ein binärer Baum ist
  \begin{List}[ListType=itemize]
  \ListItem Entweder leer,
  \ListItem oder ein Knoten mit genau \emph{zwei} Unterbäumen.
  \ListItem Knoten tragen ein Label.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume1]
\begin{code}
data Tree a = Null  
            | Node (Tree a) a (Tree a)  
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume2]
\begin{code}
               deriving (Eq, Read, Show)
\end{code}  
\end{ProgramFragment}
\end{comment}
\ListItem Andere Möglichkeiten:
  \begin{List}[ListType=itemize]
  \ListItem Label für Knoten und Blätter:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume3]
\begin{code}
data Tree' a b = Null' 
               | Leaf' b 
               | Node' (Tree' a b) a (Tree' a b)
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume4]
\begin{code}
  deriving (Eq, Read, Show)
\end{code}  
\end{ProgramFragment}
\end{comment}
\end{List}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Test auf Enthaltensein:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume5]
\begin{code}
member :: Eq a=> Tree a-> a-> Bool
member Null _ = False
member (Node l a r) b =
  a == b || (member l b) || (member r b)
\end{code}
\end{ProgramFragment}

\ListItem Primitive Rekursion auf Bäumen:
  \begin{List}[ListType=itemize]
  \ListItem Rekursionsschritt: 
    \begin{List}[ListType=itemize]
    \ListItem Label des Knoten
    \ListItem Zwei Rückgabewerte für linken, rechten Unterbaum
    \end{List}
  \ListItem Rekursionsanfang
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume6]
\begin{code}
foldT :: (a-> b-> b-> b)-> b-> Tree a-> b    
foldT f e Null = e
foldT f e (Node l a r) =
   f a (foldT f e l) (foldT f e r)
\end{code}
\end{ProgramFragment}
\ListItem Damit: Elementtest, \texttt{map}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume7]
\begin{code}
member' :: Eq a=> Tree a-> a-> Bool
\end{code}
\end{ProgramFragment}
\end{comment} 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume8]
\begin{code}    
member' t x = 
   foldT (\e b1 b2-> e == x || b1 || b2) False t

mapT :: (a-> b)-> Tree a-> Tree b
mapT f = foldT (flip Node . f) Null
\end{code}
\end{ProgramFragment}

\ListItem \RunFile{slides-6.tex}{Testen.}

\newpage

\ListItem Traversion: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume9]
\begin{code}
preorder  :: Tree a-> [a]
inorder   :: Tree a-> [a]
postorder :: Tree a-> [a]
preorder   = foldT (\x t1 t2-> [x]++ t1++ t2) []
inorder    = foldT (\x t1 t2-> t1++ [x]++ t2) []
postorder  = foldT (\x t1 t2-> t1++ t2++ [x]) []
\end{code}
\end{ProgramFragment}

\begin{List}[ListType=itemize]
\ListItem Äquivalente Definition ohne \texttt{foldT}: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume10]
\begin{code}
preorder' Null          = []
preorder' (Node l a r)  = [a] ++preorder' l ++preorder' r
\end{code}
\end{ProgramFragment}
\end{List}

\ListItem \RunFile{slides-6.tex}{Testen.}

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bin_baeume11]
\begin{code}
test1 = Node (Node Null 4 (Node Null 5 Null)) 7
             (Node (Node (Node Null 8 Null) 9 Null) 11 (Node Null 12 Null))
\end{code}
\end{ProgramFragment}
\end{comment} 
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Geordnete Bäume}, Label=para6_3_4_geord_baeume]

\begin{List}[ListType=itemize]
\ListItem Voraussetzung:
  \begin{List}[ListType=itemize]
  \ListItem Ordnung auf \texttt{a} (\texttt{Ord a})
  \ListItem Es soll für alle \texttt{Tree a l r} gelten:
    \eqn{\texttt{member x l}\Implies \texttt{x} <
      \texttt{a} \wedge \texttt{member x r}\Implies \texttt{a} <
      \texttt{x}}
  \end{List}

\ListItem Test auf Enthaltensein vereinfacht:  
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_geord_baeume1]
\begin{xcode}
member :: Ord a=> Tree a-> a-> Bool
member Null _ = False
member (Node l a r) b
  | b < a  = member l b
  | a == b = True 
  | b > a  = member r b  
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem Ordnungserhaltendes Einfügen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geord_baeume2]
\begin{code}
insert :: Ord a=> Tree a-> a-> Tree a
insert Null a = Node Null a Null
insert (Node l a r) b
  | b < a  = Node (insert l b) a r
  | b == a = Node l a r
  | b > a  = Node l a (insert r b) 
\end{code}
\end{ProgramFragment}
\ListItem \emph{Problem}: Erzeugung ungeordneter Bäume möglich.
  \begin{List}[ListType=itemize]
  \ListItem Lösung erfordert \emph{Verstecken} der Konstrukturen ---
    nächste VL.
  \end{List}

\newpage

\ListItem Löschen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geord_baeume3]
\begin{code}
delete :: Ord a=> a-> Tree a-> Tree a
delete x Null = Null
delete x (Node l y r) 
  | x < y  = Node (delete x l) y r
  | x == y = join l r
  | x > y  = Node l y (delete x r)
\end{code}
\end{ProgramFragment}
\ListItem \texttt{join} fügt zwei Bäume ordnungserhaltend zusammen.

\newpage

\ListItem Beispiel: Gegeben folgender Baum, dann \texttt{delete t 9}
  \begin{center}
    \includegraphics[width=15cm]{fig/tree-delete1}
    %Bild fehlt
    \pause
  \end{center}
  \begin{List}[ListType=itemize]
  \ListItem Wurzel wird gelöscht \pause{}
  \ListItem \texttt{join} muß Bäume ordnungserhaltend zusammenfügen
  \end{List}

\newpage

\ListItem \texttt{join} fügt zwei Bäume ordnungserhaltend zusammen.
  \begin{center}
    \includegraphics[width=15cm]{fig/tree-delete3}
    %Bild fehlt
  \end{center}

  \begin{List}[ListType=itemize]
  \ListItem Wurzel des neuen Baums: 
    Knoten \emph{links unten} im rechten Teilbaum 
    (oder Knoten rechts unten im linken Teilbaum)
  \end{List}

\newpage

\ListItem Implementation:
  \begin{List}[ListType=itemize]
  \ListItem \texttt{splitTree} spaltet Baum in Knoten links unten und
    Rest.
%%  \item Annahme: \texttt{xt} nicht leer wenn \texttt{yt} nicht leer.
  \ListItem \RunFile{slides-6.tex}{Testen.}
  \end{List}

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geord_baeume4]
\begin{code}
join ::  Tree a-> Tree a-> Tree a
join xt Null = xt
join xt yt   = Node xt u nu where
  (u, nu) = splitTree yt
  splitTree :: Tree a-> (a, Tree a)
  splitTree (Node Null a t) = (a, t)
  splitTree (Node lt a rt) =
    (u, Node nu a rt) where
       (u, nu) = splitTree lt
\end{code}
\end{ProgramFragment}


\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geord_baeume5]
\begin{code}
t = Node (Node (Node Null 1 Null)
                5
               (Node Null 7 Null))
         9
         (Node (Node Null 13 Null)
               10
               (Node Null 29 Null))
\end{code}
\end{ProgramFragment}
\end{comment} 

\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{DerivClassINST}},
                Label={section6_4_abgel_klass_inst}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Wie würde man Gleichheit auf \texttt{Shape} definieren?
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_abgel_klass_inst1]
\begin{code}
instance Eq Shape where
\end{code}
\end{ProgramFragment}
\end{comment} %%
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_abgel_klass_inst2]
\begin{code}
 Circ p1 i1 == Circ p2 i2 = p1 == p2 && i1 == i2
 Rect p1 q1 == Rect p2 q2 = p1 == p2 && q1 == q2
 Poly ps    == Poly qs    = ps == qs
 _          == _          = False
\end{code}
\end{ProgramFragment}
\ListItem \emph{Schematisierbar:}
  \begin{List}[ListType=itemize]
  \ListItem Gleiche Konstruktoren mit gleichen Argumente gleich,
  \ListItem alles andere ungleich.
  \end{List}
\ListItem Automatisch generiert durch \texttt{deriving Eq}
\ListItem Ähnlich \texttt{deriving (Ord, Show, Read)}
\end{List}

%\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para6_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Algebraische Datentypen erlauben \emph{Datenabstraktion} durch
  \begin{List}[ListType=itemize]
  \ListItem Trennung zwischen Repräsentation und Semantik und
  \ListItem Typsicherheit.
  \end{List}
\ListItem Algebraischen Datentypen sind \emph{frei erzeugt}.
\ListItem Bekannte algebraische Datentypen:
  \begin{List}[ListType=itemize]
  \ListItem Aufzählungen, Produkte, Varianten;
  \ListItem \texttt{Maybe a}, Listen, Bäume
  \end{List}
\ListItem Für geordnete Bäume: \\
  \emph{Verstecken} von Konstruktoren nötig --- nächste Vorlesung.
\end{List}

\end{Summary}

\end{Section} % End Vorlesung 6

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-6.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-7.tex %%%%
%%
%% Praktische Informatik 3 - Seventh lecture
%%

\begin{Section}[Title={Vorlesung vom 02.12.2002: Abstrakte
      Datentypen}, ShortTitle={Abstrakte Datentypen},
    Label={chapter7}]


\begin{Introduction}[Title={Inhalt}, Label=para7_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Letzte VL: 
  \begin{List}[ListType=itemize]
  \ListItem Datenabstraktion durch algebraische Datentypen
  \ListItem Mangelndes information hiding
  \end{List}
\ListItem Heute: abstrakte Datentypen (ADTs) in Haskell
\ListItem Beispiele für bekannte ADTs: 
  \begin{List}[ListType=itemize]
  \ListItem \texttt{Store}
  \ListItem Stapel und Schlangen: \texttt{Stack} und \texttt{Queue}
  \ListItem Endliche Mengen: \texttt{Set}
%  \item Relationen und Graphen
  \end{List}
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{AbstrDatTYP}}, Label=section7_1_abstr_dattyp]

\begin{center}
  Ein \emph{abstrakter Datentyp} besteht aus \\
  einem \emph{\TYP} und \emph{Operationen} darauf.
\end{center}
\begin{List}[ListType=itemize]
\ListItem Beispiele:
  \begin{List}[ListType=itemize]
  \ListItem geordnete Bäume, mit leerer Baum, einfügen, löschen, suchen; 
  \ListItem Speicher, mit Operationen lesen und schreiben; 
  \ListItem Stapel, mit Operationen \texttt{push},
    \texttt{pop}, \texttt{top};
  \ListItem Schlangen, mit Operationen einreihen, Kopf, nächstes
    Element;
  \end{List}

\ListItem \emph{Repräsentation} des Typen \emph{versteckt}.
\end{List}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefObject{HaskellMODULE}}, ShortTitle={Module},
    Label={section7_2_module}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Einschränkung der Sichtbarkeit durch \emph{Verkapselung}
\ListItem Modul: Kleinste verkapselbare Einheit
\ListItem Ein Modul umfaßt:
  \begin{List}[ListType=itemize]
  \ListItem Definitionen von Typen, Funktionen, Klassen
  \ListItem Deklaration der nach außen \emph{sichtbaren} Definitionen
  \end{List}
\ListItem Syntax:
\eqn{\texttt{module }\textit{Name}\texttt{ (}\textit{sichtbare Bezeichner}
\texttt{) where }\textit{Rumpf}}
\begin{List}[ListType=itemize]
\ListItem \textit{sichtbare Bezeichner} können leer sein
\ListItem Gleichzeitig: Übersetzungseinheit (getrennte Übersetzung)
\end{List}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: ein einfacher Speicher
      (\texttt{Store})}, Label=para7_2_1_bsp_speicher]

\begin{List}[ListType=itemize]
\ListItem Typ \texttt{Store a b}, parametrisiert über 
  \begin{List}[ListType=itemize]
  \ListItem Indextyp (muß Gleichheit, oder besser Ordnung, zulassen)
  \ListItem Wertyp
  \end{List}
\ListItem Konstruktor: leerer Speicher \texttt{initial :: Store a b}
\ListItem Wert lesen: \texttt{value :: Store a b-> a-> Maybe b}
  \begin{List}[ListType=itemize]
  \ListItem Möglicherweise undefiniert.
  \end{List}
\ListItem Wert schreiben: \\
\texttt{update :: Store a b-> a -> b-> Store a b}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Moduldeklaration}, Label=para7_2_2_modul_dekl]

\begin{List}[ListType=itemize]
\ListItem Moduldeklaration

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_modul_dekl1]
\begin{xcode}
module Store(
   Store,  
   initial, -- Store a b 
   value,   -- Store a b-> a-> Maybe b
   update,  -- Store a b-> a-> b-> Store a b
   ) where

\end{xcode}
\end{ProgramFragment}
\ListItem Signaturen nicht nötig, aber \emph{sehr} hilfreich.
\end{List}

\end{Paragraph}


%%%% input replacer: Start von slides-7-1.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modul_dekl2]
\begin{code}
module Store1(Store, initial, value, update) where

initial :: Store a b
value   :: Eq a=> Store a b-> a-> Maybe b
update  :: Eq a=> Store a b-> a-> b-> Store a b
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Erste Implementation}, Label=para7_2_2_1_erste_impl1]

\begin{List}[ListType=itemize]
\ListItem Speicher als Liste von Paaren (NB. \texttt{data}, nicht \texttt{type})
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_impl]
\begin{code}
data Store a b = St [(a, b)]
\end{code}
\end{ProgramFragment}

\ListItem Leerer Speicher: leere Liste
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_impl2]
\begin{code}
initial  = St []  
\end{code}
\end{ProgramFragment}

\ListItem Lookup (\emph{Neu:} \texttt{case} für Fallunterscheidungen):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_impl3]
\begin{code}    
value (St ls) a = case filter ((a ==).fst) ls of
                    (_, x):_ -> Just x
                    []       -> Nothing      
\end{code}
\end{ProgramFragment}
\ListItem Update: neues Paar vorne anhängen  
              \hfill{\RunFile{Test.}{slides-7-1.tex}}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_impl4]
\begin{code}
update (St ls) a b  = St ((a, b): ls)
\end{code}
\end{ProgramFragment}

\end{List}

\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7-1.tex %%%%


%%%% input replacer: Start von slides-7-2.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modul_dekl3]
\begin{code}
module Store2(Store, initial, value, update) where
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Zweite Implementation}, Label=para7_2_2_2_zweite_impl]

\begin{List}[ListType=itemize]
\ListItem Speicher als Funktion
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zweite_impl1]
\begin{code}
data Store a b = St (a-> Maybe b)
\end{code}
\end{ProgramFragment}

\ListItem Leerer Speicher: konstant undefiniert
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zweite_impl2]
\begin{code}
initial  = St (const Nothing)
\end{code}
\end{ProgramFragment}

\ListItem Lookup: Funktion anwenden
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zweite_impl3]
\begin{code}
value (St f) a  = f a  
\end{code}
\end{ProgramFragment}

\ListItem Update: punktweise Funktionsdefinition
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zweite_impl4]
\begin{code}
update (St f) a b 
  = St (\x-> if x== a then Just b else f x)  
\end{code}
\end{ProgramFragment}
\end{List}

\begin{center}
\emph{Ein} Interface, \emph{zwei} mögliche Implementierungen.  
\end{center}


\end{Paragraph}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7-2.tex %%%%



\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefObject{EXPORT} von Datentypen},
ShortTitle={Export und
      Import}, Label={section7_3_export_dattyp}]

%\begin{Paragraph}

  \begin{List}[ListType=itemize]
  \ListItem \texttt{Store(..)} exportiert Konstruktoren
    \begin{List}[ListType=itemize]
    \ListItem Implementation sichtbar
    \ListItem Pattern matching möglich
    \end{List}
  \ListItem \texttt{Store} exportiert \emph{nur} den Typ
    \begin{List}[ListType=itemize]
    \ListItem Implemtation nicht sichtbar
    \ListItem Kein pattern matching möglich
    \end{List}
  \ListItem Typsynonyme immer sichtbar

  \ListItem Kritik Haskell:
    \begin{List}[ListType=itemize]
    \ListItem Exportsignatur nicht im Kopf (nur als Kommentar)
    \ListItem Exportsignatur nicht von Implementation zu trennen (gleiche Datei!)
    \end{List}
  \end{List}
  
%\end{Paragraph}


\begin{Paragraph}[Title={Benutzung eines ADTs --- Import.},
    Label=para7_3_1_adt]

\eqn{\texttt{import [qualified] }\textit{Name} \texttt{ [hiding] (}\textit{Bezeichner}\texttt{)}}

\begin{List}[ListType=itemize]
\ListItem Ohne Bezeichner wird alles importiert
\ListItem \texttt{qualified}: \emph{qualifizierte} Namen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_adt1]
\begin{xcode}
import Store2 qualified
f = Store2.initial 
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{hiding}: Liste der Bezeichner wird \emph{versteckt}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_adt2]
\begin{xcode}import Prelude hiding (foldr) 
foldr f e ls = ...
\end{xcode}
\end{ProgramFragment}
\ListItem Mit \texttt{qualified} und \texttt{hiding} Namenskonflikte
  auflösen.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Schnittstelle vs. Semantik},
  Label=para7_3_2_schnitt_semant]

\begin{List}[ListType=itemize]
\begin{minipage}[t]{0.45\textwidth}
\ListItem Stacks
  \begin{List}[ListType=itemize]
  \ListItem Typ: \texttt{St a}
  \ListItem Initialwert: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem1]
\begin{xcode}
empty :: St a
\end{xcode}
\end{ProgramFragment}
  \ListItem Wert ein/auslesen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem2]
\begin{xcode}
push :: a-> St a-> St a
top  :: St a-> a      
pop  :: St a-> St a
\end{xcode}
\end{ProgramFragment}
  \ListItem Test auf Leer
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem3]
\begin{xcode}
isEmpty :: St a-> Bool      
\end{xcode}
\end{ProgramFragment}
\ListItem Last in, first out.
\end{List}
\end{minipage}
\begin{minipage}[t]{0.45\textwidth}
\ListItem Queues
  \begin{List}[ListType=itemize]
  \ListItem Typ: \texttt{Qu a}
  \ListItem Initialwert: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem4]
\begin{xcode}
empty :: Qu a
\end{xcode}
\end{ProgramFragment}
  \ListItem Wert ein/auslesen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem5]
\begin{xcode}
enq   :: a-> Qu a-> Qu a
first :: Qu a-> a  
deq   :: Qu a-> Qu a
\end{xcode}
\end{ProgramFragment}
  \ListItem Test auf Leer
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_schnitt_sem6]
\begin{xcode}
isEmpty :: Qu a-> Bool      
\end{xcode}
\end{ProgramFragment}
\ListItem First in, first out.
\end{List}
\end{minipage}

\ListItem Gleiche Signatur, unterscheidliche Semantik.
\end{List}

\end{Paragraph}


%%%% input replacer: Start von slides-7-stack.tex %%%%
\begin{Paragraph}[Title={Implementation von \texttt{Stack}: Liste},
    Label=para7_3_2_1_impl_stack]

\begin{List}[ListType=itemize]
\ListItem Sehr einfach wg. last in, first out

\ListItem \texttt{empty} ist \texttt{[]}
    
\ListItem \texttt{push} ist \texttt{(:)}

\ListItem \texttt{top} ist \texttt{head}

\ListItem \texttt{pop} ist \texttt{tail}

\ListItem \texttt{isEmpty} ist \texttt{null}

\ListItem \ShowFile{slides-6-stack.tex}{Zeigen?}

\end{List}


\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_stack1]
\begin{code}


module Stack (St, push, pop, top, isEmpty) where

data St a= St [a]  deriving (Show, Eq)

empty :: St a
empty =  St []

push :: a-> St a-> St a
push a (St s) = St (a:s)

top  :: St a-> a
top  (St [])  = error "Stack: top on empty stack"
top  (St s)   = head s

pop  :: St a-> St a
pop  (St [])  = error "Stack: pop on empty stack"
pop  (St s)   = St (tail s)

isEmpty :: St a-> Bool
isEmpty (St s)= null s

\end{code}  
\end{ProgramFragment}
\end{comment}

\end{Paragraph}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7-stack.tex %%%%


%%%% input replacer: Start von slides-7-q.tex %%%%
\begin{Paragraph}[Title={Implementation von \texttt{Queue}},
    Label=para7_3_2_2_impl_queue]

\begin{List}[ListType=itemize]
\ListItem Mit einer Liste?
  \begin{List}[ListType=itemize]
  \ListItem Problem: am Ende anfügen oder abnehmen ist teuer.
  \end{List}
\ListItem Deshalb zwei Listen:
  \begin{List}[ListType=itemize]
  \ListItem Erste Liste: zu entnehmende Elemente
  \ListItem Zweite Liste: hinzugefügte Elemente \emph{rückwärts}
  \ListItem Invariante: erste Liste leer gdw. Queue leer
  \end{List}

\ListItem Beispiel:

\begin{tabular}[t]{l@{\hspace{5ex}}c@{\hspace{5ex}}l}
Operation & Queue & Repräsentation \\ \pause{} 
\texttt{empty} & & ([], []) \\ \pause{} 
\texttt{enq 9} & 9 & ([9], [])  \\ \pause{} 
\texttt{enq 4} & 4 $\rightarrow$ 9 & ([9], [4]) \\ \pause{} 
\texttt{deq} & 4 & ([4], []) \\ \pause{} 
\texttt{enq 7} & 7 $\rightarrow$ 4 & ([4], [7]) \\ \pause{} 
\texttt{enq 5} & 5 $\rightarrow$ 7 $\rightarrow$ 4 & ([4], [5, 7]) \\ \pause{}  
\texttt{deq} & 5 $\rightarrow$ 7 & ([7, 5], []) \\ \pause{}  
\texttt{deq} & 7 & ([5], []) \\ \pause{}
\texttt{deq} &   & ([], []) \\  
\end{tabular}

\end{List}

\newpage

\begin{List}[ListType=itemize]
% leeres ListItem? - CK
\ListItem 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue1]
\begin{code}
module Queue(Qu, empty, isEmpty, 
             enq, first, deq) where

data Qu a = Qu [a] [a]
empty = Qu [] []
\end{code}
\end{ProgramFragment}

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue2]
\begin{code}
empty :: Qu a
isEmpty :: Qu a-> Bool
enq   :: a-> Qu a-> Qu a
first :: Qu a-> a  
deq   :: Qu a-> Qu a
\end{code}
\end{ProgramFragment}
\end{comment}

\ListItem Invariante: erste Liste leer gdw. Queue leer
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue3]
\begin{code}
isEmpty (Qu xs _) = null xs
\end{code}
\end{ProgramFragment}
\ListItem Erstes Element steht vorne in erster Liste
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue4]
\begin{code}
first (Qu [] _)  = error "Qu: first of mt Q"
first (Qu (x:xs) _) = x
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Bei \texttt{enq} und \texttt{deq} Invariante prüfen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue5]
\begin{code}
enq x (Qu xs ys) = check xs (x:ys)  

deq (Qu [] _ )     = error "Qu: deq of mt Q"
deq (Qu (_:xs) ys) = check xs ys
\end{code}
\end{ProgramFragment}

\ListItem \texttt{check} prüft die Invariante
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_queue6]
\begin{code}
check [] ys = Qu (reverse ys) []
check xs ys = Qu xs ys
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7-q.tex %%%%


%%%% input replacer: Start von slides-7-set.tex %%%%
\begin{Paragraph}[Title={Endliche Mengen}, Label=para7_3_2_3_endl_mengen]

\begin{List}[ListType=itemize]
\ListItem Eine \emph{endliche Menge} ist Sammlung von Elementen so dass
  \begin{List}[ListType=itemize]
  \ListItem kein Element doppelt ist, und
  \ListItem die Elemente nicht angeordnet sind.
  \end{List}
\ListItem Operationen:
  \begin{List}[ListType=itemize]
    \ListItem leere Menge und Test auf leer,
    \ListItem Element einfügen, 
    \ListItem Element löschen,
    \ListItem Test auf Enthaltensein,
    \ListItem Elemente aufzählen.
    \end{List}
  \end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Endliche Mengen --- Schnittstelle},
    Label=para7_3_2_4_endl_mengen_schnitt]

\begin{List}[ListType=itemize]
\ListItem Typ \texttt{Set a}
  \begin{List}[ListType=itemize]
  \ListItem Typ \texttt{a} mit Gleichheit, besser Ordnung.
  \end{List}
\end{List}

\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_end_men_schnitt1]
\begin{code}
module Set (Set,
  empty,   -- Set a
  isEmpty, -- Set a-> Bool
  insert,  -- Ord a=> Set a-> a-> Set a
  remove,  -- Ord a=> Set a-> a-> Set a
  elem,    -- Ord a=> a-> Set a-> Bool
  enum     -- Ord a=> Set a-> [a]
  ) where
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_end_men_schnitt2]
\begin{code}
import Prelude hiding(elem)
\end{code}  
\end{ProgramFragment}
\end{comment}

\end{Paragraph}


\begin{Paragraph}[Title={Endliche Mengen --- Implementation},
    Label=para7_3_2_5_endl_mengen_impl] 

\begin{List}[ListType=itemize]
\ListItem Implementation durch \emph{balancierte Bäume} 
  \begin{List}[ListType=itemize]
  \ListItem AVL-Bäume = 
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_endl_mengen_impl1]
\begin{code}
type Set a = AVLTree a
\end{code}
\end{ProgramFragment}

\ListItem Ein Baum ist \emph{ausgeglichen}, wenn 
  \begin{List}[ListType=itemize]
  \ListItem alle Unterbäume ausgeglichen sind, und
  \ListItem der Höhenunterschied zwischen zwei Unterbäumen höchstens eins
    beträgt.
  \end{List}

\newpage

\ListItem Im Knoten Höhe des Baumes an dieser Stelle
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_endl_mengen_impl2]
\begin{code}
data AVLTree a = Null 
               | Node Int 
                         (AVLTree a) 
                         a 
                         (AVLTree a)
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_endl_mengen_impl3]
\begin{code}
    deriving Eq
instance Show a=> Show (AVLTree a) where
  show t = shw 0 t where
    shw _ Null = []
    shw n (Node _ l a r) = (shw (n+1) l)
                              ++ spc n ++ show a  ++"\n" 
                              ++ (shw (n+1) r)
    spc n = concat (replicate n "   ")
\end{code}           
\end{ProgramFragment}
\end{comment}

\ListItem Ausgeglichenheit ist \emph{Invariante}.

\ListItem Alle Operationen müssen Ausgeglichenheit bewahren.

\ListItem Bei Einfügen und Löschen ggf. \emph{rotieren}.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Simple Things First}, Label=para7_3_2_6_simple_first]

\begin{List}[ListType=itemize]
\ListItem Leere Menge = leerer Baum
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_simple_first1]
\begin{code}
empty :: AVLTree a
empty = Null    
\end{code}
\end{ProgramFragment}

\ListItem Test auf leere Menge:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_simple_first2]
\begin{code}
isEmpty :: AVLTree a-> Bool
isEmpty Null = True
isEmpty _       = False
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Hilfsfunktionen}, Label=para7_3_2_7_hilfsfunkt]
\begin{List}[ListType=itemize]
\ListItem Höhe eines Baums
  \begin{List}[ListType=itemize]
  \ListItem Aus Knoten selektieren, \emph{nicht berechnen}.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_hilfsfunkt1]
\begin{code}
ht :: AVLTree a-> Int
ht Null           = 0
ht (Node h _ _ _) = h  
\end{code}
\end{ProgramFragment}

\ListItem Neuen Knoten anlegen, Höhe aus Unterbäumen berechnen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_hilfsfunkt2]
\begin{code}
mkNode :: AVLTree a-> a-> AVLTree a-> AVLTree a
mkNode l n r = Node h l n r where
               h = 1+ max (ht l) (ht r)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Ausgeglichenheit sicherstellen},
    Label=para7_3_2_8_ausgegl]

\begin{minipage}[t]{.49\textwidth}
  \begin{List}[ListType=itemize]
  \ListItem Problem: \\
    Nach Löschen oder Einfügen zu großer Höhenunterschied\\[2ex]
  \ListItem Lösung: \\
    \emph{Rotieren} der Unterbäume
  \end{List}
\end{minipage}
\parbox[t]{.49\textwidth}{\phantom{.}
  \includegraphics[width=.4\textwidth]{fig/avl-problem}
}

\end{Paragraph}


\begin{Paragraph}[Title={Linksrotation}, Label=para7_3_2_9_linksrot]

\begin{center}
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/rotl-1}}
$\Longrightarrow$ 
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/rotl-2}}
\end{center}
\vspace{3ex}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_linksrot]
\begin{code}   
rotl :: AVLTree a-> AVLTree a
rotl (Node _ xt y (Node _ yt x zt)) = 
  mkNode (mkNode xt y yt) x zt
\end{code}
\end{ProgramFragment}

\end{Paragraph}


\begin{Paragraph}[Title={Rechtsrotation}, Label=para7_3_2_10_rechtsrot]
\begin{center}
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/rotr-1}}
$\Rightarrow$ 
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/rotr-2}}
\end{center}
\vspace{3ex}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rechtsrot]
\begin{code}
rotr :: AVLTree a-> AVLTree a
rotr (Node _ (Node _ ut y vt) x rt) = 
  mkNode ut y (mkNode vt x rt)
\end{code}
\end{ProgramFragment}

\end{Paragraph}


\begin{Paragraph}[Title={Ausgeglichenheit sicherstellen},
    Label=para7_3_2_11_ausgegl2]

\begin{List}[ListType=itemize]
\ListItem Fall 1: Äußerer Unterbaum zu hoch 
\ListItem Lösung: Linksrotation
\end{List}

\begin{center}
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/avl-case1}}  
$\Rightarrow$
\raisebox{-3cm}{\includegraphics[height=7cm]{fig/avl-case1-solved}}
\end{center}

\end{Paragraph}


\begin{Paragraph}[Title={Ausgeglichenheit sicherstellen},
    Label=para7_3_2_12_ausgegl3]

\begin{List}[ListType=itemize]
\ListItem Fall 2: Innerer Unterbaum zu hoch oder gleich hoch
\ListItem Reduktion auf vorherigen Fall durch Rechtsrotation des Unterbaumes
\end{List}

\begin{center}
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/avl-case2}}
$\Rightarrow$
\raisebox{-4cm}{\includegraphics[height=8cm]{fig/avl-case1}}  
$\Rightarrow$ \dots{}
\end{center}

\end{Paragraph}


\begin{Paragraph}[Title={Ausgeglichenheit sicherstellen},
    Label=para7_3_2_13_ausgegl4]

\begin{List}[ListType=itemize]
\ListItem Hilfsfunktion: \emph{Balance} eines Baumes
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_ausgegl4]
\begin{code}
bias :: AVLTree a-> Int
bias (Node _ lt _ rt) = ht lt - ht rt  
\end{code}
\end{ProgramFragment}
\ListItem Unterscheidung der Fälle
\begin{List}[ListType=itemize]
\ListItem Fall 1: $\texttt{bias} < 0$
\ListItem Fall 2: $\texttt{bias} \geq 0$
\end{List}
\ListItem Symmetrischer Fall (linker Teilbaum zu hoch)
  \begin{List}[ListType=itemize]
  \ListItem Fall 1: $\texttt{bias} > 0$
  \ListItem Fall 2: $\texttt{bias} \leq 0$
  \end{List}

\newpage

\ListItem \texttt{mkAVL xt y zt}:
  \begin{List}[ListType=itemize]
  \ListItem Voraussetzung: Höhenunterschied \texttt{xt}, \texttt{zt}
  höchstens zwei;
  \ListItem Konstruiert neuen AVL-Baum mit Knoten \texttt{y}.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_ausgegl5]
\begin{code}
mkAVL :: AVLTree a-> a-> AVLTree a-> AVLTree a
mkAVL xt y zt 
  | hx+1< hz && 
    0<= bias zt = rotl (mkNode xt y (rotr zt))
  | hx+1< hz    = rotl (mkNode xt y zt)
  | hz+1< hx && 
    bias xt<= 0 = rotr (mkNode (rotl xt) y zt)
  | hz+1< hx    = rotr (mkNode xt y zt)
  | otherwise   = mkNode xt y zt
    where hx= ht xt; hz= ht zt
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Ordnungserhaltendes Einfügen},
    Label=para7_3_2_14_ord_erhalt_einf]

\begin{List}[ListType=itemize]
\ListItem Erst Knoten einfügen, dann ggf. rotieren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_ord_erhalt_einf]
\begin{code}
insert :: Ord a=> AVLTree a-> a-> AVLTree a
insert Null a = mkNode Null a Null
insert (Node n l a r) b
  | b < a  = mkAVL (insert l b) a r
  | b == a = Node n l a r
  | b > a  = mkAVL l a (insert r b)
\end{code}
\end{ProgramFragment}
\ListItem \texttt{mkAVL} garantiert Ausgeglichenheit.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Löschen}, Label=para7_3_2_15_loeschen]

\begin{List}[ListType=itemize]
\ListItem Erst Knoten löschen, dann ggf. rotieren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_loeschen1]
\begin{code}
remove :: Ord a=> AVLTree a-> a-> AVLTree a
remove Null x = Null
remove (Node h l y r) x
  | x < y  = mkAVL (remove l x) y r
  | x == y = join l r
  | x > y  = mkAVL l y (remove r x)
\end{code}
\end{ProgramFragment}
\ListItem \texttt{mkAVL} garantiert Ausgeglichenheit.

\newpage

\ListItem \texttt{join} fügt zwei Bäume ordnungserhaltend zusammen 
  (s. letzte VL)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_loeschen2]
\begin{code}
join ::  AVLTree a-> AVLTree a-> AVLTree a
join xt Null = xt
join xt yt   = mkAVL xt u nu where
  (u, nu) = splitTree yt
  splitTree :: AVLTree a-> (a, AVLTree a)
  splitTree (Node h Null a t) = (a, t)
  splitTree (Node h lt a rt) =
    (u, mkAVL nu a rt) where
       (u, nu) = splitTree lt
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Menge aufzählen}, Label=para7_3_2_16_menge_aufz]

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_menge_aufz1]
\begin{code}
foldT :: (a-> b-> b-> b)-> b-> AVLTree a-> b    
foldT f e Null = e
foldT f e (Node _ l a r) =
   f a (foldT f e l) (foldT f e r)
\end{code}
\end{ProgramFragment}

\begin{List}[ListType=itemize]
\ListItem Aufzählen der Menge: Inorder-Traversion (via \texttt{fold})
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_menge_aufz2]
\begin{code}
enum :: Ord a=> AVLTree a-> [a]
enum = foldT (\x t1 t2-> t1++ [x]++ t2) []
\end{code}
\end{ProgramFragment}

\ListItem Enthaltensein: \hfill{} \RunFile{slides-7-set.tex}{Testen.}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_menge_aufz3]
\begin{code}
elem :: Ord a=> a-> AVLTree a-> Bool
elem e = foldT (\x b1 b2-> e == x || b1 || b2) False
\end{code}
\end{ProgramFragment}

\end{List}

\end{Paragraph}



\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_avl_testtree]
\begin{code}
testtree :: AVLTree Int
testtree =
 foldl insert empty  [4,5,7,2,1,3,6,8,9] 
\end{code}
\end{ProgramFragment}
\end{comment}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7-set.tex %%%%



\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para7_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Abstrakter Datentyp:
  \emph{Datentyp} plus \emph{Operationen}.
\ListItem Module in Haskell:
  \begin{List}[ListType=itemize]
  \ListItem Module begrenzen Sichtbarkeit
  \ListItem Importieren, ggf. qualifiziert oder nur Teile
  \end{List}
\ListItem Beispiele für ADTs: 
  \begin{List}[ListType=itemize]
  \ListItem Steicher: mehrere Implementationen
  \ListItem Stapel und Schlangen: gleiche Signatur, andere Semantik
  \ListItem Implementation von Schlangen durch zwei Listen
  \ListItem Endliche Mengen: Implementation durch ausgeglichene Bäume
  \end{List}
\end{List}

\end{Summary}


\end{Section} % end Vorlesung 7



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-7.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-8.tex %%%%
%%
%% Praktische Informatik 3 - Eigth lecture
%%


\begin{Section}[Title={Vorlesung vom 09.12.2001: Verzögerte Auswertung
      und unendliche Datenstrukturen}, ShortTitle={Verzögerte
      Auswertung}, Label={chapter8}]


\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
      Label=prgfrag_versteckt_slides8]
\begin{code}
module Slides8 where

import Prelude hiding (cycle,foldl,all)    
import IOExts (trace)
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Introduction}[Title={Inhalt}, Label=para8_0_1_inhalt]
\begin{List}[ListType=itemize]
  \ListItem Verzögerte Auswertung
    \SingleItem{\ldots{} und was wir davon haben.}
  \ListItem Unendliche Datenstrukturen
    \SingleItem{\ldots{} und wozu sie nützlich sind.}
  \ListItem Fallbeispiel: Parserkombinatoren 
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{LazyEVAL}}, Label=section8_1_verz_auswert]
%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Auswertung: \emph{Reduktion} von Gleichungen
  \SingleItem{Strategie: Von außen nach innen; von rechts nach links}
\ListItem Effekt: Parameterübergabe \textit{call by need}, nicht-strikt
  \begin{List}[ListType=itemize]
    \ListItem Beispiel: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_verz_auswert]
\begin{xcode}
silly x y = y; double x = x+ x
\end{xcode}
\end{ProgramFragment}
$
\texttt{silly (double 3) (double 4)} 
\Reduces \texttt{double 4} 
\Reduces \texttt{4+ 4} \Reduces 4
$
  \ListItem Erstes Argument von \texttt{silly} wird nicht ausgewertet.
  \ListItem Zweites Argument von \texttt{silly} wird erst im Funktionsrumpf
    ausgewertet. 
  \end{List}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={Striktheit}, Label=para8_1_1_striktheit]

\begin{List}[ListType=itemize]
\ListItem \Def{def:striktheit}
  in einem Argument \texttt{x}, wenn ein undefinierter Wert für \texttt{x} die
  Funktion undefiniert werden läßt.
\ListItem Beispiele: 
  \begin{List}[ListType=itemize]
  \ListItem \texttt{(+)} strikt in beiden Argumenten.
  \ListItem \texttt{(\&\&)} strikt im ersten,
    nicht-strikt im zweiten.
    $\texttt{False \&\& (1/0 == 1/0)} \Reduces \texttt{False}$
  \ListItem \texttt{silly} nicht-strikt im ersten.
    $\texttt{silly (1/0) 3} \Reduces \texttt{3}$
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Effekte der verzögerten Auswertung},
  Label=para8_1_2_eff_verz_auswert]
\begin{List}[ListType=itemize]
\ListItem Datenorientierte Programme:
  \begin{List}[ListType=itemize]
%  \item Berechung von $\sum_{i=1}^n i^2$
%  \begin{itemize}
%  \item Bilde Liste \texttt{[1..n]}
%  \item Quadriere jedes Element der Liste (\verb!{map (^2)}!)
%  \item Bilde Summe (\texttt{sum :: [Int]-> Int})
%  \end{itemize}
\ListItem Berechung der Summe der Quadrate von $1$ bis $n$:
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_eff_verz_auswert1]
\begin{code}
sqrsum :: Integer-> Integer    
\end{code}
\end{ProgramFragment}
\end{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_eff_verz_auswert2]
\begin{code}
sqrsum n = sum (map (^2) [1..n])
\end{code}
\end{ProgramFragment}
$ $ \pause{} $\Longrightarrow$ Es werden keine Listen von
Zwischenergebnissen erzeugt. \pause{}
   \ListItem Minimum einer Liste durch
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_eff_verz_auswert3]
\begin{code}
msort :: Ord a=> [a]-> [a]
msort xs 
  | length xs <= 1 = xs
  | otherwise = merge (msort front) (msort back) where
    (front, back) = splitAt ((length xs) `div` 2) xs
    merge :: Ord a=> [a]-> [a]-> [a]
    merge [] x = x
    merge y [] = y
    merge (x:xs) (y:ys) 
      | x<= y     = x:(merge xs (y:ys))
      | otherwise = y:(merge (x:xs) ys)

min' :: Ord a=> [a]-> a
\end{code}
\end{ProgramFragment}
\end{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_eff_verz_auswert4]
\begin{code}
min' xs = head (msort xs)
\end{code}
\end{ProgramFragment}
$ $ \pause{} $\Longrightarrow$ Liste wird nicht vollständig sortiert --- binäre Suche.
\end{List}
\pause{}
\ListItem Unendliche Datenstrukturen.
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\DefClass{InfinitDatSTRUCT}},
    Label={section8_2_unendl_datstrukt}] 


\begin{Paragraph}[Title={Unendliche Datenstrukturen: Ströme},
    Label=para8_2_1_unendl_datstrukt]

\begin{List}[ListType=itemize]
\ListItem \emph{Ströme} sind \emph{unendliche Listen}.
\begin{List}[ListType=itemize]
\ListItem Unendliche Liste \texttt{[2,2,2,$\dots{}$]}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_unendl_datstrukt1]
\begin{code}
twos = 2 : twos
\end{code}
\end{ProgramFragment}
\ListItem Die natürlichen Zahlen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_unendl_datstrukt2]
\begin{code}
nat  = [1..]  
\end{code}
\end{ProgramFragment}
\ListItem Bildung von unendlichen Listen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_unendl_datstrukt3]
\begin{code}
cycle :: [a]-> [a]
cycle xs = xs ++ cycle xs    
\end{code}
\end{ProgramFragment}
\end{List}
\ListItem Repräsentation durch endliche, zyklische Datenstruktur
  \begin{List}[ListType=itemize]
  \ListItem   Kopf wird nur einmal ausgewertet. 
  \hfill{} \RunFile{slides-8.tex}{Zeigen.}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgxfrag_unendl_datstrukt4]
\begin{xcode}
cycle (trace "Foo!" "x")
\end{xcode}
\end{ProgramFragment}
  \end{List}
\ListItem Nützlich für Listen mit unbekannter Länge
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Bsp: Berechnung der ersten $n$ Primzahlen},
    Label=para8_2_2_erste_primz]

  \begin{List}[ListType=itemize]
  \ListItem Eratosthenes --- bis wo sieben? 
  \ListItem Lösung: Berechnung \emph{aller} Primzahlen, davon die ersten
    $n$. 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_primz1]
\begin{code}
sieve :: [Integer]-> [Integer]
sieve (p:ps) = 
  p:(sieve (filter (\n-> n `mod` p /= 0) ps)) 
\end{code}
\end{ProgramFragment}
\ListItem \emph{Keine} Rekursionsverankerung
% `)' muß in den LinkText, sonst Leerraum davor! - CK
   (vgl. \Link[LinkText={alte Version)}]{sieve_finite}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_erste_primz2]
\begin{code}
primes :: Int-> [Integer]
primes n = take n (sieve [2..])
\end{code}
\end{ProgramFragment}
\hfill{} \RunFile{slides-8.tex}{Testen.}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Bsp: Fibonacci-Zahlen},
    Label=para8_2_3_fibonacciz]

  \begin{List}[ListType=itemize]
    \ListItem Aus der Kaninchenzucht.
  \ListItem Sollte jeder Informatiker kennen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_fibonacciz1]
\begin{code}
fib :: Integer-> Integer
fib 0 = 1
fib 1 = 1
fib n = fib (n-1)+ fib (n-2)
\end{code}
\end{ProgramFragment}
\ListItem Problem: exponentieller Aufwand.

\newpage

\ListItem Lösung: zuvor berechnete Teilergebnisse wiederverwenden.
\ListItem Sei \texttt{fibs :: [Integer]} Strom aller Fib'zahlen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fibonacciz2]
\begin{xcode}
            fibs  1  1  2  3  5  8 13 21 34 55
       tail fibs  1  2  3  5  8 13 21 34 55
tail (tail fibs)  2  3  5  8 13 21 34 55
\end{xcode}
\end{ProgramFragment}
\ListItem \Declare{ref:fib_stream} \pause{} 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_fibonacciz3]
\begin{code}
fibs :: [Integer]
fibs = 1 : 1 : zipWith (+) fibs (tail fibs)
\end{code}
\end{ProgramFragment}

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_fibonacciz4]
\begin{code}
ffib :: Int-> Integer
ffib = (fibs !!)
\end{code}
\end{ProgramFragment}
\end{comment}

\ListItem Aufwand: linear, da \texttt{fibs} nur einmal ausgewertet wird.
\ListItem \texttt{n}-te Primzahl mit \texttt{fibs !! n} \hfill{}
  \RunFile{slides-8.tex}{Zeigen.}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Fallstudie: Parsierung mit Parserkombinatoren},
    ShortTitle={Parsierung}, Label={section8_3_parsierung}]

\begin{Paragraph}[Title={Fallstudie: Parsierung}, Label=para8_3_1_parsierung]

\begin{List}[ListType=itemize]
\ListItem Gegeben: Grammatik
%\ListItem Gesucht: Funktion, Wörter der Grammatik erkennt - `die' - CK
\ListItem Gesucht: Funktion, die Wörter der Grammatik erkennt
\begin{center}
  \includegraphics[width=\textwidth]{fig/parser}
\end{center}

\newpage

\ListItem \emph{Parser} bildet Eingabe auf Parsierungen ab.
%  \begin{itemize}
%  \item Mehrere Parsierungen möglich.
%  \item Backtracking möglich.
%  \item Durch verzögerte Auswertung dennoch effizient.
%  \end{itemize}
\ListItem Basisparser erkennen Terminalsymbole
\ListItem \emph{Kombinatoren}:
  \begin{List}[ListType=itemize]
  \ListItem Sequenzierung (erst $A$, dann $B$)
  \ListItem Alternierung (entweder $A$ oder $B$)
  \ListItem Abgeleitete Kombinatoren 
    (z.B. Listen $A^*$, nicht-leere Listen $A^+$)
  \end{List}
  $\Longrightarrow$ Nichtterminalsymbole
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Arithmetische Ausdrücke},
    Label=para8_3_2_arith_ausdr]

\begin{List}[ListType=itemize]
\ListItem \Def{expr_grammar_alt}
\begin{verbatim}
Expr   ::= Term + Term 
         | Term - Term 
         | Term
Term   ::= Factor * Factor 
         | Factor / Factor 
         | Factor
Factor ::= Number | (Expr)
Number ::= Digit  | Digit Number 
Digit  ::= 0 |...| 9
\end{verbatim}

\newpage

\ListItem Daraus \emph{abstrakte Syntax}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_arith_ausdr]
\begin{xcode}
data Expr   = Plus  Expr Expr
            | Minus Expr Expr 
            | Times Expr Expr
            | Div   Expr Expr
            | Number Int 
            deriving (Eq, Show)
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Hier Unterscheidung \texttt{Term}, \texttt{Factor},
  \texttt{Number} unnötig.
\end{List}
\end{List}

\end{Paragraph}

%%%% input replacer: Start von slides-8-parser.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_parser]
\begin{code}
module Parser where
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Modellierung in Haskell},
    Label=para8_3_2_1_mod_in_hask]

\begin{List}[ListType=itemize]
\ListItem Welcher \emph{Typ} für Parser?
  \begin{List}[ListType=itemize]
  \ListItem Parser übersetzt \emph{Token} in \emph{abstrakte Syntax}
  \ListItem Parametrisiert über Eingabetyp (Token) \texttt{a} und Ergebnis
    \texttt{b} \pause{}
  \ListItem Müssen mehrdeutige Ergebnisse modellieren \pause{}
  \ListItem Müssen Rest der Eingabe modellieren \pause{}
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_in_hask]
\begin{code}
type Parse a b = [a]-> [(b, [a])]      
\end{code}
\end{ProgramFragment}
\ListItem Beispiel: 
$\verb!parse "3+4*5"! \Reduces \verb![!
\begin{array}[t]{l}
 \verb!(3, "+4*5"),! \\
 \verb!Plus 3 4, "*5"),! \\
 \verb!(Plus 3 (Times 4 5), "")]!
\end{array}$
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Basisparser}, Label=para8_3_2_2_basisparser]
\begin{List}[ListType=itemize]
\ListItem Erkennt nichts:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_basisparser1]
\begin{code}
none :: Parse a b
none = const []
\end{code}
\end{ProgramFragment}
\ListItem Erkennt alles:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_basisparser2]
\begin{code}
suceed :: b-> Parse a b
suceed b inp = [(b, inp)]
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Erkennt einzelne Zeichen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_basisparser3]
\begin{code}
token :: Eq a=> a-> Parse a a
token t = spot (== t)
spot  :: (a-> Bool)-> Parse a a
spot p []     = []
spot p (x:xs) = if p x then [(x, xs)] else []
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Warum nicht \texttt{none}, \texttt{suceed} durch \texttt{spot}?
\end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kombinatoren}, Label=para8_3_2_3_kombinatoren]

\begin{List}[ListType=itemize]
\ListItem Alternierung:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kombinatoren1]
\begin{code}
infixl 3 `alt`
alt :: Parse a b-> Parse a b-> Parse a b
alt p1 p2 i = p1 i ++ p2 i
\end{code}
\end{ProgramFragment}
\ListItem Sequenzierung: 
  \SingleItem{Rest des ersten Parsers als Eingabe für den zweiten}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_kombinatoren2]
\begin{code}
infixl 5 >*>
(>*>) :: Parse a b-> Parse a c-> Parse a (b, c)
(>*>) p1 p2 i = [((y, z), r2) | (y, r1) <- p1 i, 
                                (z, r2) <- p2 r1]
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Eingabe weiterverarbeiten:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kombinatoren3]
\begin{code}
infix 4 `build`
build :: Parse a b-> (b-> c)-> Parse a c
build p f inp = [(f x, r) | (x, r)<- p inp]    
\end{code}
\end{ProgramFragment}

\ListItem Damit z.B. Sequenzierung rechts/links:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kombinatoren4]
\begin{code}
infixl 5 *>, >*
(*>) :: Parse a b-> Parse a c-> Parse a c
(>*) :: Parse a b-> Parse a c-> Parse a b
p1 *> p2 = p1 >*> p2 `build` snd
p1 >* p2 = p1 >*> p2 `build` fst
\end{code}  
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Abgeleitete Kombinatoren},
    Label=para8_3_2_4_abgel_komb]

\begin{List}[ListType=itemize]
\ListItem Listen: \hspace{13ex} $A^{*} ::= A A^{*} \mid \varepsilon$
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_abgel_komb1]
\begin{code}
list :: Parse a b-> Parse a [b]
list p = p >*> list p `build` uncurry (:)
         `alt` suceed []
\end{code}
\end{ProgramFragment}

\ListItem Nicht-leere Listen: \hspace{2ex}  $A^{+} ::= A A^{*}$
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_abgel_komb2]
\begin{code}
some :: Parse a b-> Parse a [b]
some p = p >*> list p `build` uncurry (:)
\end{code}
\end{ProgramFragment}
\ListItem NB. Präzedenzen: 
\texttt{>*>} (5) vor \texttt{build} (4) vor \texttt{alt} (3)

\end{List}


\end{Paragraph}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-8-parser.tex %%%%



\begin{Paragraph}[Title={Einschub: Präzedenzen}, Label=para8_3_3_praezed]

Höchste Priorität: Funktionsapplikation
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgsfrag_praezed]
\begin{scode}
infixr 9  .
infixr 8  ^, ^^, **
infixl 7  *, /, `quot`, `rem`, `div`, `mod`
infixl 6  +, -
infixr 5  :
infix  4  ==, /=, <, <=, >=, >
infixr 3  &&
infixr 2  ||
infixl 1  >>, >>=
infixr 1  =<<
infixr 0  $, $!, `seq` 
\end{scode}
\end{ProgramFragment}

\end{Paragraph}


%%%% input replacer: Start von slides-8-expr1.tex %%%%
%% 
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_expr1]
\begin{code}
module Expr1 where

import Parser

data Expr   = Plus  Expr Expr
            | Minus Expr Expr 
            | Times Expr Expr
            | Div   Expr Expr
            | Number Int 
            deriving (Eq, Show)
\end{code}  
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Der Kern des Parsers}, Label=para8_3_3_1_pars_kern]

\begin{List}[ListType=itemize]
\ListItem \Def{pexpr_alt}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_pars_kern1]
\begin{code}
pExpr :: Parse Char Expr
pExpr = pTerm >* token '+' >*> pTerm 
                          `build` uncurry Plus
        `alt` pTerm >* token '-' >*> pTerm 
                         `build` uncurry Minus
        `alt` pTerm 
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Parsierung von \texttt{Term}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_pars_kern2]
\begin{code}      
pTerm :: Parse Char Expr
pTerm = pFactor >* token '*' >*> pFactor 
                          `build` uncurry Times
        `alt` pFactor >* token '/' >*> pFactor 
                            `build` uncurry Div
        `alt` pFactor 
\end{code}
\end{ProgramFragment}

\ListItem Parsierung von \texttt{Factor}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_pars_kern3]
\begin{code}      
pFactor :: Parse Char Expr
pFactor = 
       some (spot isDigit) `build` Number. read
       `alt` token '(' *> pExpr >* token ')'
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Die Hauptfunktion}, Label=para8_3_3_2_hauptfunkt]

\begin{List}[ListType=itemize]
\ListItem Lexing: Leerzeichen aus der Eingabe entfernen
\ListItem Zu prüfen:  \hfill{} \RunFile{slides-8-expr1.tex}{Testen.}
  \begin{List}[ListType=itemize]
  \ListItem Parsierung braucht Eingabe auf
  \ListItem Keine Mehrdeutigkeit
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_hauptfunkt]
\begin{code}
parse :: String-> Expr
parse i = 
  case filter (null. snd) 
         (pExpr (filter (not.isSpace) i)) of 
     [] -> error "Input does not parse." 
     [(e, _)] -> e
     _  -> error "Ambiguous input."
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-8-expr1.tex %%%%


%%%% input replacer: Start von slides-8-expr2.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_expr2]
\begin{code}
module Expr2 where

import Parser 
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Ein kleiner Fehler},
    Label=para_8_3_3_3_kleiner_fehler]

\begin{List}[ListType=itemize]
\ListItem Mangel: \texttt{3+4+5} ist Syntaxfehler
\ListItem Behebung: leichte Änderung der Grammatik \ldots{}
\begin{verbatim}
Expr   ::= Term + Expr | Term - Expr | Term
Term   ::= Factor * Term | Factor / Term | Factor
Factor ::= Number | (Expr)
Number ::= Digit  | Digit Number
Digit  ::= 0 |...| 9
\end{verbatim}
  \begin{List}[ListType=itemize]
    \ListItem \Link[LinkText={(vergleiche alt)}]{expr_grammar_alt}
  \end{List}

\ListItem Abstrakte Syntax bleibt \ldots{}

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kleiner_fehler1]
\begin{code}
data Expr   = Plus  Expr Expr
            | Minus Expr Expr 
            | Times Expr Expr
            | Div   Expr Expr
            | Number Int 
            deriving (Eq, Show)
\end{code}
\end{ProgramFragment}
\end{comment}

\newpage

\ListItem Entsprechende Änderung des Parsers in \texttt{pExpr}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kleiner_fehler2]
\begin{code}
pExpr :: Parse Char Expr
pExpr = pTerm >* token '+' >*> pExpr
                         `build` uncurry Plus
        `alt` pTerm >* token '-' >*> pExpr 
                        `build` uncurry Minus
        `alt` pTerm 
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem \Link[LinkText={(vergleiche alt)}]{pexpr_alt}
  \end{List}

\newpage

\ListItem \dots{} und in \texttt{pTerm}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_kleiner_fehler3]
\begin{code}
pTerm :: Parse Char Expr
pTerm = pFactor >* token '*' >*> pTerm 
                         `build` uncurry Times
        `alt` pFactor >* token '/' >*> pTerm 
                           `build` uncurry Div         
        `alt` pFactor
\end{code}
\end{ProgramFragment}
\ListItem \texttt{pFactor} und Hauptfunktion bleiben:
  \hfill{} \RunFile{slides-8-expr2.tex}{Testen.}

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_kleiner_fehler4]
\begin{code}
pFactor :: Parse Char Expr
pFactor = 
     some (spot isDigit) `build` Number . read
     `alt` token '(' *> pExpr >* token ')'

parse :: String-> Expr
parse i = 
  case filter (null. snd) 
         (pExpr (filter (not.isSpace) i)) of 
     [] -> error "Input does not parse." 
     [(e, _)] -> e
     _  -> error "Ambiguous input."
\end{code}  
\end{ProgramFragment}
\end{comment}

\end{List}

\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-8-expr2.tex %%%%




\begin{Paragraph}[Title={Zusammenfassung Parserkombinatoren},
    Label=para8_3_4_zusfas_parserkomb]

\begin{List}[ListType=itemize]

\ListItem Systematische Konstruktion des Parsers aus der Grammatik.

\ListItem Abstraktion durch Funktionen höherer Ordnung.

\ListItem Durch verzögerte Auswertung annehmbare Effizienz:

  \begin{List}[ListType=itemize]
  \ListItem Einfache Implementierung (wie oben) skaliert nicht
  \ListItem Grammatik muß eindeutig sein (LL(1) o.ä.)
  \ListItem Gut implementierte Büchereien (wie \textsf{Parsec}) bei
    eindeutiger Grammatik auch für große Eingaben geeignet
  \end{List}

\end{List}

\end{Paragraph}


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para8_0_2_zusammenfassung]
\begin{List}[ListType=itemize]
\ListItem \emph{Verzögerte Auswertung} erlaubt \emph{unendliche
    Datenstrukturen}
  \begin{List}[ListType=itemize]
  \ListItem Zum Beispiel: Ströme (unendliche Listen)
  \end{List}
\ListItem Parserkombinatoren:
  \begin{List}[ListType=itemize]
  \ListItem Systematische Konstruktion von Parsern
  \ListItem Durch verzögerte Auswertung annehmbare Effizienz
  \end{List}
\end{List}

\end{Summary}


\end{Section} % end Vorlesung 8


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-8.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-9.tex %%%%
%%
%% Praktische Informatik 3 - Ninth lecture (Christmas edition)
%%

%\begin{comment}
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_IOExts]
%\begin{code}
%import IOExts (trace)
%-- import Prelude hiding (sequence, mapM, mapM_)
%import Char (toLower)
%import Random (randomRIO)
%main :: IO ()
%main = return ()
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 16.12.2001: Ein/Ausgabe in
      Funktionalen Sprachen}, ShortTitle={Ein/Ausgabe},
    Label={chapter9}]


\begin{Introduction}[Title={Inhalt}, Label=para9_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Wo ist das Problem?
\ListItem Aktionen und der Datentyp \textit{IO}.
\ListItem Vordefinierte Aktionen
\ListItem Beispiel: \texttt{Nim}
\ListItem Aktionen als Werte
\end{List}

{\vfill\hfill {\includegraphics[height=2cm]{img/santa}}}

\clearpage{}

\end{Introduction}


\begin{Section}[Title={Ein- und Ausgabe in \RefClass[funktionalen
Sprachen]{FunctPROGLAN}},
    Label={section9_1_einaus_funktsprach}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem \textbf{Problem:} 
  
  Funktionen mit Seiteneffekten nicht referentiell transparent.
  \begin{List}[ListType=itemize]
  \ListItem z. B. \texttt{readString :: () -> String} ??
  \end{List}
\pause{}

\ListItem \textbf{Lösung:} 

  Seiteneffekte am Typ \DefObject{IO} erkennbar ---  \emph{\DefClass{ACTION}}
  \begin{List}[ListType=itemize]
  \ListItem 
    Aktionen können nur mit Aktionen komponiert werden 
  \ListItem 
    "`einmal \IO, immer \IO"'
  \end{List}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={\ACTION\ als abstrakter Datentyp},
    Label=para9_1_1_akt_abs_dattyp]

\vfill{}
\begin{minipage}[c]{.53\textwidth}
  \Blink{}\includegraphics[width=10cm]{fig/action}
\end{minipage}\pause{}
\begin{minipage}[c]{.45\textwidth}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_akt_abs_dattyp]
\begin{xcode}
type IO t 

(>>=)  :: IO a
          -> (a-> IO b)
          -> IO b

return :: a-> IO a 
\end{xcode}
\end{ProgramFragment}
\end{minipage}\hfill{}
\vfill{}

\end{Paragraph}


\begin{Paragraph}[Title={Vordefinierte \ACTION\ (Prelude)},
    Label=para9_1_2_vordef_akt]

\begin{List}[ListType=itemize]
\ListItem Zeile von \texttt{stdin} lesen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_vordef_akt1]
  \begin{xcode}
    getLine  :: IO String 
  \end{xcode}
\end{ProgramFragment}
  
\ListItem 
  String auf \texttt{stdout} ausgeben:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_vordef_akt2]
  \begin{xcode}
    putStr   :: String-> IO ()
  \end{xcode}
\end{ProgramFragment}

\ListItem 
  String mit Zeilenvorschub ausgeben:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_vordef_akt3]
  \begin{xcode}
    putStrLn :: String-> IO ()
  \end{xcode}
\end{ProgramFragment}
  
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Ein einfaches Beispiel}, Label=para9_1_3_einf_bsp]

\begin{List}[ListType=itemize]
\ListItem \RunFile{slides-9.tex}{Echo:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_bsp1]
\begin{code}
echo :: IO ()
echo = getLine >>= putStrLn >>= \_ -> echo
\end{code}
\end{ProgramFragment}
\ListItem \RunFile{slides-9.tex}{Umgekehrtes Echo:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_bsp2]
\begin{code}
ohce :: IO ()
ohce = getLine >>= putStrLn . reverse >> ohce
\end{code}
\end{ProgramFragment}

\ListItem Vordefinierte Abkürzung:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_einf_bsp3]
\begin{xcode}
(>>) :: IO t-> IO u-> IO u
f >> g = f >>= \_ -> g    
\end{xcode}
\end{ProgramFragment}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Die \texttt{do}-Notation}, Label=para9_1_4_do_nota]

\begin{List}[ListType=itemize]
\ListItem Syntaktischer Zucker für \texttt{\IO}: \\[2ex]
\begin{minipage}[m]{0.45\textwidth}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_do_nota1]
\begin{xcode}
echo = 
  getLine 
  >>= \s-> putStrLn s
  >> echo

\end{xcode}
\end{ProgramFragment}
\end{minipage} 
$\Longleftrightarrow$
\begin{minipage}[m]{0.4\textwidth}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_do_nota2]
\begin{xcode}
echo = 
  do s<- getLine
     putStrLn s
     echo

\end{xcode}
\end{ProgramFragment}
\end{minipage}

\SingleItem{Rechts sind \texttt{>>=}, \texttt{>>} \texttt{implizit}.}

\ListItem Es gilt die Abseitsregel.
  \begin{List}[ListType=itemize]
  \ListItem Einrückung der ersten Anweisung nach \texttt{do} bestimmt Abseits.
  \ListItem Fallunterscheidungen: \texttt{then}-Zweig einrücken.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Module in der Standardbücherei},
  Label=para9_1_5_mod_in_stdlib]

\begin{List}[ListType=itemize]
\ListItem Ein/Ausgabe, Fehlerbehandlung (Modul \texttt{IO})
\ListItem Zufallszahlen (Modul \texttt{Random})
\ListItem Kommandozeile, Umgebungsvariablen (Modul \texttt{System})
\ListItem Zugriff auf das Dateisystem (Modul \texttt{Directory})
\ListItem Zeit (Modul \texttt{Time})
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Ein/Ausgabe mit Dateien},
    Label={section9_2_io_files}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Im Prelude vordefiniert: 
  \begin{List}[ListType=itemize]
  \ListItem Dateien schreiben (überschreiben, anhängen):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_io_files1]
\begin{xcode}
type FilePath =  String
writeFile    ::  FilePath -> String -> IO ()
appendFile   ::  FilePath -> String -> IO ()
\end{xcode}
\end{ProgramFragment}
\ListItem Datei lesen (verzögert):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_io_files2]
\begin{xcode}
readFile     ::  FilePath           -> IO String   
\end{xcode}
\end{ProgramFragment}
\end{List}

\ListItem Mehr Operationen im Modul \texttt{IO} der Standardbücherei 
  \begin{List}[ListType=itemize]
  \ListItem Buffered/Unbuffered, Seeking, \&c.
  \ListItem Operationen auf \texttt{Handle}
  \end{List}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={Beispiel: Zeichen, Worte, Zeilen zählen
  (\texttt{wc})}, Label=para9_2_1_zwz_zaehlen]

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zwz_zaehlen]
\begin{code}    
wc :: String-> IO ()
wc file = 
  do c<- readFile file
     putStrLn (show (length (lines c)) 
                              ++ " lines ")
     putStrLn (show (length (words c)) 
                              ++ " words, and ") 
     putStrLn (show (length c)++ " characters. ")
\end{code}
\end{ProgramFragment}
\pause{} Nicht sehr effizient --- Datei wird im Speicher gehalten.

%\newslide{Ein verbessertes Beispiel}

%\begin{code}    
%wc :: String-> IO ()
%wc file = 
%  do c<- readFile file
%     putStrLn (show (length (lines c)) 
%                              ++ " lines ")
%     putStrLn (show (length (words c)) 
%                              ++ " words, and ") 
%     putStrLn (show (length c)++ " characters. ")
%\end{code}
%\begin{itemize}
%\item Nicht sehr effizient --- Inhalt der Datei wird im Speicher gehalten.
%\end{itemize}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%

% enthält neue Section - CK
%%%% input replacer: Start von slides-9-nim.tex %%%%
\begin{Section}[Title={Nim Revisited}, Label={section9_3_nim_rev}]

\newcommand{\RunNim}[1]{\RunFile{slides-9-nim.tex}{#1}}

\begin{Paragraph}[Title={Noch ein Beispiel: \texttt{Nim} revisited},
    Label=para9_3_1_bsp_nim_rev]

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_nim]
\begin{code}
module Nim where
\end{code}  
\end{ProgramFragment}
\end{comment}

%\newcommand{\RunNim}[1]{\RunFile{slides-9-nim.tex}{#1}}
% nach oben verschoben, da sonst nur innerhalb dieses Paragraphs
% def. - CK

\begin{List}[ListType=itemize]
\ListItem Benutzerschnittstelle von \texttt{Nim}:
\ListItem Am Anfang Anzahl der Hölzchen auswürfeln.
\ListItem Eingabe des Spielers einlesen.
\ListItem Wenn nicht zu gewinnen, aufgeben, ansonsten ziehen.
\ListItem Wenn ein Hölzchen übrig ist, hat Spieler verloren.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Alles Zufall?}, Label=para9_3_2_alles_zuf]

\begin{List}[ListType=itemize]
\ListItem Zufallswerte: Modul \texttt{Random}, Klasse \texttt{Random}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_alles_zuf]
\begin{xcode}
class Random a where
  randomRIO :: (a, a)-> IO a
  randomIO  :: IO a
\end{xcode}
\end{ProgramFragment}
\ListItem Instanzen von \texttt{Random}: Basisdatentypen.
\ListItem \texttt{Random} enthält ferner 
  \begin{List}[ListType=itemize]
  \ListItem Zufallsgeneratoren für Pseudozufallszahlen.
  \ListItem Unendliche Listen von Zufallszahlen.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\texttt{Nim} revisited}, Label=para9_3_3_nim_rev]

\begin{List}[ListType=itemize]
\ListItem Importe und Hilfsfunktionen:

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_nim_rev1]
\begin{code}
import Random (randomRIO)
\end{code}
\end{ProgramFragment}
\ListItem \texttt{wins} liefert $\texttt{Just } n$, wenn Zug $n$ gewinnt;
  ansonsten \texttt{Nothing}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_nim_rev2]
\begin{code}
wins :: Int-> Maybe Int
wins n = 
  if m == 0 then Nothing else Just m where 
     m = (n- 1) `mod` 4
\end{code}
\end{ProgramFragment}

\newpage

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_nim_rev3]
\begin{code}
play :: Int-> IO ()
play n = 
  do putStrLn ("Der Haufen enthält "++ show n ++
               " Hölzchen.")
     if n== 1 then putStrLn "Ich habe gewonnen!" 
       else
         do m<- getInput
            case wins (n-m) of 
              Nothing -> putStrLn "Ich gebe auf."
              Just l  -> do putStrLn ("Ich nehme " 
                                      ++ show l)
                            play (n-(m+l))
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Noch zu implementieren: Benutzereingabe
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_nim_rev4]
\begin{code}
getInput' :: IO Int
getInput' = 
  do putStr "Wieviele nehmen Sie? "
     n <- do s<- getLine 
             return (read s)
     if n<= 0 || n>3 then 
       do putStrLn "Ungültige Eingabe!" 
          getInput'
       else return n    
\end{code}
\end{ProgramFragment}
\ListItem Nicht sehr befriedigend: \RunNim{Abbruch} bei falscher Eingabe.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Fehlerbehandlung}, Label=para9_3_4_fehlerbeh]

\begin{List}[ListType=itemize]
\ListItem Fehler werden durch \texttt{IOError} repräsentiert
\ListItem Fehlerbehandlung durch \emph{Ausnahmen} (ähnlich Java)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fehlerbeh1]
\begin{xcode}
ioError :: IOError -> IO a    -- "throw"
catch   :: IO a-> (IOError-> IO a) -> IO a      
\end{xcode}
\end{ProgramFragment}
\ListItem Nur in Aktionen können Fehler behandelt werden.

\newpage

\ListItem Fangbare Benutzerfehler mit 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fehlerbeh2]
\begin{xcode}
userError::String-> IOError    
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{IOError} kann analysiert werden--- Auszug aus Modul \texttt{IO}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgsfrag_fehlerbeh3]
\begin{scode}
isDoesNotExistError  :: IOError -> Bool
isIllegalOperation   :: IOError -> Bool
isPermissionError    :: IOError -> Bool
isUserError          :: IOError -> Bool 
ioeGetErrorString    :: IOError -> String
ioeGetFileName       :: IOError -> Maybe FilePath
\end{scode}    
\end{ProgramFragment}
\ListItem \texttt{read} mit Ausnahme bei Fehler (statt Programmabbruch):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fehlerbeh4]
\begin{xcode}
readIO :: Read a=> String-> IO a
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Robuste Eingabe}, Label=para9_3_5_rob_eing]

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_eing]
\begin{code}
getInput :: IO Int
getInput = 
  do putStr "Wieviele nehmen Sie? "
     n <- catch (do s<- getLine
                    readIO s)
                (\_ -> do putStrLn "Eingabefehler!" 
                          getInput)
     if n<= 0 || n>3 then 
       do putStrLn "Ungültige Eingabe!" 
          getInput
       else return n
\end{code}
\end{ProgramFragment}

\end{Paragraph}


\begin{Paragraph}[Title={Haupt- und Startfunktion},
    Label=para9_3_6_haupt_start_funkt]

\begin{List}[ListType=itemize]
\ListItem Begrüßung,
\ListItem Anzahl Hölzchen auswürfeln,
\ListItem Spiel \RunNim{starten.}
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_haupt_start_funkt]
\begin{code}
main :: IO ()
main = do putStrLn "\nWillkommen bei Nim!\n"
          n <- randomRIO(5,49)
          play n
\end{code}
\end{ProgramFragment}

\end{Paragraph}

\end{Section}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-9-nim.tex %%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={\ACTION\ als Werte}, Label={section9_3_akt_als_werte}]

%\begin{Paragraph}

\begin{List}[ListType=itemize]
\ListItem Aktionen sind Werte wie alle anderen.
\ListItem Dadurch Definition von Kontrollstrukturen möglich.
\ListItem Besser als jede imperative Sprache.

\newpage

\ListItem Endlosschleife:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_akt_als_werte1]
\begin{code}
forever :: IO a-> IO a
forever a = a >> forever a      
\end{code}
\end{ProgramFragment}
\pause{}
%\item Iteration (feste Anzahl)
%\begin{code}
%forN :: Int-> IO a-> IO ()
%forN n a | n == 0    = return ()
%         | otherwise = a >> forN (n-1) a
%\end{code}
%\newslide{}
\ListItem Iteration (variabel, wie \texttt{for} in Java)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_akt_als_werte2]
\begin{code}
for :: (a, a-> Bool, a-> a)-> (a-> IO ())-> IO ()
for (start, cont, next) cmd = 
  iter start where
    iter s = if cont s then cmd s >> iter (next s) 
             else return ()
\end{code}
\end{ProgramFragment}
\end{List}

%\end{Paragraph}


\begin{Paragraph}[Title={Vordefinierte Kontrollstrukturen (Prelude)},
    Label=para9_3_1_vordef_kontrlstrukt]

\begin{List}[ListType=itemize]
\ListItem Listen von Aktionen sequenzieren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_vordef_kontrlstrukt1]
\begin{xcode}
sequence :: [IO a]-> IO [a]
sequence (c:cs) = do x  <- c
                     xs <- sequence cs
                     return (x:xs)
\end{xcode}
\end{ProgramFragment}
\ListItem Sonderfall: \texttt{[()]} als \texttt{()}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_vordef_kontrlstrukt2]
\begin{xcode}  
sequence_ :: [IO ()]-> IO ()
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Map und Filter für Aktionen},
    Label=para9_3_2_map_filt_akt]

\begin{List}[ListType=itemize]
\ListItem Map für Aktionen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_map_filt_akt1]
\begin{xcode}
mapM :: (a-> IO b)-> [a]-> IO [b]
mapM f = sequence . map f

mapM_ :: (a-> IO ())-> [a]-> IO ()
mapM_ f = sequence_ . map f
\end{xcode}
\end{ProgramFragment}

\ListItem Filter für Aktionen 
  \begin{List}[ListType=itemize]
  \ListItem Importieren mit \texttt{import Monad (filterM)}.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_map_filt_akt2]
\begin{xcode}
filterM :: (a -> IO Bool) -> [a] -> IO [a]
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel}, Label=para9_3_3_map_fil_bsp]

\begin{List}[ListType=itemize]
\ListItem Führt Aktionen zufällig oft aus:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_map_fil_bsp1]
\begin{code}
atmost :: Int-> IO a-> IO [a]
atmost most a = 
  do l<- randomRIO (1, most)
     sequence (replicate l a)
\end{code}
\end{ProgramFragment}

\pause{}
\ListItem Zufälligen String:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_map_fil_bsp2]
\begin{code}
randomStr :: IO String
randomStr = atmost 10 (randomRIO ('a','z'))
\end{code}
\end{ProgramFragment}

\hfill{\RunFile{slides-9.tex}{Zeigen.}}

%\begin{xcode}
%randWord :: IO String
%randWord = 
%  do l<- randomRIO (1, 10)
%     mapM randomRIO (replicate l ('a', 'z'))
%\end{xcode}

\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para9_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Ein/Ausgabe in Haskell durch \emph{Aktionen}
\begin{List}[ListType=itemize]
\ListItem Aktionen  (Typ \texttt{IO a}) sind seiteneffektbehaftete Funktionen
\ListItem Komposition von Aktionen durch 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zusfas_komp]
\begin{xcode}
  (>>=)  :: IO a-> (a-> IO b)-> IO b
  return :: a-> IO a 
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{do}-Notation 
\end{List}
\ListItem Fehlerbehandlung durch Ausnahmen (\texttt{IOError}, \texttt{catch}).
\ListItem Verschiedene Funktionen der Standardbücherei:
  \begin{List}[ListType=itemize]
  \ListItem Prelude: \texttt{getLine, putStr, putStrLn}
  \ListItem Module: \texttt{IO}, \texttt{Random}, 
  \end{List}
% \item Implementation von \texttt{IO}: 
%  \begin{itemize}
%  \item Explizite Modellierung des Systemzustandes.
%  \end{itemize}
\end{List}

\end{Summary}

\end{Section} % end Vorlesung 9


  
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-9.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-10.tex %%%%
%%
%% Praktische Informatik 3 - Tenth lecture (All is quiet on New Year's Day)
%%

\begin{Section}[Title={Vorlesung vom 06.01.2003:
      Grafikprogrammerierung I --- Die Hugs Graphics Library},
    ShortTitle={Grafikprogrammierung I}, Label={chapter10}]


\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_graph]
\begin{code}
module Main where

import GraphicsUtils    
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Introduction}[Title={Inhalt}, Label=para10_0_1]

\begin{List}[ListType=itemize]
  \ListItem Organisatorisches: 
    \begin{List}[ListType=itemize]
      \ListItem \emph{Scheinanmeldung} (bis Semesterende)
    \end{List}
\ListItem Grafikprogrammierung mit HGL (\emph{Hugs Graphics Library})
\ListItem Einführung in die Schnittstelle, kleine Beispiele.
\ListItem Abstraktion über \texttt{HGL}: 
  \begin{List}[ListType=itemize]
  \ListItem Entwurf und Implementation einer kleine Geometriebücherei. 
  \ListItem Kleines Beispiel.
  \end{List}
\ListItem Literatur: Paul Hudak, The Haskell School of Expression. 
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Die Hugs Graphics Library HGL}, Label={section10_1}]

%%%% input replacer: Start von slides-10-hello.tex %%%%
\begin{Paragraph}[Title={Grafik --- erste Schritte.},
    Label=para10_1_1_graf_1st_steps]

\begin{List}[ListType=itemize]
\ListItem 
Das kanonische \RunFile{slides-10-hello.tex}{Beispielprogramm}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_1st_steps]
\begin{code}
module Hello where
import GraphicsUtils
hello :: IO ()
hello = runGraphics (do
  w <- openWindow "Hallo Welt?" (300, 300)
  drawInWindow w (text(100, 100) "Hallo Welt!")
  drawInWindow w (ellipse (100,150) (200,250))
  getKey w
  closeWindow w)
\end{code}
\end{ProgramFragment}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem \texttt{runGraphics :: IO ()-> IO ()} \\
  führt Aktion mit Grafik aus; \pause{}
\ListItem \texttt{openWindow :: Title-> Point-> IO Window} \\
  öffnet Fenster; \pause{}
\ListItem \texttt{drawInWindow :: Window-> Graphic-> IO ()} \\
  zeichnet Grafik in Fenster; \pause{}
\ListItem ADTs \texttt{Window} und \texttt{Graphic}: \\
  Fenster und darin darstellbare Grafiken; \pause{}
\ListItem \texttt{getKey :: Window-> IO Char} wartet auf Taste \pause{}
\ListItem \texttt{closeWindow :: Window-> IO ()} schließt Fenster
\end{List}

\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 

%%%% input replacer: Ende von slides-10-hello.tex %%%%

% enthält para10_1_1 - CK


\begin{Paragraph}[Title={Die Hugs Graphics Library \texttt{HGL}},
    Label=para10_1_2_hugs_lib]

\begin{List}[ListType=itemize]
%% \item Autoren: Alistair Reid (und andere)
\ListItem Kompakte Grafikbücherei 
 für einfache Grafiken und Animationen.
\ListItem Gleiche Schnittstelle zu X11 und Win32 Graphics Library.
\ListItem Bietet:
  \begin{List}[ListType=itemize]
  \ListItem Fenster
  \ListItem verschiedene Zeichenfunktionen
  \ListItem Unterstützung für Animationen
  \end{List}
\ListItem Bietet nicht:
  \begin{List}[ListType=itemize]
  \ListItem Hochleistungsgrafik, 3D-Unterstützung (e.g. OpenGL)
  \ListItem GUI-Funktionalität
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Übersicht \texttt{HGL}},
  Label=para10_1_3_uebersicht]

\begin{List}[ListType=itemize]
\ListItem Grafik
\begin{List}[ListType=itemize]
\ListItem Atomare Grafiken
\ListItem Modifikatoren
\ListItem Attribute
\ListItem Kombination von Grafiken
\ListItem Pinsel, Stifte und Texfarben
\ListItem Farben
\end{List}
\ListItem Fenster
\ListItem Benutzereingaben: \texttt{Events}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Basisdatentypen}, Label=para10_1_4_basis_dattyp]

\begin{List}[ListType=itemize]
\ListItem Winkel (Grad, nicht Bogenmaß)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_basis_dattyp1]
\begin{xcode}
type Angle     = Double
\end{xcode}
\end{ProgramFragment}

\ListItem Dimensionen (Pixel)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_basis_dattyp2]
\begin{xcode}
type Dimension = Int
\end{xcode}
\end{ProgramFragment}

\ListItem Punkte (Ursprung: links oben)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_basis_dattyp3]
\begin{xcode}
type Point     = (Dimension,Dimension)
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


% enthält Paragraph 10_1_4_1 - CK
%%%% input replacer: Start von slides-10-simple1.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_mod_graphutils]
\begin{code}
module Main where

import GraphicsUtils
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Atomare Grafiken}, Label=para10_1_4_1_atom_graf_ellip]

\begin{List}[ListType=itemize]
\ListItem Größte Ellipse (gefüllt) innerhalb des gegeben Rechtecks
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_atom_graf_ellip1]
\begin{xcode}
ellipse :: Point -> Point -> Graphic
\end{xcode}
\end{ProgramFragment}
\ListItem Größte Ellipse (gefüllt) innerhalb des Parallelograms:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_atom_graf_ellip2]
\begin{xcode}
shearEllipse :: Point-> Point-> Point-> Graphic
\end{xcode}
\end{ProgramFragment}
\ListItem Bogenabschnitt einer Ellipse im math. positiven Drehsinn:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_atom_graf_ellip3]
\begin{xcode}
arc:: Point-> Point-> Angle-> Angle-> Graphic
\end{xcode}
\end{ProgramFragment}

\ListItem \RunFile{slides-10-simple1.tex}{Beispiel:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgsfrag_atom_graf_ellip4]
\begin{scode}
  drawInWindow w (arc (40, 50) (340, 250) 45 270)
  drawInWindow w (arc (60, 50) (360, 250) (-45) 90)
\end{scode}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_atom_graf_ellip5]
\begin{code}
main :: IO ()
main = runGraphics $ do    
  w<- openWindow "Arcs" (400, 300)
--  drawInWindow w (shearEllipse (50, 200) (150,10) (450,200)) -- eh?
  drawInWindow w (arc (40, 50) (340, 250) 45 270)
  drawInWindow w (arc (60, 50) (360, 250) (-45) 90)
\end{code} %$
\end{ProgramFragment}
\end{comment}

\end{List}

\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-10-simple1.tex %%%%



\begin{Paragraph}[Title={Atomare Grafiken}, Label=para10_1_5_atom_graf]

\begin{List}[ListType=itemize]
\ListItem Strecke, Streckenzug:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_atom_graf1]
\begin{xcode}  
line     :: Point -> Point -> Graphic
polyline :: [Point] -> Graphic
\end{xcode}
\end{ProgramFragment}

\ListItem  Polygon (gefüllt)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_atom_graf2]
\begin{xcode}
polygon :: [Point] -> Graphic  
\end{xcode}
\end{ProgramFragment}

\ListItem Text:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_atom_graf3]
\begin{xcode}
text :: Point -> String -> Graphic    
\end{xcode}
\end{ProgramFragment}

\ListItem Leere Grafik:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_atom_graf4]
\begin{xcode}
emptyGraphic :: Graphic
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Modifikation von Grafiken},
    Label=para10_1_6_modif_graf]
\begin{List}[ListType=itemize]
\ListItem 
Andere Fonts, Farben, Hintergrundfarben,\ldots{}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_modif_graf1]
\begin{xcode}    
withFont      :: Font   -> Graphic -> Graphic
withTextColor :: RGB    -> Graphic -> Graphic
withBkColor   :: RGB    -> Graphic -> Graphic
withBkMode    :: BkMode -> Graphic -> Graphic
withPen       :: Pen    -> Graphic -> Graphic
withBrush     :: Brush  -> Graphic -> Graphic
withRGB       :: RGB    -> Graphic -> Graphic
withTextAlignment :: Alignment -> Graphic
                               -> Graphic
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem 
Modifikatoren sind kumulativ:
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modif_graf2]
\begin{code}
test1 :: RGB-> Font-> Graphic
test1 red courier = 
\end{code}
\end{ProgramFragment}
\end{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modif_graf3]
\begin{code}
 withFont courier (
   withTextColor red (
     withTextAlignment (Center, Top)
       (text (100, 100) "Hallo?")))
\end{code}
\end{ProgramFragment}
\ListItem Unschön --- Klammerwald.
\ListItem Abhilfe: \texttt{(\$) :: (a-> b)-> a-> b} (rechtsassoziativ)
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modif_graf4]
\begin{code}
test2 :: RGB-> Font-> Graphic
test2 red courier =   
\end{code}
\end{ProgramFragment}
\end{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_modif_graf5]
\begin{code}
 withFont courier $
 withTextColor red $
 withTextAlignment (Center, Top) $
 text (100, 100) "Hallo?"
\end{code} % $ emacs-fontify - CK
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Attribute}, Label=para10_1_7_attrib]

\begin{List}[ListType=itemize]
\ListItem Konkrete Attribute (Implementation sichtbar):
\begin{List}[ListType=itemize]
\ListItem Farben: Rot, Grün, Blau
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib1]
\begin{xcode}
data RGB       = RGB Int Int Int  
\end{xcode}
\end{ProgramFragment}
\ListItem Textausrichtung, Hintergrundmodus
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib2]
\begin{xcode}
type Alignment = (HAlign, VAlign)
data HAlign = Left' | Center   | Right'
data VAlign = Top   | Baseline | Bottom
data BkMode = Opaque | Transparent  
\end{xcode}  
\end{ProgramFragment}
\end{List}

\ListItem Abstrakte Attribute: 
\texttt{Font}, \texttt{Brush} und \texttt{Pen}

\newpage

\ListItem \texttt{Brush} zum Füllen (Polygone, Ellipsen,
  Regionen) 
  \begin{List}[ListType=itemize]
  \ListItem Bestimmt nur durch Farbe
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib3]
\begin{xcode}
mkBrush :: RGB -> (Brush-> Graphic)-> Graphic
\end{xcode}
\end{ProgramFragment}
\ListItem \texttt{Pen} für Linien (Arcs, Linien, Streckenzüge)
  \begin{List}[ListType=itemize]
  \ListItem Bestimmt durch Farbe, Stil, Breite.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib4]
\begin{xcode}
data Style = Solid| Dash| Dot| DashDot| DashDotDot| ...
mkPen :: Style -> Int-> RGB-> (Pen-> Graphic)-> Graphic
\end{xcode}
\end{ProgramFragment}
\ListItem Fonts
  \begin{List}[ListType=itemize]
  \ListItem Punktgröße, Winkel (nicht unter X11), Fett, Kursiv, Name. 
  \ListItem Portabilität beachten --- keine exotischen Kombinationen.
  \ListItem Portable Namen: \texttt{courier}, \texttt{helvetica},
    \texttt{times}. 
    \RunFile{slides-10-simplefont.tex}{Beispiel},
    \ShowFile{slides-10-simplefont.tex}{Quelle}.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib5]
\begin{xcode}
createFont :: Point-> Angle-> Bool-> Bool->
               String-> IO Font     
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem Farben

\begin{List}[ListType=itemize]
\ListItem Nützliche Abkürzung: benannte Farben
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib6]
\begin{xcode}
data Color = Black | Blue | Green | Cyan | Red 
           | Magenta | Yellow | White
\end{xcode}
\end{ProgramFragment}
%          deriving (Eq, Ord, Bounded, Enum, Ix, Show, Read)
\ListItem Dazu Modifikator:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib7]
\begin{xcode}
withColor :: Color-> Graphic-> Graphic    
\end{xcode}
\end{ProgramFragment}
%% \item Benannte Farben sind einfach nur \texttt{Array Color RGB}
\end{List}

\ListItem Kombination von Grafiken

\begin{List}[ListType=itemize]
\ListItem Überlagerung (erste über zweiter):
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_attrib8]
\begin{xcode}
overGraphic  ::  Graphic-> Graphic-> Graphic    
overGraphics :: [Graphic]-> Graphic    
overGraphics = foldr overGraphic emptyGraphic
\end{xcode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Fenster}, Label=para10_1_8_fenster]

\begin{List}[ListType=itemize]
\ListItem Elementare Funktionen: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fenster1]
\begin{xcode}
getGraphic :: Window -> IO Graphic    
setGraphic :: Window -> Graphic-> IO ()
\end{xcode}
\end{ProgramFragment}
\ListItem Abgeleitetete Funktionen:  

  \begin{List}[ListType=itemize]
  \ListItem In Fenster zeichnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fenster2]
\begin{xcode}
drawInWindow :: Window -> Graphic -> IO ()
drawInWindow w g = do
  old <- getGraphic w
  setGraphic w (g `overGraphic` old)    
\end{xcode}
\end{ProgramFragment}
  \ListItem Grafik löschen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_fenster3]
\begin{xcode}
clearWindow :: Window -> IO ()
\end{xcode}
\end{ProgramFragment}
%% clearWindow w = setGraphic w emptyGraphic      
  \end{List}

\end{List}

\end{Paragraph}

% enthält Paragraph 10_1_9: - CK
%%%% input replacer: Start von slides-10-ball.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_balls]
\begin{code}
module Balls where

import GraphicsUtils 

\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Ein einfaches Beispiel},
    Label=para10_1_9_graf_bsp_ball]

\begin{List}[ListType=itemize]
\ListItem Ziel: einen gestreiften Ball zeichen.
\ListItem Algorithmus: als Folge von konzentrischen Ellipsen: 
\begin{List}[ListType=itemize]
\ListItem Start mit Eckpunkten $(x_1, y_1)$ und $(x_2, y_2)$.
\ListItem Verringerung von $x$ um $\Delta_x$, $y$ bleibt gleich.
\ListItem Dabei Farbe verändern.
\end{List}

\begin{center}
\includegraphics[height=5cm]{fig/ball}
\end{center}

\newpage

\ListItem Bälle zeichnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_ball1]
\begin{code}
drawBalls :: Window-> Color->
                        Point-> Point-> IO ()
drawBalls w c (x1, y1) (x2, y2) =    
  if x1 >= x2 then return ()
  else let el = ellipse (x1, y1) (x2, y2)
       in do drawInWindow w (withColor c el)
             drawBalls w (nextColor c) 
                         (x1+deltaX, y1) 
                         (x2-deltaX, y2)    
deltaX :: Int
deltaX = 25
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Farbveränderung, zyklisch:

\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_ball2]
\begin{code}
nextColor :: Color-> Color    
nextColor Red   = Green
nextColor Green = Blue
nextColor Blue  = Red    
\end{code}
\end{ProgramFragment}
%\begin{itemize}
%\item Alternative: sich unendlich wiederholender Liste von Farben \\
%  \texttt{cycle [Red, Green, Blue]} 
%\end{itemize}

%% \newslide{}

\ListItem \RunFile{slides-10-ball.tex}{Hauptprogramm}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_ball3]
\begin{code}
main :: IO ()
main = runGraphics $ do
   w <- openWindow "Balls!" (500,500)
   drawBalls w Blue (25, 25) (485, 485)
   getKey w
   closeWindow w
\end{code}
% $
\end{ProgramFragment}

\end{List}   

\end{Paragraph}   


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 

%%%% input replacer: Ende von slides-10-ball.tex %%%%


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Eine Geometrie-Bücherei}, Label={section10_2_geo_lib}]

%%%% input replacer: Start von slides-10-geometry.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_geo_lib]
\begin{code}
module Geo where

import GraphicsUtils
import List (nub)
import IOExts(trace)

-- to make ghc happy -- delete for hugs
-- fromInt :: Num a=> Int-> a
-- fromInt n = fromInteger (toInteger n)

\end{code}  
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={}, Label=para10_2_1_geo_lib]

\begin{List}[ListType=itemize]
\ListItem Ziel: Abstrakte Repräsentation von geometrischen Figuren
\ListItem Komplementär zu HGL.
\ListItem Unterstützung von
  Translation,
  Skalierung, Rotation
\ListItem Basisfiguren:
 Rechtecke,
 Dreiecke,
 Polygone,
 Kreise
\begin{List}[ListType=itemize]
\ListItem Alle Basisfiguren liegen im Nullpunkt
\end{List}
\ListItem Später: Unterstützung von Kollisionserkennung
\ListItem Keine Mengen, keine grafischen Attribute (Farben)

\newpage

\ListItem Repräsentation durch algebraischen Datentyp

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geo_lib1]
\begin{code}
type Dimension = Int
data Figure = Rect Dimension Dimension
            | Triangle Dimension Angle Dimension
            | Polygon [Point]
            | Circle Dimension       
            | Translate Point Figure
            | Scale Double Figure
            | Rotate Angle Figure
           deriving (Eq, Ord, Show)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Beispiele: 
  \begin{List}[ListType=itemize]
  \ListItem \texttt{Rect 10 20} --- Rechteck mit Höhe 10, Länge 20
  \ListItem \texttt{Rotate (pi/2) (Triangle 10 (pi/3) 10)} \\
    Gleichschenkliges Dreieck, auf dem Kopf stehend.
  \ListItem \texttt{Rotate pi (Circle 20)} --- rotierter Kreis 
  \end{List}

\ListItem Beispiel für abgeleitete Funktionen:
  \begin{List}[ListType=itemize]
  \ListItem Drehung um einen Punkt:
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geo_lib2]
\begin{code}
rotate :: Point-> Angle-> Figure-> Figure
rotate (px, py) w = Translate (px, py) . 
                    Rotate w . 
                    Translate (-px, -py)
\end{code}
\end{ProgramFragment}
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_geo_lib3]
\begin{code}
scaleFrom :: Point-> Double-> Figure-> Figure
scaleFrom (px, py) f = Translate (px, py) . Scale f . 
                                  Translate (-px, -py)
\end{code}  
\end{ProgramFragment}
\end{comment}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Darstellung einer geometrischen Figur},
    Label=para10_2_2_darst_geo_fig]

\begin{List}[ListType=itemize]
  \ListItem Rechtecke und Dreiecke sind spezielle Polygone.
  \ListItem Alles ist ein Polygon oder eine Ellipse.
  \ListItem Nullpunkt $(0, 0)$ des Koordinatensystems links oben.
  \ListItem Rotation, Translation und Skalierung herausrechnen.
  \ListItem \emph{Problem}: Nicht kommutativ!
    \begin{List}[ListType=itemize]
    \ListItem d.h. Reihenfolge relevant.
    \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Mathematische Grundlagen},
    Label=para10_2_3_math_grundl]

\begin{List}[ListType=itemize]
\ListItem Lineare Algebra: Vektorraum $\mathbb{R}^2$
\ListItem Skalierung mit Faktor $F$: Skalarmultiplikation in $\mathbb{R}^2$
\ListItem Translation um Punkt $\vec t$: Addition in $\mathbb{R}^2$
\ListItem Rotation um den Winkel $\omega$: Multiplikation mit der
    \emph{Rotationsmatrix}
    \eqn{M_\omega = \left(
        \begin{array}{cc}
          \cos{\omega} & \sin{\omega} \\
          -\sin{\omega} & \cos{\omega} 
        \end{array}        
      \right)}
\ListItem Es gelten folgende Gleichungen:
    \begin{eqnarray}
      \label{eq:vr1}
      (\vec{p} + \vec{q}) M_ \omega & = & \vec{p} M_\omega + \vec{q}
      M_\omega \\
      \label{eq:vr2}
      r\cdot(\vec{p} + \vec{q}) & = & r \cdot \vec{p} + r\cdot\vec{q}\\
      (r\cdot\vec{p})M_\omega & = & r\cdot(\vec{p} M_\omega)
      \label{eq:vr3}
    \end{eqnarray}
\ListItem Implementation von \texttt{draw}:
  \begin{List}[ListType=itemize]    
  \ListItem (\ref{eq:vr1}) -- (\ref{eq:vr3}) erlauben Reduktion zu einer
    \emph{Normalform} 
  \end{List}
  \eqn{E(\vec{p}) = \vec{t}+ s\cdot(\vec{p}M_\omega)}
  \begin{List}[ListType=itemize]
  \ListItem Zuerst Rotation um Vektor $\omega$ 
  \ListItem Dann Skalierung um Faktor $s$
  \ListItem Dann Translation um Vektor $t$
  \end{List}

\newpage

\ListItem Skalierung eines Punktes $(x, y)$ um den Faktor $f$:
%%  Skalarmultiplikation des Vektorraumes.
  \eqn{(x', y') = (f x, f y)}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_math_grundl1]
\begin{code}
smult :: Double-> Point-> Point
smult f (x, y) 
  | f == 1    = (x, y)
  | otherwise = (round (f* fromInt x),  
                 round (f* fromInt y))
\end{code}
\end{ProgramFragment}
\ListItem Translation eines Punktes $(x, y)$ um einen Vektor $(a, b)$:
%%  Addition des Vektorraumes.
  \eqn{(x', y') = (x+ a, y+ b)}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_math_grundl2]
\begin{code}
add :: Point-> Point-> Point
add (x1, y1) (x2, y2) = (x1+ x2, y1+ y2)      
\end{code}
\end{ProgramFragment}
\ListItem Rotation eines Punktes $(x, y)$ um den
  Winkel $\phi$: 
  $$ (x', y') = (x \cos\phi+ y\sin\phi, -x \sin\phi+y\cos\phi) $$
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_math_grundl3]
\begin{code}
rot :: Angle-> Point-> Point
rot w (x, y) 
  | w == 0    = (x, y)
  | otherwise = (round (x1* cos w+ y1* sin w), 
                 round (-x1 * sin w + y1* cos w)) 
                 where x1 = fromInt x
                       y1 = fromInt y
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Implementation der Zeichenfunktion},
    Label=para10_2_4_impl_zeichfunkt]

\begin{List}[ListType=itemize]
\ListItem Damit \Def{ref:draw}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_impl_zeichfunkt1]
\begin{code} 
draw :: Figure-> Graphic
draw = draw' ((0, 0), 1, 0) where
  draw' :: (Point, Double, Angle)-> 
           Figure-> Graphic
\end{code}
\end{ProgramFragment}
\ListItem Hauptarbeit findet in \texttt{draw'} statt:
  \begin{List}[ListType=itemize]
  \ListItem Translation, Skalierung, Rotation in Argumenten kumulieren
  \ListItem Basisfiguren entsprechend zeichnen
  \end{List}

\newpage

\ListItem Translation, Skalierung, Rotation:
\begin{List}[ListType=itemize]
\ListItem Translation, Skalierung, Rotation aufrechnen
\ListItem Dabei Gleichungen (\ref{eq:vr1}), (\ref{eq:vr2}) beachten
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_impl_zeichfunkt2]
\begin{code}    
  draw' (m, r, phi) (Translate t f) = 
    draw' (add m (smult r (rot phi t)), r, phi) f 
  draw' (m, r, phi) (Scale s f) =
    draw' (m, s+ r, phi) f
  draw' (m, r, phi) (Rotate w f) = 
    draw' (m, r, phi+ w) f
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Basisfiguren zeichnen:

\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_impl_zeichfunkt3]
\begin{code}    
  draw' ((mx, my), r, _) (Circle d) = 
    ellipse (mx- rad, my-rad) (mx+ rad, my+rad) 
    where rad= round (r*fromInt d / 2)
  draw' c (Rect a b) = 
    poly c [(x2, y2), (-x2, y2), 
            (-x2, -y2), (x2, -y2)]
    where x2= a `div` 2; y2= b `div` 2
  draw' c (Triangle l1 a l2) =
    poly c [(0, 0), (0, l1), rot a (0, l2)]
  draw' c (Polygon pts) = poly c pts
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Hilfsfunktion: Polygon zeichnen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_impl_zeichfunkt4]
\begin{code}
  poly :: (Point, Double, Angle)-> 
          [Point]-> Graphic
  poly (m, p, w) = 
    polygon . map (add m. smult p. rot w)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-10-geometry.tex %%%%


%%%% input replacer: Start von slides-10-geoex.tex %%%%
\begin{comment}

ghc -c ShapeEx.lhs -i/home/cxl/opt/src/graphics-2.0.4/lib/x11 -fglasgow-exts -package lang -package concurrent
ghc -o shapeEx ShapeEx.o Shape.o /home/cxl/opt/src/graphics-2.0.4/lib/x11/graphics.a -package util -package concurrent -L/usr/X11R6/lib -lX11


\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_geom]
\begin{code}
module Main where

import Geometry
import GraphicsUtils
import IOExts(trace)
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Ein kleines Beispielprogramm},
    Label=para10_2_5_graf_bsp_prg]

\begin{List}[ListType=itemize]
\ListItem Sequenz von gedrehten, skalierten Figuren. 
\ListItem Im wesentlichen zwei Funktionen:
  \begin{List}[ListType=itemize]
  \ListItem \texttt{drawFigs :: [Figure]-> IO} zeichnet Liste von Figuren in
    wechselnden Farben
  \ListItem \texttt{swirl: Figure-> [Figure]} erzeugt aus Basisfigur
    unendliche Liste von gedrehten, vergrösserten Figuren
  \end{List}
\end{List}  

\newpage

\begin{List}[ListType=itemize]
\ListItem Liste von Figuren zeichnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_prg1]
\begin{code}
drawFigs :: [Figure]-> IO ()
drawFigs f = runGraphics $ do
  w<- openWindow "Here's some figures!" (500, 500)
  drawInWindow w 
    (overGraphics (zipWith withColor 
           (cycle [Blue ..])
           (map (draw. Translate (250, 250)) f))) 
  getKey w
  closeWindow w
\end{code}
% $
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem \texttt{(cycle [Blue ..]} erzeugt unendliche Liste aller Farben.
\ListItem NB: Figuren werden im Fenstermittelpunkt gezeichnet.
\end{List}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Figuren erzeugen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_prg2]
\begin{code}
swirl :: Figure-> [Figure]
swirl = iterate (Scale 1.123. Rotate (pi/7))
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Nutzt \texttt{iterate :: (a-> a)-> a-> [a]} aus dem Prelude: 
\texttt{iterate f x = [x, f x, f f x, f f f x, ...]}
\end{List}

\ListItem \RunFile{slides-10-geoex.tex}{Hauptprogramm:}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_graf_bsp_prg3]
\begin{code}
main = do
  drawFigs (take 20 (swirl (Rect 15 10)))
  drawFigs (take 50 (swirl 
                     (Triangle 6 (pi/3) 6)))
\end{code}
\end{ProgramFragment}

\end{List}

\end{Paragraph}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-10-geoex.tex %%%%


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para10_0_2_zusammenfassung]
\begin{List}[ListType=itemize]
\ListItem Die Hugs Graphics Library (HGL) bietet abstrakte
  und portable Graphikprogrammierung für Hugs.
  \begin{List}[ListType=itemize]
  \ListItem Handbuch und Bezugsquellen auf PI3-Webseite oder
    \texttt{http://www.haskell.org/graphics}
  \end{List}
\ListItem Darauf aufbauend Entwicklung einer kleinen Geometriebücherei.  
\ListItem Nächste Woche: Kollisionserkennung und Animation.
\end{List}

\end{Summary}

\end{Section}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-10.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-11.tex %%%%
%%
%% Praktische Informatik 3 - Eleventh lecture
%%

%\begin{comment}  
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prel_hid]
%\begin{code}
%import Prelude hiding (print)
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 13.01.2003:  Grafikprogrammierung
      II Animation und Interaktion}, ShortTitle={Grafikprogrammierung
      II}, Label={chapter11}]


\begin{Introduction}[Title={Inhalt}, Label=para11_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Erweiterung der Geometriebücherei
\ListItem Bewegte Grafiken: Animationen
\ListItem \textit{Labelled Records}
\ListItem Space --- the final frontier
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% Section 11_1: - CK
%%%% input replacer: Start von slides-11-geometry.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_versteckt_mod_geo]
\begin{code}
module Geometry(
   Figure(..),   -- data Figure = Rect Dimension Dimension
                 --             | Triangle Dimension Angle Dimension
                 --             | Polygon [Point]
                 --             | Circle Dimension       
                 --             | Translate Point Figure
                 --             | Scale Double Figure
                 --             | Rotate Angle Figure
                 --           deriving (Eq, Ord, Show)         
   draw,  --  :: Figure-> Graphic
   Shape, -- abstract
   shape, --     :: Figure -> Shape
   drawShape, -- :: Figure-> Graphic
   contains,  -- :: Shape-> Point-> Bool
   intersect, -- :: Shape-> Shape-> Bool

   polar, -- :: Double-> Angle-> Point
   smult, -- :: Double-> Point-> Point
   add,   -- :: Point-> Point-> Point
   sub,   -- :: Point-> Point-> Point
   len,   -- :: Point-> Double
   rot    -- :: Angle-> Point-> Point
) where 

import GraphicsUtils
import List (nub)

-- to make ghc happy -- delete for hugs
-- fromInt :: Num a=> Int-> a
-- fromInt n = fromInteger (toInteger n)


-- unchanged bits from previous version
type Dimension = Int
data Figure = Rect Dimension Dimension
            | Triangle Dimension Angle Dimension
            | Polygon [Point]
            | Circle Dimension       
            | Translate Point Figure
            | Scale Double Figure
            | Rotate Angle Figure
           deriving (Eq, Ord, Show)

smult :: Double-> Point-> Point
smult f (x, y) 
  | f == 1    = (x, y)
  | otherwise = (round (f* fromInt x),  
                 round (f* fromInt y))

add :: Point-> Point-> Point
add (x1, y1) (x2, y2) = (x1+ x2, y1+ y2)      

sub :: Point-> Point-> Point
sub (x1, y1) (x2, y2) = (x1- x2, y1- y2) 

rot :: Angle-> Point-> Point
rot w (x, y) 
  | w == 0    = (x, y)
  | otherwise = (round (x'* cos w+ y'* sin w), 
                 round (-x' * sin w + y'* cos w)) where 
                x' = fromInt x; y'= fromInt y
\end{code}
\end{ProgramFragment}
\end{comment}


%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Kollisionserkennung}, Label={section11_1_kollisionserk}]

\begin{Paragraph}[Title={}, Label=para11_1_1_kollisionserk]

\begin{List}[ListType=itemize]
\ListItem Ziel: Interaktion der Figuren erkennen 
  \begin{List}[ListType=itemize]
  \ListItem \ldots zum Beispiel Überschneidung
  \ListItem Eine Möglichkeit: \texttt{Region} (aus HGL)
  \ListItem Elementare Regionen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgxfrag_kollisionserk1]
\begin{xcode}
  emptyRegion   :: Region
  polygonRegion :: [Point]-> Region
\end{xcode}
\end{ProgramFragment}
  \ListItem Vereinigung, Schnitt, Subtraktion:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_kollisionserk2]
\begin{xcode}
  unionRegion     :: Region-> Region-> Region
  intersectRegion :: Region-> Region-> Region      
\end{xcode}
\end{ProgramFragment}
    \ListItem aber leider nur Funktion nach \texttt{Graphic}, \emph{nicht}
      \texttt{isEmpty :: Region-> Bool}
      oder \texttt{contains :: Region-> Point-> Bool}
  \end{List}

\newpage

\ListItem Deshalb: eigene Implementation
  \begin{List}[ListType=itemize]
  \ListItem Idee: zur Darstellung wird Normalform berechnet
  \ListItem Normalform auch zur Kollisionserkennung nutzen
  \end{List}
\ListItem Normalform: Elementare Figuren (\texttt{Shape})
  \begin{List}[ListType=itemize]
  \ListItem einfach zu zeichnen
  \ListItem einfache Kollisionserkennung
  \end{List}
\ListItem \emph{Konservative Erweiterung} des \texttt{Geometry}-Moduls
  \begin{List}[ListType=itemize]
  \ListItem Alte Schnittstelle bleibt erhalten.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Erweiterung der Schnittstelle},
    Label=para11_1_2_erw_schnittst]

\begin{List}[ListType=itemize]
\ListItem Abstrakter Typ \texttt{Shape}
\ListItem Konversion von Figur in Form:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_erw_schnittst1]
\begin{xcode}
shape :: Figure-> Shape
\end{xcode}
\end{ProgramFragment}
\ListItem Form zeichnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_erw_schnittst2]
\begin{xcode}
drawShape :: Shape-> Graphic  
\end{xcode}
\end{ProgramFragment}
\ListItem Kollisionserkennung:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_erw_schnittst3]
\begin{xcode}
contains  :: Shape-> Point-> Bool
intersect :: Shape-> Shape-> Bool
\end{xcode}
\end{ProgramFragment}
\ListItem \ShowFile{slides-11-geometry.tex}{Gesamte Schnittstelle}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Implementierung}, Label=para11_1_3_implement]

\begin{List}[ListType=itemize]
\ListItem Ein \texttt{Shape} ist 
\begin{List}[ListType=itemize]
\ListItem ein geschlossenes Polygon oder ein Kreis
\ListItem mit normalisierten Koordinaten.
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_implement1]
\begin{code}
data Shape = Poly [Point]
           | Circ Point Double
           deriving (Eq, Show)
\end{code}
\end{ProgramFragment}
\ListItem Konversion \texttt{Figure} nach \texttt{Shape}:
  \begin{List}[ListType=itemize]
  \ListItem Translation, Rotation, Skalierung herausrechnen;
  \ListItem Adaption von \Link[LinkText=draw]{ref:draw} (Letzte VL)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_implement2]
\begin{code}
shape :: Figure-> Shape
shape = fig' ((0, 0), 1, 0) where
  fig' :: (Point, Double, Angle)-> Figure-> Shape
  fig' (m, r, phi) (Translate t f) = 
    fig' (add m (smult r (rot phi t)), r, phi) f 
  fig' (m, r, phi) (Scale s f) =
    fig' (m, r* s, phi) f
  fig' (m, r, phi) (Rotate w f) = 
    fig' (m, r, phi+ w) f
  fig' c (Rect a b) = 
    poly c [(x2, y2), (-x2, y2),  
            (-x2, -y2), (x2, -y2)] where
      x2= a `div` 2; y2= b `div` 2
  fig' c (Triangle l1 a l2) =
    poly c [(0, 0), (0, l1), rot a (0, l2)]
  fig' c (Polygon pts) = poly c pts
  fig' (m, r, _) (Circle d) = 
    Circ m (r*fromInt d)
  poly :: (Point, Double, Angle)-> [Point]-> Shape
  poly (m, p, w) = Poly. checkclosed. 
                      map (add m. smult p. rot w) where
\end{code}
\end{ProgramFragment}
\ListItem Prüfung ob Polygon geschlossen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_implement3]
\begin{code}    
    checkclosed [] = []
    checkclosed x  = if (head x) == (last x) 
                     then x else x++ [head x]    
\end{code}
\end{ProgramFragment}
\end{List}

\end{List}
\end{Paragraph}


\begin{Paragraph}[Title={Formen zeichnen}, Label=para11_1_4_form_zeich]

\begin{List}[ListType=itemize]

\ListItem Form zeichnen ist trivial:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_form_zeich1]
\begin{code}
drawShape :: Shape-> Graphic
drawShape (Poly pts) = polygon pts
drawShape (Circ (mx, my) r) = 
    ellipse (mx-r', my- r') (mx+ r', my+ r') where 
      r'= round r
\end{code}
\end{ProgramFragment}
\ListItem Alte Funktion \texttt{draw :: Figure-> Graphic}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_form_zeich2]
\begin{code}
draw :: Figure-> Graphic    
draw = drawShape . shape
\end{code}    
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kollisionserkennung}, Label=para11_1_5_koll_erk]

\begin{List}[ListType=itemize]
\ListItem 
Fallunterscheidung:
\begin{List}[ListType=itemize]
\ListItem Polygon und Polygon
  \begin{List}[ListType=itemize]
  \ListItem Kollision, wenn ein Eckpunkt des einen im anderen
  \ListItem \emph{Voraussetzung:} Polygone konvex
  \end{List}
\ListItem Polygon und Kreis
  \begin{List}[ListType=itemize]
  \ListItem Kollision, wenn ein Eckpunkt im Kreis
  \end{List}
\ListItem Kollision Kreis und Kreis
  \begin{List}[ListType=itemize]
  \ListItem Kollision, wenn Entfernung der Mittelpunkte kleiner als Summe
    der Radien
  \end{List}
\end{List}
\ListItem Erster Schritt: Kollision von Formen und \emph{Punkten}.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kollisionserkennung: Punkte und Kreise},
    Label=para11_1_6_punkte_kreise]

\begin{List}[ListType=itemize]
\ListItem Punkt ist innerhalb des Kreises gdw. \\
  Abstand zum Mittelpunkt kleiner (gleich) Radius
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_punkte_kreise1]
\begin{code}  
inC :: Point-> Double-> Point-> Bool
inC (mx, my) r (px, py) = 
    len (px- mx, py- my) <= r
\end{code}
\end{ProgramFragment}
\ListItem Abstand ist \emph{Länge} (Betrag) des Differenzvektors: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_punkte_kreise2]
\begin{code}
len :: Point-> Double
len (x, y)= sqrt (fromInt (x^2+ y^2))
\end{code} 
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kollisionserkennung: Punkte und Polygone},
    Label=para11_1_7_punkte_polyg]

\begin{List}[ListType=itemize]
\ListItem Hilfsmittel: \emph{Orientierung} eines Punktes
\ListItem Orientierung von $C$ bez. Strecke $\overline{AB}$:
\[
\begin{array}[b]{c}
\begin{diagram}[w=1.5em,h=1em,tight]
  & C \\
  & & \luTo(2,2){} \\
  & & & B \\
  A & & \ruTo(3,1)
\end{diagram}  \\[1.5em]
\mbox{\emph{Positive} Orientierung}
\end{array}
\quad\quad\quad
\begin{array}[b]{c}
\begin{diagram}[w=1.5em,h=1em,tight]
  & & & B \\
  & & \ruTo(3,3){} & & \rdTo(1,2){} \\
  &  & & & C \\
  A
\end{diagram} \\[1.5em]
\mbox{\emph{Negative} Orientierung}
\end{array}
\]

\ListItem Punkt ist innerhalb eines Polygons, wenn gleiche Orientierung
  bez. aller Seiten.

\newpage

\ListItem Orientierung ist Vorzeichen der \emph{Determinante:}
\eqn{D_{A,B,C} = (B_y- A_y)(C_x-B_x)- (C_y- B_y)(B_x- A_x)}
\begin{List}[ListType=itemize]
\ListItem Falls $D_{A,B,C}< 0$, dann Orientierung positiv
\ListItem Falls $D_{A,B,C}> 0$, dann Orientierung negativ
\ListItem Falls $D_{A,B,C}= 0$, dann Punkte in einer Flucht
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_punkte_polyg1]
\begin{code}
det :: Point-> (Point, Point)-> Int
det (cx,cy) ((ax,ay), (bx,by)) = 
  signum ((by-ay)*(cx-bx)-(cy-by)*(bx-ax))
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem \texttt{signum} ist Vorzeichen
\end{List}

\newpage

\ListItem Punkt ist innerhalb eines Polygon, wenn gleiche Orientierung
  bez. aller Seiten.
  \begin{List}[ListType=itemize]
  \ListItem \emph{Voraussetzung:} Polygon ist konvex
  \ListItem Punkte \emph{auf} den Seiten werden nicht erkannt
  \ListItem Hilfsmittel: \emph{Orientierung} eines Punktes.
  \end{List}
\ListItem Hilfsfunktion: Liste der Seiten eines Polygons 
  \begin{List}[ListType=itemize]
  \ListItem Voraussetzung: Polygon geschlossen
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_punkte_polyg2]
\begin{code}
sides :: [Point]-> [(Point, Point)]
sides []     = []
sides (x:[]) = []
sides (x:xs) = (x, head xs):(sides xs)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Damit Hauptfunktion: 
  \begin{List}[ListType=itemize]
  \ListItem aus Polygon Liste der Seiten bilden,
  \ListItem Determinante aller Seiten bilden,
  \ListItem doppelte Vorkommen löschen;
  \ListItem Ergebnisliste hat Länge 1 gdw. gleiche Orientierung für
    alle Seiten
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_punkte_polyg3]
\begin{code}
inP :: [Point]-> Point-> Bool
inP ps c = 
  (length. nub. map (det c). sides) ps == 1
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem \texttt{nub :: Eq a=> [a]-> [a]} entfernt doppelte Elemente
  \ListItem Ineffizient --- \texttt{length} berechnet immer Länge der
    ganzen Liste. 
  \end{List}  
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kolliosionserkennung für Punkte},
  Label=para11_1_8_koll_erk_punkte]
\begin{List}[ListType=itemize]
\ListItem Einfache Fallunterscheidung
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_koll_erk_punkte]
\begin{code}
contains :: Shape-> Point-> Bool
contains (Poly pts)= inP pts
contains (Circ c r)= inC c r
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kollisionserkennung von Formen},
    Label=para11_1_9_koll_erk_formen]

\begin{List}[ListType=itemize]
\ListItem Kreise: Distanz Mittelpunkte
  kleiner als Summe Radien
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgfrag_koll_erk_formen1]
\begin{code}
intersect :: Shape-> Shape-> Bool
intersect (Circ (mx1, my1) r1) 
          (Circ (mx2, my2) r2)=
   len (mx2- mx1, my2- my1) <= r1+ r2
\end{code}
\end{ProgramFragment}

\ListItem Polygone: Eckpunkt des einem im anderen
  \begin{List}[ListType=itemize]
  \ListItem Beachtet Randfall nicht: Polygone \emph{berühren} sich.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_koll_erk_formen2]
\begin{code}
intersect (Poly p1) (Poly p2)= 
   any (inP p1) p2 || any (inP p2) p1
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Polygon und Kreis: ein Eckpunkt im Kreis
  \begin{List}[ListType=itemize]
  \ListItem Beachtet Randfall nicht: Kreis schneidet \emph{nur} Seite
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_koll_erk_formen3]
\begin{code}
intersect (Poly p) (Circ c r)= 
   inP p c || any (inC c r) p
intersect (Circ c r) (Poly p)=
   inP p c || any (inC c r) p
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Noch eine Hilfsfunktion},
   Label=para11_1_10_hilfsfunkt]

\begin{List}[ListType=itemize]
\ListItem Polarkoordinaten  $P= (r, \phi)$ 
\ListItem Konversion in kartesische Koordinaten: 
  
  Punkt $(r, 0)$ um Winkel $\phi$ drehen.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_hilfsfunkt]
\begin{code}
polar :: Double-> Angle-> Point
polar r phi = rot phi (round r, 0)
\end{code}  
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\end{Section}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-11-geometry.tex %%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Benutzereingaben}, Label={section11_2_benutz_eingab}]

\begin{Paragraph}[Title={Benutzereingaben: \texttt{Events}},
    Label=para11_2_1_benutz_eingab]

\begin{List}[ListType=itemize]
\ListItem Benutzereingabe: 
  \begin{List}[ListType=itemize]
  \ListItem Tasten
  \ListItem Mausbewegung
  \ListItem Mausknöpfe
  \ListItem Fenster: Größe verändern, schließen 
  \end{List}
\ListItem Grundliegende Funktionen:
  \begin{List}[ListType=itemize]
  \ListItem Letzte Eingabe, auf nächste Eingabe warten:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_benutz_eingab1]
\begin{xcode}
getWindowEvent :: Window -> IO Event      
\end{xcode}
\end{ProgramFragment}
  \ListItem Letzte Eingabe, nicht warten:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_benutz_eingab2]
\begin{xcode}
maybeGetWindowEvent :: Window-> IO (Maybe Event)     
\end{xcode}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem \texttt{Event} ist ein \emph{labelled record}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_benutz_eingab3]
\begin{xcode}
data Event 
  = Char      { char :: Char }
  | Key       { keysym :: Key, isDown :: Bool }
  | Button    { pt :: Point, 
                isLeft, isDown :: Bool }
  | MouseMove { pt :: Point }
  | Resize
  | Closed
 deriving Show 
\end{xcode}
\end{ProgramFragment}

\pause{}

\ListItem Was ist das ?!?

\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Labelled Records}, Label={section11_3_lab_rec}]

\begin{Paragraph}[Title={Probleme mit großen Datentypen},
    Label=para11_3_1_prob_gross_dattyp]

\begin{List}[ListType=itemize]
\ListItem Beispiel Warenverwaltung
  \begin{List}[ListType=itemize]
  \ListItem Ware mit Bezeichung, Stückzahl, Preis (in Cent)
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prob_gross_dattyp1]
\begin{code}
data Item = Item String Int Int
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
  \ListItem Kommt Stückzahl oder Preis zuerst?
\end{List}
\pause{}
\ListItem Beispiel Buch: 
  \begin{List}[ListType=itemize]
  \ListItem Titel, Autor, Verlag, Signatur, Fachgebiet, Stichworte
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prob_gross_dattyp2]
\begin{code}
data Book' = Book' String String String String String
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem Kommt Titel oder Autor zuerst? \\
    Ist Verlag das dritte oder vierte Argument?
  \end{List}

\newpage

\ListItem Reihenfolge der Konstruktoren.
\begin{List}[ListType=itemize]
  \ListItem Typsynonyme (\texttt{type Author= String}) helfen nicht
  \ListItem Neue Typen (\texttt{data Author = Author String}) zu umständlich
  \end{List}
\ListItem Selektion und Update 
  \begin{List}[ListType=itemize]
  \ListItem Für jedes Feld einzeln zu definieren.    
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_prob_gross_dattyp3]
\begin{code}
getSign :: Book'-> String
getSign (Book' _ _ _ s _) = s
setSign :: Book'-> String-> Book'
setSign (Book' t a p _ f) s = Book' t a p s f
\end{code}
\end{ProgramFragment}
  \end{List}
\ListItem Inflexibilität
  \begin{List}[ListType=itemize]
  \ListItem Wenn neues Feld hinzugefügt wird, alle Konstruktoren ändern.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Lösung: \textit{labelled records}},
    Label=para11_3_2_lab_rec]

\begin{List}[ListType=itemize]
\ListItem Algebraischer Datentyp mit \emph{benannten}
  Feldern
\ListItem Beispiel:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_lab_rec1]
\begin{code}
data Book = Book { author :: String,
                   title  :: String,
                   publisher :: String }
\end{code}
\end{ProgramFragment}
\ListItem Konstruktion: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_lab_rec2]
\begin{code}
b = Book 
  {author = "M. Proust",
   title  = "A la recherche du temps perdu",
   publisher = "S. Fischer Verlag"}
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Selektion durch Feldnamen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_lab_rec3]
\begin{xcode}
publisher b --> "S. Fischer Verlag"
author b    --> "M. Proust"
\end{xcode}
\end{ProgramFragment}
\ListItem Update:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_lab_rec4]
\begin{xcode}
b{publisher = "Rowohlt Verlag"}    
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Rein funktional! (\texttt{b} bleibt unverändert)
\end{List}

\ListItem Patternmatching: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_lab_rec5]
\begin{code}
print :: Book-> IO ()
print (Book{author= a, publisher= p, title= t}) =
  putStrLn (a++ " schrieb "++ t ++ " und "++
            p++ " veröffentlichte es.")
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Partielle Konstruktion und Patternmatching möglich:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_lab_rec6]
\begin{code}
b2 = Book {author= "C. Lüth"}   
shortPrint :: Book-> IO ()
shortPrint (Book{title= t, author= a}) = 
  putStrLn (a++ " schrieb "++ t)
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
  \ListItem Guter Stil: nur auf benötigte Felder matchen.
\end{List}

\ListItem Datentyp erweiterbar: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_lab_rec7]
\begin{xcode}
data Book = Book {author :: String,
                  title  :: String,
                  publisher :: String,
                  signature :: String }
\end{xcode}
\end{ProgramFragment}
Programm muß nicht geändert werden (nur neu übersetzt). 
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Zusammenfassung labelled records},
    Label=para11_3_3_zusfas_lab_rec]

\begin{List}[ListType=itemize]
\ListItem Reihenfolge der Konstruktorargumente irrelevant
\ListItem Generierte Selektoren und Update-Funktionen
\ListItem Erhöht Programmlesbarkeit und Flexibilität
\ListItem NB. Feldnamen sind Bezeichner
  \begin{List}[ListType=itemize]
  \ListItem Nicht zwei gleiche Feldnamen im gleichen Modul
  \ListItem Felder nicht wie andere Funktionen benennen
  \end{List}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Animation}, Label={section11_4_anim}]

\begin{Paragraph}[Title={}, Label=para11_4_1_anim]

{\flushright\small{} \emph{Alles dreht sich, alles bewegt sich}\dots\par{}}

\begin{List}[ListType=itemize]
  \ListItem Animation: über der Zeit veränderliche Grafik
  \ListItem Unterstützung von Animationen in HGL:
    \begin{List}[ListType=itemize]
    \ListItem \texttt{Timer} ermöglichen getaktete Darstellung
    \ListItem Gepufferte Darstellung ermöglicht flickerfreie Darstellung
    \end{List}
  \ListItem Öffnen eines Fensters mit Animationsunterstützung: 
    \begin{List}[ListType=itemize]
      \ListItem Initiale Position, Grafikzwischenpuffer, Timer-Takt in Millisekunden
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_anim]
\begin{xcode}
openWindowEx :: Title-> Maybe Point-> Size->  
                RedrawMode-> Maybe Time-> IO Window
data RedrawMode
  = Unbuffered | DoubleBuffered
\end{xcode}
\end{ProgramFragment}
    \end{List}
\end{List}


\end{Paragraph}

% paragraph 11_4_2: - CK
%%%% input replacer: Start von slides-11-simpleanim.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_bouncy]
\begin{code}
module Bouncy where

import GraphicsUtils
import Geometry

\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Eine einfache Animation}, Label=para11_4_2_einf_anim]

\begin{List}[ListType=itemize]
\ListItem Ein springender Ball:
  \begin{List}[ListType=itemize]
  \ListItem Ball hat Position und Geschwindigkeit:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_anim1]
\begin{code}
data Ball = Ball { p :: Point,
                   v :: Point }  
\end{code}
\end{ProgramFragment}
  \ListItem Ball zeichnen: Roter Kreis an Position $\vec p$
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_anim2]
\begin{code}  
drawBall :: Ball-> Graphic
drawBall (Ball {p= p}) =
  withColor Red  
    (draw (Translate p (Circle 20)))
\end{code}
\end{ProgramFragment}
\end{List}

\newpage

  \ListItem Ball bewegen: 
  \begin{List}[ListType=itemize]
  \ListItem Geschwindigkeit $\vec v$ zu Position $\vec p$ addieren
  \ListItem In X-Richtung: modulo Fenstergröße 500
  \ListItem In Y-Richtung: wenn Fensterrand 500 erreicht,
    Geschwindigkeit invertieren
  \ListItem Geschwindigkeit in Y-Richtung nimmt immer um 1 ab
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_anim3]
\begin{code}
move :: Ball-> Ball 
move (Ball {p= (px, py), v= (vx, vy)})=   
  Ball {p= (px', py'), v= (vx, vy')} where
    px' = (px+ vx) `mod` 500
    py0 = py+ vy
    py' = if py0> 500 then 500-(py0-500) else py0 
    vy' = (if py0> 500 then -vy else vy)+ 1
\end{code}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem \RunFile{slides-11-simpleanim.tex}{Hauptprogramm:}
  \begin{List}[ListType=itemize]
  \ListItem Fenster öffnen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_anim4]
\begin{code}
main :: IO ()
main = runGraphics $
  do w<- openWindowEx "Bounce!" 
                      Nothing (500, 500) DoubleBuffered
                      (Just 30)
     loop w (Ball{p=(0, 10), v= (5, 0)}) where 
\end{code}
\end{ProgramFragment}
% $
 \ListItem Hauptschleife: Ball zeichnen, auf Tick warten, Folgeposition
   berechnen 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_einf_anim5]
\begin{code}
       loop :: Window-> Ball-> IO ()
       loop w b = 
         do setGraphic w (drawBall b)
            getWindowTick w          
            loop w (move b)
\end{code}
\end{ProgramFragment}
\end{List}
\end{List}

\end{Paragraph}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-11-simpleanim.tex %%%%


% paragraph 11_4_3: - CK
%%%% input replacer: Start von slides-11-space.tex %%%%
\begin{Paragraph}[Title={Ein Raumflugsimulator}, Label=para11_4_3_raumflug_sim]

\begin{List}[ListType=itemize]
\ListItem Ziel: Simulation eines Raumschiffs
\ListItem Steuerung nur mit Schub und Drehung

\begin{center}
\includegraphics[height=5cm]{fig/space}
\end{center}

\ListItem Geschwindigkeit $\vec v$, Schub $\vec t$
  \begin{List}[ListType=itemize]
  \ListItem Schub operiert immer in Richtung der \emph{Orientierung}
  \end{List}

\end{List}

\newpage

\newcommand{\R}{{\mathbb R}}
\newcommand{\VR}{\R^2}

\begin{List}[ListType=itemize]
\ListItem Zustand des Schiffes zu gegebener Zeit:
  \begin{List}[ListType=itemize]
  \ListItem Position $\vec p \in\VR$
  \ListItem Geschwindigkeit $\vec v \in\VR$
  \ListItem Orientierung $\phi\in\R$ (als Winkel)
  \ListItem Schub $s \in \R$ (als Betrag; $\vec t$ ist $\mathit{polar}(s,
    \phi)$) 
  \ListItem Winkelbeschleunigung $\omega\in\dot\R$
  \end{List}
\ListItem Zustandsübergang:
  \begin{List}[ListType=itemize]
  \ListItem Neue Position: $\vec p'= \vec p+ \vec v'$
  \ListItem Neue Geschwindigkeit: $\vec v'= \vec v+ \mathit{polar}(s, \phi)$
  \ListItem Neue Orientierung: $\phi'= \phi+ \omega$
  \ListItem Winkelbeschleunigung und Schub: durch Benutzerinteraktion
  \end{List}

\newpage

\ListItem Benutzerinteraktion:
  \begin{List}[ListType=itemize]
  \ListItem Konstanten $W$ für Winkelbeschleunigung, $T$ für Schub
  \ListItem Tasten für \textit{Links}, \textit{Rechts}, \textit{Schub}
  \ListItem \textit{Links} drücken: Winkelbeschleunigung auf $+W$ setzen
  \ListItem \textit{Links} loslassen: Winkelbeschleunigung auf $0$
    setzen
  \ListItem \textit{Rechts} drücken: Winkelbeschleunigung auf $-W$ setzen
  \ListItem \textit{Rechts} loslassen: Winkelbeschleunigung auf $0$
    setzen
  \ListItem \textit{Schub} drücken: Schub auf $T$ setzen
  \ListItem \textit{Schub} loslassen: Schub auf $0$ setzen    
  \end{List}
\ListItem Neuer Zustand: \\
  Zustandsübergang plus Benutzerinteraktion.
\end{List}

\newpage

\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim1]
\begin{code}
module Main where

import GraphicsUtils
import Geometry
import Random(Random,randomRIO)
\end{code}
\end{ProgramFragment}
\end{comment}

\begin{List}[ListType=itemize]

\ListItem Modellierung des Gesamtsystems 
  \begin{List}[ListType=itemize]
  \ListItem Für den Anfang nur das Schiff:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim2]
\begin{code}
data State = State { ship  :: Ship }
\end{code}
\end{ProgramFragment}
  \ListItem Schiffszustand:
    \begin{List}[ListType=itemize]
    \ListItem \texttt{Shape} merken für effiziente Kollisionserkennung!
    \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim3]
\begin{code}     
data Ship = 
   Ship { pos    :: Point, 
          shp    :: Shape, 
          vel    :: Point, 
          ornt   :: Double,
          thrust :: Double,
          hAcc   :: Double } 
\end{code}
\end{ProgramFragment}
   \end{List}

\newpage

  \ListItem Globale Konstanten
  \begin{List}[ListType=itemize]
\ListItem Das Raumschiff
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim4]
\begin{code}
spaceShip :: Figure
spaceShip = Polygon [(15, 0), (-15, 10), 
                     (-10, 0), (-15, -10), (15, 0)]
\end{code}
\end{ProgramFragment}
\ListItem Fenstergröße
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim5]
\begin{code}
winSize :: (Int, Int)
winSize = (800, 600)    
\end{code}
\end{ProgramFragment}
\ListItem Schub
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim6]
\begin{code}
aDelta :: Double
aDelta = 1    
\end{code}
\end{ProgramFragment}
\ListItem Maximale Geschwindigkeit
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim7]
\begin{code}
vMax :: Double
vMax = 20    
\end{code}
\end{ProgramFragment}
\ListItem Winkelbeschleunigung
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim8]
\begin{code}
hDelta :: Double
hDelta = 0.3    
\end{code}
\end{ProgramFragment}
\ListItem Der Anfangszustand: Links oben, nach Süden gerichtet
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_raumflug_sim9]
\begin{code}
initialState :: State
initialState = 
  State {ship= setShp $ 
     Ship{pos= (40, 40),
          vel= (0, 0), ornt= -pi/2,
          thrust= 0, hAcc= 0}}
  
\end{code}
\end{ProgramFragment} %$
\end{List}

\newpage

\ListItem Neuen Schiffszustand berechnen
  \begin{List}[ListType=itemize]
  \ListItem Geschwindigkeit so verändern, dass Betrag Obergrenze
    $v_{\textit{max}}$ nie überschreitet.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim10]
\begin{code}
moveShip :: Ship-> Ship
moveShip(Ship {pos= pos0, vel= vel0, 
               hAcc= hAcc, thrust= t, ornt= o}) = 
  setShp $
    Ship{pos= addWinMod pos0 vel0,
         vel= if l> vMax then smult (vMax/l) vel1 
                         else vel1,
         thrust= t, ornt= o+ hAcc, hAcc= hAcc} where
           vel1= add (polar t o) vel0
           l   = len vel1
\end{code}
\end{ProgramFragment} %$
\end{List}

\newpage

\ListItem \texttt{Shape} berechnen und setzen:
  \begin{List}[ListType=itemize]
  \ListItem \texttt{spaceShip} ist das Aussehen des Schiffes (globale
      Konstante) 
    \ListItem Um Orientierung drehen und an Position verschieben.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
      Label=prgfrag_raumflug_sim11]
\begin{code}
setShp :: Ship-> Ship
setShp s = s{shp= shape (Translate (pos s) 
                     (Rotate (ornt s) spaceShip))}
\end{code}
\end{ProgramFragment}
  \ListItem Vektoraddition modulo Fenstergröße:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim12]
\begin{code}
addWinMod :: (Int,Int) -> (Int,Int) -> (Int,Int)
addWinMod (a, b) (c, d)= 
  ((a+ c) `mod` (fst winSize), 
   (b+ d) `mod` (snd winSize))
\end{code}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem Systemzustand darstellen
\begin{List}[ListType=itemize]
\ListItem Gesamter Systemszustand
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim13]
\begin{code}
drawState :: State-> Graphic
drawState s = drawShip (ship s)
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Weitere Objekte mit \texttt{overGraphics} kombinieren
\end{List}
\ListItem Schiff darstellen (Farbänderung bei Beschleunigung)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim14]
\begin{code}
drawShip :: Ship-> Graphic
drawShip s =
   withColor (if thrust s> 0 then Red else Blue) 
             (drawShape (shp s))
\end{code}
\end{ProgramFragment}
  \end{List}

\newpage

\ListItem Neuen Systemzustand berechnen: 
  \begin{List}[ListType=itemize]
  \ListItem Hauptschleife: zeichnen, auf nächsten Tick warten,
    Benutzereingabe lesen, Folgezustand berechnen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim15]
\begin{code}
loop :: Window-> State-> IO ()
loop w s =  
  do setGraphic w (drawState s) 
     getWindowTick w
     evs<- getEvs
     s'<- nextState evs s
     loop w s' where
\end{code}
\end{ProgramFragment}

\newpage

  \ListItem Liste aller Eingaben seit dem letzten Tick:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim16]
\begin{code}
       getEvs :: IO [Event]
       getEvs = do x<- maybeGetWindowEvent w 
                   case x of
                       Nothing -> return []
                       Just e  -> do rest <- getEvs 
                                     return (e : rest)
\end{code}
\end{ProgramFragment}
  \ListItem Folgezustand berechnen: später IO möglich (Zufallszahlen!)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim17]
\begin{code}
nextState :: [Event]-> State-> IO State
nextState evs s =
  return s1{ship= moveShip (ship s1)} where
     s1= foldl (flip procEv) s evs
\end{code}
\end{ProgramFragment}
\end{List}

\newpage

\begin{List}[ListType=itemize]
  \ListItem Eine Eingabe bearbeiten:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim18]
\begin{code}
procEv :: Event-> State-> State
procEv (Key {keysym= k, isDown=down}) 
   | isLeftKey k && down      = sethAcc hDelta
   | isLeftKey k && not down  = sethAcc 0
   | isRightKey k && down     = sethAcc (- hDelta)
   | isRightKey k && not down = sethAcc 0
   | isUpKey k && down        = setThrust aDelta
   | isUpKey k && not down    = setThrust 0
procEv _ = id
sethAcc :: Double->State-> State
sethAcc a s = s{ship= (ship s){hAcc= a}}
setThrust :: Double-> State-> State
setThrust a s = s{ship= (ship s){thrust= a}}        
\end{code}
\end{ProgramFragment}
\end{List}

\ListItem Das \RunFile{slides-11-space.tex}{Hauptprogramm}

\begin{List}[ListType=itemize]
\ListItem Fenster öffnen, Schleife mit Anfangszustand starten
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_raumflug_sim19]
\begin{code}
main :: IO ()
main = runGraphics $
  do w<- openWindowEx "Space --- The Final Frontier" 
                      Nothing winSize DoubleBuffered
                      (Just 30)
     loop w initialState
     closeWindow w
\end{code}
\end{ProgramFragment} %$

\end{List}

\end{List}


\end{Paragraph}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-11-space.tex %%%%



\end{Section} % end Section Animation


%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para11_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Erweiterung der Geometriebücherei 
  \begin{List}[ListType=itemize]
  \ListItem Der Datentyp \texttt{Shape} und Kollisionserkennung 
  \end{List}
\ListItem Neues Haskell-Konstrukt: \emph{labelled records}
  \begin{List}[ListType=itemize]
    \ListItem Reihenfolge der Konstruktorargumente irrelevant
    \ListItem Generierte Selektoren und Update-Funktionen
    \ListItem Erhöht Programmlesbarkeit und Flexibilität
  \end{List}
\ListItem Animation:
  \begin{List}[ListType=itemize]
  \ListItem Unterstützung in \texttt{HGL} durch Timer und Zeichenpuffer
  \ListItem Implementation eines einfachen Raumschiffsimulators
  \end{List}
\end{List}


\end{Summary}

\end{Section} % end Vorlesung 11


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-11.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-12.tex %%%%
%%
%% Praktische Informatik 3 - Twelfth lecture
%%

%\begin{comment}  
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
%    Label=prgfrag_versteckt_slides12]
%\begin{code}
%import Prelude hiding (all,foldl,length)
%import Monad (when)
%import List(intersperse)
%import IOExts(trace)
%import Memo (memo)
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 20.01.2003: Effiziente
      Funktionale Programme}, ShortTitle={Effizienzaspekte},
    Label={chapter12}]


\begin{Introduction}[Title={Inhalt}, Label=para12_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Zeitbedarf: Endrekursion --- \texttt{while} in Haskell
\ListItem Platzbedarf: Speicherlecks
\ListItem Verschiedene andere Performancefallen:
  \begin{List}[ListType=itemize]
  \ListItem Überladene Funktionen
  \ListItem Listen
  \ListItem Referenzen
  \end{List}

\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Endrekursion}, Label={section12_1_endrek}]

\begin{Paragraph}[Title={}, Label=para12_1_1_endrek]

Eine Funktion ist \emph{endrekursiv}, wenn kein rekursiver
Aufruf in einem geschachtelten Ausdruck steht.

\begin{List}[ListType=itemize]
\ListItem D.h. darüber nur \texttt{if}, \texttt{case}, guards oder
  Fallunterscheidungen.
\ListItem Entspricht \texttt{goto} oder \texttt{while} in imperativen
  Sprachen.
\ListItem Wird in Schleifen übersetzt.
\ListItem Nicht-endrekursive Funktionen brauchen Platz auf dem Stack.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiele}, Label=para12_1_2_endrek_bsp]

\begin{List}[ListType=itemize]
\ListItem \texttt{fac'} \emph{nicht} endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_bsp1]
\begin{code}
fac' :: Int-> Int
fac' n  = if n == 0 then 1 else n * fac' (n-1) 
\end{code}
\end{ProgramFragment}
\ListItem \texttt{fac} endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_bsp2]
\begin{code}  
fac :: Int-> Int
fac n     = fac0 n 1 where
  fac0 n acc = if n == 0 then acc 
               else fac0 (n-1) (n*acc)
\end{code}
\end{ProgramFragment}

\ListItem \texttt{fac'} verbraucht Stackplatz, \texttt{fac} nicht.
  \RunFile{slides-12.tex}{(Zeigen)}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Liste umdrehen, \emph{nicht} endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_bsp3]
\begin{code}
rev' :: [a]-> [a]
rev' []     = []
rev' (x:xs) = rev' xs ++ [x]    
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem Hängt auch noch hinten an --- $O(n^2)$!\pause{}
  \end{List}
\ListItem Liste umdrehen, endrekursiv und $O(n)$:
\hfill{} \RunFile{slides-12.tex}{(Zeigen)}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_bsp4]
\begin{code}
rev :: [a]-> [a]
rev xs = rev0 xs [] where
    rev0 []     ys = ys
    rev0 (x:xs) ys = rev0 xs (x:ys)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Überführung in Endrekursion},
    Label=para12_1_3_ueberfuehr_endrek]

\begin{List}[ListType=itemize]
\ListItem 
Gegeben eine Funktion $f'$
\texttt{$f'$: $S$-> $T$} \\
\texttt{$f'$ x = if $B$ x 
  \begin{tabular}[t]{l}
  then $H$ x \\
  else $\phi$ ($f'$ ($K$ x)) ($E$ x)
  \end{tabular}}
\begin{List}[ListType=itemize]
\ListItem Mit \texttt{$K$:$S$-> $S$}, \texttt{$\phi$:$T$-> $T$-> $T$}, 
\texttt{$E$:$S$-> $T$}, \texttt{$H$:$S$-> $T$}.
\end{List}

\ListItem 
Sei $\phi$ assoziativ ist, \texttt{$e$:$T$} neutrales Element

\ListItem Dann ist die endrekursive Form: \\
\texttt{$f$: $S$-> $T$} \\
\texttt{$f$ x = $g$ x $e$ where \\
\begin{tabular}[t]{ll}
$g$ x y = if $B$ x & then $\phi$ ($H$ x) y  \\
          & else $g$ ($K$ x) ($\phi$ ($E$ x) y)
\end{tabular}}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Beispiel}, Label=para12_1_4_ueberfuehr_bsp]

\begin{List}[ListType=itemize]

\ListItem Länge einer Liste
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_ueberfuehr_bsp1]
\begin{code}
length' :: [a]-> Int
length' xs = if (null xs) then 0 
             else 1+ length' (tail xs)
\end{code}
\end{ProgramFragment}
\ListItem Zuordnung der Variablen:
\eqn{\begin{array}{rcl}
    K(x) & \mapsto{} & \texttt{tail} \\
    E(x) & \mapsto{} & 1 \\
    \phi(x, y) & \mapsto{} & x+ y \\
  \end{array}\quad\quad\quad{}
  \begin{array}{rcl}
    B(x) & \mapsto{} & \texttt{null} x  \\
    H(x) & \mapsto{} & 0 \\
    e    & \mapsto{} & 0 
\end{array}}

\ListItem Es gilt: $\phi(x, e)= x+ 0= x$ ($0$ neutrales Element)

\newpage

\ListItem Damit ergibt sich endrekursive Variante:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_ueberfuehr_bsp2]
\begin{code}
length :: [a]-> Int
length xs = len xs 0 where
  len xs y = if (null xs) then 0 -- was: 0+ 0
             else len (tail xs) (1+ y)
\end{code}
\end{ProgramFragment}
\ListItem Allgemeines \emph{Muster}:
  \begin{List}[ListType=itemize]
  \ListItem Monoid $(\phi,e)$: $\phi$ assoziativ, $e$ neutrales Element.
  \ListItem Zustäzlicher Parameter \emph{akkumuliert} Resultat.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Endrekursive \ACTION}, Label=para12_1_5_endrek_akt]

Eine Aktion ist endrekursiv, wenn nach dem rekursiven Aufruf keine
weiteren Aktionen folgen.

\begin{List}[ListType=itemize]
\ListItem Nicht endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_akt1]
\begin{code}
getLines' :: IO String
getLines' = do str<- getLine 
               if null str then return "" 
                  else  do rest<- getLines'
                           return (str++ rest)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_endrek_akt2]
\begin{code}
getLines :: IO String
getLines = getit "" where
   getit res = do str<- getLine 
                  if null str then return res
                     else getit (res++ str)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Fortgeschrittene Endrekursion},
    Label=para12_1_6_fortgesch_enfrek]

\begin{List}[ListType=itemize]
\ListItem Akkumulation von Ergebniswerten durch \emph{closures}
  \begin{List}[ListType=itemize]
  \ListItem closure: partiell instantiierte Funktion
  \end{List}
\ListItem Beispiel: die Klasse \DefObject{SHOW}
  \begin{List}[ListType=itemize]
  \ListItem Nur \texttt{show} wäre zu langsam ($O(n^2)$):
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_fortgesch_enfrek1]
\begin{xcode}
class Show a where
   show :: a-> String    
\end{xcode}
\end{ProgramFragment}
\pause{}
  \ListItem Deshalb zusätzlich
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgxfrag_fortgesch_enfrek2]
\begin{xcode}
   showsPrec :: Int-> a-> String-> String
   show x    = showsPrec 0 x "" 
\end{xcode}
\end{ProgramFragment}
  \ListItem String wird erst aufgebaut, wenn er ausgewertet wird ($O(n)$).

\newpage

  \ListItem Damit zum Beispiel:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_fortgesch_enfrek3]
\begin{code}
data Set a = Set [a] -- Mengen als Listen
\end{code}
\end{ProgramFragment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_fortgesch_enfrek4]
\begin{xcode}
instance Show a=> Show (Set a) where
  showsPrec i (Set elems) = 
      \r-> r++ "{" ++ concat (intersperse ", " 
                              (map show elems)) ++ "}"
\end{xcode}
\end{ProgramFragment}
\pause\ListItem Nicht perfekt--- besser: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_fortgesch_enfrek5]
\begin{code}
instance Show a=> Show (Set a) where    
  showsPrec i (Set elems) = showElems elems where
    showElems []     = ("{}" ++)
    showElems (x:xs) = ('{' :) . shows x . showl xs
       where showl []     = ('}' :)
             showl (x:xs) = (',' :) . shows x . showl xs
\end{code}
\end{ProgramFragment}
\end{List}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Speicherlecks}, ShortTitle={Speichereffizienz},
  Label={section12_2_speicherlecks}]

\begin{Paragraph}[Title={}, Label=para12_2_1_speicherlecks]

\begin{List}[ListType=itemize]
\ListItem \emph{Garbage collection} gibt unbenutzten Speicher wieder frei.
  \begin{List}[ListType=itemize]
  \ListItem Nicht mehr benutzt: Bezeichner nicht mehr im Scope.
  \end{List}
\ListItem Eine Funktion hat ein \emph{Speicherleck}, wenn Speicher belegt
  wird, der nicht mehr benötigt wird.
\ListItem Beispiel: \texttt{getLines}, \texttt{fac}
  \begin{List}[ListType=itemize]
  \ListItem Zwischenergebnisse werden nicht auswertet. 
    \RunFile{slides-12-spaceleak.hs}{(Zeigen.)}
  \ListItem Insbesondere ärgerlich bei nicht-terminierenden Funktionen.
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Striktheit}, Label=para12_2_2_striktheit]

\begin{List}[ListType=itemize]
\ListItem \Link[LinkText={Strikte Argumente}]{def:striktheit} erlauben
  Auswertung \emph{vor} Aufruf 
  \begin{List}[ListType=itemize]
  \ListItem Dadurch konstanter Platz bei Endrekursion.
  \end{List}
\ListItem Striktheit durch erzwungene Auswertung: 
  \begin{List}[ListType=itemize]
  \ListItem   \texttt{seq :: a-> b-> b} wertet erstes Argument aus.
  \ListItem \texttt{(\$!) :: (a-> b)-> a-> b} strikte Funktionsanwendung
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_striktheit1]
\begin{xcode}
f $! x = x `seq` f x    
\end{xcode}
\end{ProgramFragment}
  \end{List}
\ListItem Fakultät in konstantem Platzaufwand 
  \RunFile{slides-12-spaceleak.hs}{(zeigen)}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_striktheit2]
\begin{code}
fac2 n = fac0 n 1 where 
  fac0 n acc = seq acc $ if n == 0 then acc 
                         else fac0 (n-1) (n*acc)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\texttt{foldr} vs. \texttt{foldl}},
  Label=para12_2_3_foldrl]

\begin{List}[ListType=itemize]
\ListItem \texttt{foldr} ist nicht endrekursiv.
\ListItem \texttt{foldl} ist endrekursiv:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_foldrl1]
\begin{code}
foldl :: (a -> b -> a) -> a -> [b] -> a
foldl f z []      = z
foldl f z (x:xs)  = foldl f (f z x) xs   
\end{code}
\end{ProgramFragment}
\ListItem \texttt{foldl' :: (a-> b-> a)-> a-> [b]-> a} ist endrekursiv und
  strikt.

\newpage

\ListItem \texttt{foldl} endrekursiv, aber traversiert immer die \emph{ganze}
  Liste.
\ListItem \texttt{foldl'} konstanter Platzaufwand, aber traversiert immer
  die \emph{ganze} Liste.
\ListItem Wann welches \texttt{fold}?
  \begin{List}[ListType=itemize]
  \ListItem Strikte Funktionen mit \texttt{foldl'} falten.
  \ListItem Wenn nicht die ganze Liste benötigt wird, \texttt{foldr}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_foldrl2]
\begin{code}
all :: (a-> Bool)-> [a]-> Bool
all p = foldr ((&&) . p) True
\end{code}
\end{ProgramFragment}
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Gemeinsame Teilausdrücke},
    Label=para12_2_4_gemeins_teilausdr]

\begin{List}[ListType=itemize]
\ListItem Ausdrücke werden intern durch \emph{Termgraphen} dargestellt. 
\ListItem Argument wird nie mehr als einmal ausgewertet:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_gemeins_teilausdr1]
\begin{code}  
f :: Int-> Int
f x = (x+ 1)* (x+ 1)
\end{code}
\end{ProgramFragment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_gemeins_teilausdr2]
\begin{xcode}
f (trace "Foo" (3+2))
x + x where x = (trace "Bar" (3+2))
\end{xcode}
\end{ProgramFragment}
\ListItem \textit{Sharing} von Teilausdrücken (wie \texttt{x})
  \begin{List}[ListType=itemize]
  \ListItem Explizit mit \texttt{where} oder \texttt{let}
  \ListItem Implizit (\texttt{ghc})
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Memoisation}, Label=para12_2_5_memois]

\begin{List}[ListType=itemize]
\ListItem \emph{Kleine Änderung} der \Link[LinkText={Fibonacci-Zahlen
    als Strom:}]{ref:fib_stream}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_memois1]
\begin{code}
fibsFn :: () -> [Integer]
fibsFn () = 1 : 1 : zipWith (+) (fibsFn ()) 
                                (tail (fibsFn ()))    
\end{code}
\end{ProgramFragment}
\ListItem \emph{Große Wirkung:} \RunFile{slides-12.tex}{Exponentiell in
    Space/Time.} Warum?   
\pause{}
\begin{List}[ListType=itemize]
\ListItem Jeder Aufruf von \texttt{fibsFn()} bewirkt erneute Berechnung.
%% \item Die Abhilfe: \emph{Memoisation} 
\end{List}
\ListItem \emph{Memoisation}: Bereits berechnete Ergebnisse speichern.
\ListItem In Hugs: Aus dem Modul \texttt{Memo}: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_memois2]
\begin{xcode}
  memo :: (a-> b)-> a-> b    
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem Damit ist alles wieder \RunFile{slides-12.tex}{gut} (oder?)
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_memois3]
\begin{code}
fibsFn' :: () -> [Integer]
fibsFn' = memo (\()-> 1 : 1 : zipWith (+)  
                              (fibsFn' ()) 
                              (tail (fibsFn' ())))
\end{code}
\end{ProgramFragment}
\end{List}

%\newslide{Continuations}
%\begin{itemize}
%\item \emph{Continuation}: Funktion, die Ergebnis weiterverarbeit. 
%  \begin{itemize}
%  \item Funktion gibt nicht Ergebnis zurück, sondern springt woanders hin.
%  \item \texttt{GOTO} für Haskell. 
%  \end{itemize}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Verschiedene Performancefallen},
    Label={section12_3_perf_fallen}]

\begin{Paragraph}[Title={Überladene Funktionen sind langsam.},
    Label=para12_3_1_perf_fallen]

\begin{List}[ListType=itemize]
\ListItem \TYPClass\ sind elegant aber \emph{langsam}.
  \begin{List}[ListType=itemize]
  \ListItem Implementierung von Typklassen: \emph{dictionaries} von
    Klassenfunktionen.
  \ListItem Überladung wird zur \emph{Laufzeit} aufgelöst.
  \end{List}
\ListItem Bei kritischen Funktionen durch Angabe der Signatur
  \emph{Spezialisierung erzwingen}.
\ListItem NB: \emph{Zahlen} (numerische Literale) sind in Haskell \emph{überladen}!
  \begin{List}[ListType=itemize]
  \ListItem Bsp: \texttt{facs} hat den Typ \texttt{Num a=> a-> a}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_perf_fallen]
\begin{code}
facs n = if n == 0 then 1 else n* facs (n-1)  
\end{code}
\end{ProgramFragment}
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Listen als Performance-Falle},
    Label=para12_3_2_listen_perf_fallen]

\begin{List}[ListType=itemize]
\ListItem Listen sind \emph{keine} Felder.
\ListItem Listen: 
  \begin{List}[ListType=itemize]
  \ListItem Beliebig lang
  \ListItem Zugriff auf $n$-tes Element in linearer Zeit.
  \ListItem Abstrakt: frei erzeugter Datentyp aus Kopf und Rest
  \end{List}

\ListItem Felder:
  \begin{List}[ListType=itemize]
  \ListItem Feste Länge
  \ListItem Zugriff auf $n$-tes Element in konstanter Zeit.
  \ListItem Abstrakt: Abbildung Index auf Daten
  \end{List}

\newpage

\ListItem Modul \texttt{Array} aus der Standardbücherei
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_listen_perf_fallen]
\begin{xcode}
data Ix a=> Array a b  -- abstract
array     :: (Ix a) => (a,a) -> [(a,b)] 
                                    -> Array a b
listArray :: (Ix a) => (a,a) -> [b] -> Array a b
(!)       :: (Ix a) => Array a b -> a -> b
(//)      :: (Ix a) => Array a b -> [(a,b)] 
                                    -> Array a b
\end{xcode}
\end{ProgramFragment}
\ListItem Als Indexbereich geeignete Typen (Klasse \texttt{Ix}): 
  \texttt{Int}, \texttt{Integer}, \texttt{Char}, \texttt{Bool}, Tupel
  davon, Aufzählungstypen.
\ListItem In Hugs/GHC vordefiniert (als ``primitiver'' Datentyp)
\end{List}

\end{Paragraph}


% paragraph 12_3_3: - CK
%%%% input replacer: Start von slides-12-array.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_mod_funct_arr]
\begin{code}
module FunctionalArrays where
  
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Funktionale Arrays}, Label=para12_3_2_funkt_arr]

\begin{List}[ListType=itemize]
\ListItem Idee: Arrays implementiert durch binäre Bäume
\ListItem Pfad im Index kodiert: 0 --- links, 1 --- rechts:
  \begin{center}
    \includegraphics{fig/array-tree}
  \end{center}

\newpage

\ListItem Schnittstelle:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_arr1]
\begin{code}
module FArray(
  Array, -- abstract
  (!),  -- :: Array a-> Int-> Maybe a,
  upd,  -- :: Array a-> Int-> a-> Array a,
  remv, -- :: Array a-> Int-> Array
  ) where
\end{code}
\end{ProgramFragment}

\ListItem Der Basisdatentyp ist ein binärer Baum:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_arr2]
\begin{code}
data Tree a = Leaf | Node a (Tree a) (Tree a)
               deriving (Show, Read)
type Array a = Tree a
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem \emph{Invariante:} zusammenhängende Indizes.
\end{List}

\newpage

\ListItem Lookup: Baumtraversion
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_arr3]
\begin{code}
(!) :: Tree a -> Int-> Maybe a
Leaf ! _           = Nothing
(Node v t1 t2) ! k 
   | k == 1         = Just v
   | k `mod` 2 == 0 = t1 ! (k `div` 2)
   | otherwise      = t2 ! (k `div` 2)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Update: ähnlich. 
\begin{List}[ListType=itemize]
\ListItem Feld kann erweitert werden, aber immer nur um ein Element!
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_arr4]
\begin{code}
upd :: Tree a -> Int-> a-> Tree a
upd Leaf k v = 
  if k== 1 then (Node v Leaf Leaf)
  else error "Tree.upd: illegal index"
upd (Node w t1 t2) k v 
  | k == 1    = Node v t1 t2
  | k `mod` 2 == 0 
              = Node w (upd t1 (k `div` 2) v) t2
  | otherwise = Node w t1 (upd t2 (k `div` 2) v)  
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Remove: darf nur für oberstes Element angewandt werden.
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_funkt_arr5]
\begin{code}
remv :: Tree a-> Int-> Tree a
remv Leaf _  = Leaf
remv (Node w t1 t2) k
  | k == 1    = Leaf
  | k `mod` 2 == 0 
              = Node w (remv t1 (k `div` 2)) t2
  | otherwise = Node w t1 (remv t2 (k `div` 2))  
\end{code}
\end{ProgramFragment}
\ListItem Mangel: \emph{Invariante} wird bei \texttt{remv} \emph{nicht geprüft}. 
\ListItem Einfache Abhilfe:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_funkt_arr6]
\begin{xcode}
type Array a = (Tree a, Int)    
\end{xcode}
\end{ProgramFragment}

\end{List}

\end{Paragraph}
%%%% input replacer: Ende von slides-12-array.tex %%%%



\begin{Paragraph}[Title={Zustände und Referenzen},
    Label=para12_3_4_zust_refer]

\begin{List}[ListType=itemize]
\ListItem Zugriff auf Referenzen: Seiteneffekt ---\emph{Aktion}
\ListItem In Hugs und GHC: Modul \texttt{IORef}
\ListItem Abstrakter Datentyp von Referenzen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zust_refer1]
\begin{xcode}
data IORef a  -- abstract, instance of: Eq
\end{xcode}
\end{ProgramFragment}
\ListItem Neue Referenz erzeugen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zust_refer2]
\begin{xcode}
newIORef    :: a -> IO (IORef a)
\end{xcode}
\end{ProgramFragment}
\ListItem Referenz beschreiben:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zust_refer3]
\begin{xcode}
writeIORef  :: IORef a -> a -> IO ()
\end{xcode}
\end{ProgramFragment}
\ListItem Referenz auslesen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zust_refer4]
\begin{xcode}
readIORef   :: IORef a -> IO a
\end{xcode}
\end{ProgramFragment}
%\item Elementare Modifikation:
%\begin{xcode}
%modifyIORef :: IORef a -> (a -> a) -> IO ()
%\end{xcode}
% \item Achtung: echte Seiteneffekte!
\end{List}

\end{Paragraph}


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para12_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Endrekursion: \texttt{while} für Haskell.
  \begin{List}[ListType=itemize]
  \ListItem Überführung in Endrekursion meist möglich.
  \ListItem Noch besser sind strikte Funktionen.
  \end{List}
\ListItem Speicherlecks vermeiden: Striktheit, Endrekursion und Memoisation.
\ListItem Überladene Funktionen sind langsam.
\ListItem Listen sind keine Arrays.
\ListItem Referenzen in Haskell: \texttt{IORef}
\end{List}

\end{Summary}

\end{Section} % end Vorlesung 12


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-12.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-13.tex %%%%
%%
%% Praktische Informatik 3 - Thirteenth Lecture
%%

%\begin{comment}  
%\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_IRLO]
%\begin{code}
%module IRL0 where

%import Array
%import List
%import Monad
%import GraphicsUtils
%import qualified GraphicsWindows as GW (getEvent)
%\end{code}
%\end{ProgramFragment}
%\end{comment}


\begin{Section}[Title={Vorlesung vom 27.01.2003: Roboter!},
    ShortTitle={Die Imperative Roboterkontrollsprache (IRL)},
    Label={chapter13}]


\begin{Introduction}[Title={Inhalt}, Label=para13_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem \emph{Domain Specific Languages}
\ListItem Modellierung von Zuständen: \emph{Monaden}
\ListItem Beispiel für eine DSL: Roboterkontrollsprache IRL
  \begin{List}[ListType=itemize]
  \ListItem Nach Hudak, Kapitel 19.
  \end{List}
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Domain Specifc Languages (DSL)}, Label=section13_1_dsl]

\begin{List}[ListType=itemize]
\ListItem DSL: Sprache für speziellen Problembereich
  \begin{List}[ListType=itemize]
  \ListItem Im Gegensatz zu universalen Programmiersprachen
  \ListItem Beispiel: \LaTeX{}, Shell-Skripte, Spreadsheets, \dots{}
  \end{List}
\ListItem Implementierung von DSLs:
  \begin{List}[ListType=itemize]
  \ListItem Einbettung in Haskell
  \end{List}
\ListItem Beispiel heute: Imperative Roboterkontrollsprache IRL
\ListItem Dazu: imperative Konzepte in Haskell
\end{List}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% State Transformer Monads

% section 13_2: - CK
%%%% input replacer: Start von slides-13-monads.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_ST]
\begin{code}
module ST where
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Section}[Title={Zustandsübergangsmonaden},
    Label={section13_2_zus_ueb_mon}]

\begin{Paragraph}[Title={}, Label=para13_2_1_zus_ueb_mon]

\begin{List}[ListType=itemize]
\ListItem Aktionen (\texttt{IO a}) sind keine schwarze Magie.
\ListItem Grundprinzip: 
  \begin{List}[ListType=itemize]
  \ListItem Der Systemzustand wird durch das Programm gereicht. 
  \ListItem Darf dabei nie dupliziert oder vergessen werden.
  \ListItem Auswertungsreihenfolge muß erhalten bleiben.
  \end{List}
\ListItem $\Longrightarrow$ \emph{Zustandsübergangsmonaden} 
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Zustandsübergangsmonaden},
    Label=para13_2_2_zus_ueb_mon]

\begin{List}[ListType=itemize]
\ListItem Typ:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zus_ueb_mon1]
\begin{code}
data ST s a = ST (s-> (a, s))
\end{code}
\end{ProgramFragment}
  \begin{List}[ListType=itemize]
  \ListItem Parametrisiert über Zustand \texttt{s} und Berechnungswert
    \texttt{a}.
  \end{List}
\ListItem \texttt{IO a} ist Instanz der Typklasse \texttt{Monad}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zus_ueb_mon2]
\begin{xcode}
class Monad m  where
    (>>=)  :: m a -> (a -> m b) -> m b
    return :: a -> m a
\end{xcode}
\end{ProgramFragment}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Komposition von Zustandsübergängen:
  \begin{List}[ListType=itemize]
  \ListItem Im Prinzip Vorwärtskomposition \texttt{(>.>)}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zus_ueb_mon3]
\begin{xcode}
(>>=) :: ST s a-> (a-> ST s b)-> ST s b
(>>=) :: (s-> (a, s))-> (a-> s->  (b, s))-> (s-> (b, s))
(>>=) :: (s-> (a, s))-> ((a, s)-> (b, s))-> (s-> (b, s))
\end{xcode}
\end{ProgramFragment}
  \ListItem Damit \texttt{f >>= g = uncurry g . f}.
  \ListItem Aber: Konstruktor um \texttt{ST}, deshalb Hilfsfunktion zum
    Auspacken. 
  \end{List}

\ListItem Identität für Zustandstransformationen: 
  \begin{List}[ListType=itemize]
  \ListItem Identität auf dem Zustand, Identität auf dem Argument.
  \end{List}

\newpage

\ListItem Damit: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_zus_ueb_mon4]
\begin{xcode}
unwrap :: ST s a-> (s-> (a, s))
unwrap (ST f) = f

instance Monad (ST s) where
  f >>= g = ST (uncurry (unwrap. g) . unwrap f)
  return  a = ST (\s-> (a, s))
\end{xcode}
\end{ProgramFragment}

\newpage

\ListItem \Def{ref:st_monad}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_zus_ueb_mon5]
\begin{code}
instance Monad (ST s) where
  (ST f) >>= g = ST $ \s0-> let (r1, s1)= f s0
                                ST g0   = g r1
                            in  g0 s1
  return a = ST $ \s-> (a, s)
\end{code}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={\ACTION}, Label=para13_2_3_aktionen]

\begin{List}[ListType=itemize]

\ListItem Aktionen: Zustandstransformationen auf der Welt
\ListItem Typ \texttt{RealWorld\#} repräsentiert Außenwelt
  \begin{List}[ListType=itemize]
  \ListItem Typ hat genau einen Wert \texttt{realworld\#}, der nur für
    initialen Aufruf erzeugt wird.
  \ListItem Aktionen: \texttt{type IO a = ST RealWorld\# a}
  \end{List}
\ListItem Optimierungen:
  \begin{List}[ListType=itemize]
  \ListItem \texttt{ST s a} vordefiniert durch in-place-update implementieren;
  \ListItem \texttt{IO}-Aktionen durch einfachen Aufruf ersetzen.
  \end{List}
\end{List}


\end{Paragraph}


\end{Section}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-13-monads.tex %%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={IRL im Beispiel}, Label=section13_3_irl_bsp]

\begin{Paragraph}[Title={}, Label=para13_3_1_irl_bsp]

\begin{List}[ListType=itemize]
\ListItem Alle Roboterkommandos haben Typ \texttt{Robot a}
  \begin{List}[ListType=itemize]
  \ListItem Bewegung \texttt{move :: Robot ()}, \texttt{turnLeft :: Robot ()}
  \ListItem Roboter kann zeichnen: \texttt{penUp :: Robot()},
    \texttt{penDown :: Robot()}
  \ListItem Damit: Quadrat zeichnen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_irl_bsp1]
\begin{xcode}
drawSquare =
  do penDown; move; turnRight; move; 
     turnRight; move; turnRight; move     
\end{xcode}
\end{ProgramFragment}
  \end{List}
\ListItem Roboter lebt in einer einfachen Welt mit Wänden %% (und Öffnungen)
  \begin{List}[ListType=itemize]
  \ListItem Test, ob Feld vor uns frei:  \texttt{blocked :: Robot Bool} 
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Kontrollstrukturen}, Label=para13_3_2_kontrl_strukt]

\begin{List}[ListType=itemize]
\ListItem Bedingungen und Schleifen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_kontrl_strukt1]
\begin{xcode}
cond  :: Robot Bool-> Robot a-> Robot a-> Robot a
cond1 :: Robot Bool-> Robot ()-> Robot ()
while :: Robot Bool-> Robot ()-> Robot ()
\end{xcode}
\end{ProgramFragment}
\ListItem Bsp: Ausweichen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgsfrag_kontrl_strukt2]
\begin{scode}
evade :: Robot ()
evade = do cond1 blocked turnRight     
\end{scode}
\end{ProgramFragment}
\ListItem Bsp: Auf nächste Wand zufahren:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgsfrag_kontrl_strukt3]
\begin{scode}
moveToWall :: Robot ()
moveToWall = while (isnt blocked)
                move
\end{scode}
\end{ProgramFragment}
%\newslide{}
%\item Dazu \emph{geliftete} Boolsche Operatoren:
%\item Negation \texttt{isnt :: Robot Bool-> Robot Bool}
%\item Konjunktion und Disjunktion:
%\begin{xcode}
%(&&*), (||*) :: Robot Bool-> Robot Bool-> Robot Bool  
%\end{xcode}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Roboter auf Schatzsuche}, Label=para13_3_3_rob_schatz]

\begin{List}[ListType=itemize]
\ListItem Welt enhält auch \emph{Münzen}.
\ListItem Münzen aufnehmen und ablegen: \\
  \texttt{pickCoin :: Robot ()}, \texttt{dropCoin :: Robot ()}
\ListItem Roboter steht auf einer Münze? \texttt{onCoin :: Robot Bool}
\ListItem Beispiel: Auf dem Weg Münzen sammeln 
  (wie \texttt{moveWall})
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgsfrag_rob_schatz]
\begin{scode}
getCoinsToWall :: Robot ()
getCoinsToWall = while (isnt blocked) $
                   do move; pickCoin
\end{scode}
\end{ProgramFragment} %$
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Implementation}, Label=para13_3_4_rob_impl]

\begin{List}[ListType=itemize]
\ListItem Der Roboterzustand:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl1]
\begin{code}
data RobotState 
 = RobotState 
   { position  :: Position   
   , facing    :: Direction
   , pen       :: Bool 
   , color     :: Color
   , treasure  :: [Position]
   , pocket    :: Int
   } deriving Show  
\end{code}
\end{ProgramFragment}

\newpage

\ListItem \texttt{Robot a} transformiert Robotstate.
\begin{List}[ListType=itemize]
\ListItem Erster Entwurf: 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_rob_impl2]
\begin{xcode}
type Robot a = RobotState-> (RobotState, a)    
\end{xcode}
\end{ProgramFragment}
\ListItem Aber: brauchen die Welt (\texttt{Grid}),
  Roboterzustände \emph{zeichnen}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_rob_impl3]
\begin{xcode}
type Robot a = RobotState-> Grid-> Window->
                            (RobotState, a, IO())        
\end{xcode}
\end{ProgramFragment}
\ListItem Aktionen nicht erst aufsammeln, sondern gleich ausführen ---
  \texttt{RobotState} in \texttt{IO} einbetten.
\end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl4]
\begin{code}
data Robot a 
  = Robot (RobotState -> Grid -> Window -> 
                             IO (RobotState, a))
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Damit \texttt{Robot} als Instanz von \texttt{Monad} (vergleiche
  \Link[LinkText={\texttt{ST}):}]{ref:st_monad}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl5]
\begin{code}
instance Monad Robot where
  Robot sf0 >>= f
    = Robot $ \s0 g w -> do
                (s1,a1) <- sf0 s0 g w
                let Robot sf1 = f a1
                sf1 s1 g w
  return a 
    = Robot (\s _ _ -> return (s,a))

\end{code}
\end{ProgramFragment} %$

\newpage

\ListItem Positionen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl6]
\begin{code}
type Position = (Int,Int)
\end{code}
\end{ProgramFragment}

\ListItem Richtungen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl7]
\begin{code}
data Direction = North | East | South | West
     deriving (Eq,Show,Enum)  
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem 
Hilfsfunktionen: Rechts-/Linksdrehungen:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl8]
\begin{code}
right,left :: Direction -> Direction
right d = toEnum (succ (fromEnum d) `mod` 4)
left  d = toEnum (pred (fromEnum d) `mod` 4)
\end{code}
\end{ProgramFragment}
\end{List}
\ListItem Die Welt:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_rob_impl9]
\begin{code}
type Grid = Array Position [Direction]
\end{code}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Enthält für Feld \texttt{(x,y)} die Richtungen, in denen
  erreichbare Nachbarfelder sind.
\end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Einfache Zustandsmanipulationen},
  Label=para13_3_5_einf_zust_manip]

\begin{List}[ListType=itemize]
\ListItem Zwei Hilfsfunktionen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_einf_zust_manip1]
\begin{xcode}
updateState :: (RobotState -> RobotState) 
                                 -> Robot ()
queryState  :: (RobotState -> a) -> Robot a
\end{xcode}
\end{ProgramFragment}
\ListItem Damit Implementation der einfachen Funktionen (\texttt{turnLeft}, \texttt{turnRight}, \texttt{coins}, \&c)
\ListItem Einzige Ausnahme: \texttt{blocked}.
\ListItem \ShowFile{IRL.hs}{Zeigen.}
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Beim Bewegen:
  \begin{List}[ListType=itemize]
  \ListItem Prüfen, ob Bewegung möglich
  \ListItem Neue Position des Roboters zeichnen
  \ListItem Neue Position in Zustand eintragen.
  \end{List}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
  Label=prgsfrag_einf_zust_manip2]
\begin{scode}
move :: Robot ()
move = cond1 (isnt blocked) $
         Robot $ \s _ w -> do
            let newPos = movePos (position s) (facing s)
            graphicsMove w s newPos
            return (s {position = newPos}, ())

movePos :: Position -> Direction -> Position    
\end{scode}
\end{ProgramFragment}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Grafik}, Label=para13_3_6_grafik]

\begin{List}[ListType=itemize]
\ListItem Weltkoordinaten (\texttt{Grid}): Ursprung $(0,0)$ in Bildmitte
\ListItem Eine Position (\texttt{Position}) $\sim$ zehn Pixel
\ListItem Wände werden zwischen zwei Positionen gezeichnet
\ListItem Roboterstift zeichnet von einer Position zum nächsten
\ListItem Münzen: gelbe Kreise direkt links über der Position
\ListItem Münzen löschen durch übermalen mit schwarzem Kreis
\ListItem \ShowFile{IRL.hs}{Zeigen.}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Hauptfunktion}, Label=para13_3_7_hauptfunkt]

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_hauptfunkt]
\begin{xcode}
runRobot :: Robot () -> RobotState -> Grid -> IO ()  
\end{xcode}
\end{ProgramFragment}
\begin{List}[ListType=itemize]
\ListItem Fenster öffnen
\ListItem Welt zeichnen, initiale Münzen zeichnen
\ListItem Auf Spacetaste warten
\ListItem Funktion \texttt{Robot ()} ausführen
\ListItem Aus Endzustand kleine Statistik drucken 
\ListItem \ShowFile{IRL.hs}{Zeigen.}
\end{List}

\end{Paragraph}


\end{Section}


%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={IRL: Beispiele}, Label={section13_4_irl_beispiele}]

%%%% input replacer: Start von slides-13-robotex1.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_robex1]
\begin{code}
module RobotEx1 where

import IRL
import RobotWorld

\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Beispiel 1}, Label=para13_4_1_bsp1]

\begin{List}[ListType=itemize]
  \ListItem Roboter läuft in Spirale.
  \ListItem Nach rechts drehen, $n$ Felder laufen, 
    nach rechts drehen, $n$ Felder laufen;    
  \ListItem Dann $n$ um eins erhöhen; 
  \ListItem Nützliche Hilfsfunktion:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp1_1]
\begin{code}
for :: Int -> Robot ()-> Robot ()
for n a = sequence_ (replicate n a)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Hauptfunktion:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp1_2]
\begin{code}
spiral :: Robot ()
spiral = penDown >> loop 1 where
 loop n =
   let turnMove = do turnRight; for n move
   in  do for 2 turnMove
          cond1 (isnt blocked) (loop (n+1))

main :: IO ()
main = runRobot spiral s0 g0
\end{code}
\end{ProgramFragment}

\ListItem \RunFile{slides-13-robotex1.tex}{Zeigen.}
\end{List}


\end{Paragraph}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 



%%%% input replacer: Ende von slides-13-robotex1.tex %%%%


%%%% input replacer: Start von slides-13-robotex2.tex %%%%
\begin{comment}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_mod_robex2]
\begin{code}
module RobotEx2 where

import Array
import List
import Monad
import IRL
import GraphicsUtils
import RobotWorld


for :: Int -> Robot ()-> Robot ()
for n a = sequence_ (replicate n a)

moven :: Int-> Robot ()
moven n = for n move
\end{code}
\end{ProgramFragment}
\end{comment}


\begin{Paragraph}[Title={Beispiel 2}, Label=para13_4_2_bsp2]

Eine etwas komplizierte Welt: 
\begin{center}
  \includegraphics[height=13cm]{img/g3}
\end{center}

\newpage

\begin{List}[ListType=itemize]
\ListItem Ziel: in dieser Welt alle Münzen finden. 
\ListItem Dazu: Zerlegung in Teilprobleme
\end{List}
\begin{List}[ListType=enumerate]
\ListItem Von Startposition in Spirale nach außen
\ListItem Wenn Wand gefunden, Tür suchen
\ListItem Wenn Tür gefunden, Raum betreten
\ListItem Danach alle Münzen einsammeln
\end{List}

\newpage

\begin{List}[ListType=itemize]
\ListItem Schritt 1: Variation der Spirale
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_1]
\begin{code}
treasureHunt :: Robot ()
treasureHunt = do
  penDown; loop 1
   where loop n =
           cond blocked findDoor $
             do turnRight; moven n
                cond blocked findDoor $
                  do turnRight
                     moven n; loop (n+1)    
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Schritt 2: Tür suchen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_2]
\begin{code}
findDoor :: Robot ()
findDoor = do 
  turnLeft
  loop
   where loop = do
           wallFollowRight
           cond doorOnRight
             (do enterRoom; getGold)
             (do turnRight; move; loop)
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Hilfsfunktion 2.1: Wand folgen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_3]
\begin{code}
wallFollowRight :: Robot ()
wallFollowRight =
  cond1 blockedRight $
    do move; wallFollowRight

blockedRight :: Robot Bool
blockedRight = do
  turnRight
  b <- blocked
  turnLeft
  return b    
\end{code}
\end{ProgramFragment} %$

\newpage

\ListItem Hilfsfunktion 2.2: Tür suchen, Umdrehen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_4]
\begin{code}
doorOnRight :: Robot Bool
doorOnRight = do
  penUp; move
  b <- blockedRight
  turnAround; move; turnAround; penDown
  return b

turnAround :: Robot ()
turnAround = do turnRight; turnRight
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Schritt 3: Raum betreten
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_5]
\begin{code}
enterRoom :: Robot ()
enterRoom = do
  turnRight
  move
  turnLeft
  moveToWall
  turnAround  

moveToWall :: Robot ()
moveToWall = while (isnt blocked)
               move
\end{code}
\end{ProgramFragment}

\newpage

\ListItem Schritt 4: Alle Münzen einsammeln
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_6]
\begin{code}
getGold :: Robot ()
getGold = do
  getCoinsToWall
  turnLeft; move; turnLeft 
  getCoinsToWall
  turnRight
  cond1 (isnt blocked) $
    do move; turnRight; getGold  
\end{code}
\end{ProgramFragment} %$

\newpage

\ListItem Hilfsfunktion 4.1: Alle Münzen in einer Reihe einsammeln
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_7]
\begin{code}
getCoinsToWall :: Robot ()
getCoinsToWall = while (isnt blocked) $
                   do move; pickCoin
\end{code}
\end{ProgramFragment} %$

\ListItem Hauptfunktion:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgfrag_bsp2_8]
\begin{code}
main = runRobot treasureHunt s1 g3
\end{code}
\end{ProgramFragment}

\ListItem \RunFile{slides-13-robotex2.tex}{Zeigen!}
\end{List}


\end{Paragraph}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-13-robotex2.tex %%%%


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Summary}[Title={Zusammenfassung}, Label=para13_0_2_zusammenfassung]

\begin{List}[ListType=itemize]
\ListItem Zustandstransformationen 
  \begin{List}[ListType=itemize]
  \ListItem Aktionen als Transformationen der \texttt{RealWorld}
  \end{List}
\ListItem Die Roboterkontrollsprache IRL 
  \begin{List}[ListType=itemize]
  \ListItem Einbettung einer imperativen Sprache in Haskell
  \ListItem Der Robotersimulator
  \end{List}
\ListItem Beispiel für eine domänenspezifische Sprache (DSL).
  \begin{List}[ListType=itemize]
  \ListItem Hier in Haskell eingebettet.
  \ListItem Wegen flexibler Syntax, Typklassen und Funktionen höherer
    Ordnung gut möglich. 
  \end{List}
\end{List}

\end{Summary}


\end{Section} % end Vorlesung 13

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 
%%%% input replacer: Ende von slides-13.tex %%%%
\clearpage 
\clearpage %%%% input replacer: Start von slides-14.tex %%%%
%%
%% Praktische Informatik 3 - Fourteenth lecture 
%%                         

\begin{Section}[Title={Vorlesung vom 03.02.2002 Schlußbemerkungen},
    ShortTitle={Schlußbemerkungen}, Label={chapter14}]


\begin{Introduction}[Title={Inhalt der Vorlesung}, Label=para14_0_1_inhalt]

\begin{List}[ListType=itemize]
\ListItem Organisatorisches
\ListItem Noch ein paar Haskell-Döntjes:
  \begin{List}[ListType=itemize]
  \ListItem Web-Scripting mit Haskell
  \ListItem Concurrent Haskell
  \ListItem HTk
  \end{List}
\ListItem Rückblick über die Vorlesung
\ListItem Ausblick
\end{List}

\end{Introduction}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Organisatorisches}, Label={section14_1_organisat}]

\begin{Paragraph}[Title={Der \emph{studienbegleitende
        Leistungsnachweis}}, Label=para14_1_1_studbegl_leistnach]

\begin{List}[ListType=itemize]
\ListItem Bitte \emph{Scheinvordruck ausfüllen}.
  \begin{List}[ListType=itemize]
  \ListItem Siehe Anleitung.
  \ListItem Erhältlich vor FB3-Verwaltung (MZH Ebene 7)
  \ListItem \emph{Nur wer ausgefüllten Scheinvordruck abgibt, erhält auch einen.}
  \end{List}
\ListItem Bei Sylvie Rauer (MZH 8190) oder mir (MZH 8110) \emph{abgeben}
  (oder zum Fachgespräch mitbringen)
\ListItem Nicht vergessen: in \emph{Liste eintragen!}.
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Das Fachgespräch}, Label=para14_1_2_fachgespr]

\begin{List}[ListType=itemize]
\ListItem Dient zur \emph{Überprüfung der Individualität der Leistung}. 
  \begin{List}[ListType=itemize]
  \ListItem Insbesondere: Teilnahme an Beabeitung der Übungsblätter.
  \ListItem \emph{Keine Prüfung}.
  \end{List}
\ListItem Dauer: ca. 5--10 Min; einzeln, auf Wunsch mit Beisitzer
\ListItem Inhalt: Übungsblätter 
\ListItem Bearbeitete Übungsblätter mitbringen --- es werden zwei Aufgaben
  besprochen, die erste könnt Ihr Euch aussuchen.
\ListItem Termine: 
  \begin{List}[ListType=itemize]
  \ListItem Do. 06.02, Do. 13.02 --- Liste vor MZH 8110
  \ListItem oder nach Vereinbarung.
  \end{List}
\end{List}

\end{Paragraph}

\end{Section}


%%%%%%%%%%%%%%%%%%%%%%%%%


% Section 14_2: - CK
%%%% input replacer: Start von slides-14-cgi.tex %%%%
% -*-Mode: LaTeX-*-
%
% Server Side Scripting in Haskell

\begin{Section}[Title={Fallbeispiel: Lehrveranstaltungsevaluation},
    Label={section14_2_fallbsp_lehrveranst_eval}]

\begin{Paragraph}[Title={}, Label=para14_2_1]

\begin{List}[ListType=itemize]
\ListItem Ziel: Webformular zur Evaluation der Lehrveranstaltung
\ListItem Erfordert \emph{Auswertung} auf Serverseite: 
  \textit{server side scripting}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Medieninformatik für Einsteiger},
    Label=para14_2_1_medieninf_einsteig]

\begin{List}[ListType=itemize]
\ListItem Das Web:
\begin{center}
  \includegraphics[height=5cm]{fig/the-web}
\end{center}
\ListItem \texttt{Request} definiert durch Transferprotokoll \emph{HTTP}
\ListItem Datenformat definiert durch \emph{MIME} 
\ListItem \emph{HTML} ist ein spezielles Format
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={HTTP: Hypertext Transfer Protocol},
    Label=para14_2_2_http] %%  (RFC 2616)}

\begin{tabular}[t]{l@{\hspace{2ex}}l}
    Client (Webbrowser) & Server (e.g. \texttt{apache})  \\
    \hline 
    \texttt{connect}  & \texttt{listen} (Port 80) \\
    \texttt{GET index.html} \\
    & lese Datei \texttt{index.html} \\
    & sende Inhalt \\
    Inhalt von \texttt{index.html} \\
    empfangen \\
    HTML als Grafik darstellen \\
  \end{tabular} \\

%\verb"[08:57:01] cxl@atlas <cxl> # telnet www.informatik.uni-bremen.de 80"\\
%\verb"Trying 134.102.201.4..."\\
%\verb"Connected to olof.informatik.uni-bremen.de."\\
%\verb"Escape character is '^]'."\\
%\verb"GET /home.html"\\
%\verb"<HTML><HEAD><TITLE>Allgemeine Informationen zum FB3</TITLE>"\\
%% \verb"  <BASE HREF="http://www.informatik.uni-bremen.de/fb3/"></HEAD>"\\

\end{Paragraph}


\begin{Paragraph}[Title={Verschiedene Dokumenttypen: MIME},
    Label=para14_2_3_mime]

\begin{List}[ListType=itemize]
\ListItem Dokumente sind \texttt{getypt}: \emph{MIME}
  \begin{List}[ListType=itemize]
  \ListItem (Multipurpose Internet Mail Extensions, \texttt{RFC1521}) 
  \end{List}
\ListItem MIME-Typ: \texttt{typ/subtyp}, wie in
  \begin{tabular}[t]{l}
   \texttt{text/plain} \\[.5ex]
   \texttt{text/html}  \\[.5ex]
   \texttt{image/gif}  \\[.5ex]
   \texttt{application/postscript} \\[.5ex]
   \texttt{x-application/url-encoded} \\[.5ex]
  \end{tabular}
\ListItem Typ bestimmt Darstellung --- HTML ein Typ von vielen  
\end{List}

\end{Paragraph}


\begin{comment}
\begin{Paragraph}[Title={HTML: Hypertext Markup Language},
    Label=para14_2_4_html]
\begin{List}[ListType=itemize]
\ListItem Spezielles Format der Standard General Markup Language (SGML)
\ListItem Text besteht aus \emph{Elementen}, eingeschlossen in
  \emph{Tags}: \\[1ex]
  \verb"       <elem attr=val ...> ... </elem>"
  \\[1ex]
  Beispiele: \texttt{h1} (\verb!<h1>Ueberschrift</h1>!),
  \texttt{h2}, \ldots, \texttt{a} (Attribut \texttt{href}),
  \texttt{img} (Attr. \texttt{src}, \texttt{alt}),
  \texttt{ul} (Liste aus \texttt{it} Elementen), \texttt{p},
  \texttt{br}, \ldots
\ListItem Ein HTML-Text besteht aus einem Element \texttt{HTML}, welches aus
  \texttt{Head} und \texttt{Body} besteht. 
\ListItem Einfach zu parsen, schwer zu schreiben, schwerer zu generieren!
\end{List}  
\end{Paragraph}

\end{comment}


\begin{Paragraph}[Title={CGI-Skripte \textit{(server side
        scripting)}}, Label=para14_2_5_cgi]

\begin{List}[ListType=itemize]
\ListItem CGI-Skripte liegen unter \texttt{/home/www/users/cxl/cgi-bin/<name>},\\
  Aufruf als \texttt{http://www....de/cgi-bin/cgiwrap/cxl/<name>}
\ListItem CGI-Skripte werden auf dem Server \emph{ausgeführt}, \\
  Ausgabe wird an Client übertragen 
\ListItem Bei Ausgabe Syntax beachten: 
\begin{verbatim}
Content-Type: text/html 

<HTML><BODY><H1>Hello, World</H1></BODY></HTML>  
\end{verbatim}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Formulare}, Label=para14_2_6_formulare]

\texttt{Formulare} sind spezielle HTML-Elemente zum
  Datenaustausch zwischen Client und Server:

  \begin{tabular}[t]{l|l}
    Element & Attribut \\[.5ex]
    \hline
    \texttt{FORM} &
    \texttt{ACTION}: \texttt{POST}, \texttt{GET} \\[.3ex]
    & \texttt{METHOD:} URL \\[.5ex]
    \texttt{INPUT} &
     \texttt{TYPE}: \texttt{TEXT}, \texttt{CHECKBOX}, \texttt{RADIO},
     \texttt{SUBMIT}, \texttt{RESET} \ldots{} \\[.3ex] 
                 %% , \texttt{HIDDEN}, \texttt{IMAGE} \\[.3ex]
    & \texttt{NAME}, \texttt{VALUE}, 
     \texttt{CHECKED}, \texttt{SIZE}, \texttt{MAXLENGTH} \\[.5ex]
%    \texttt{SELECT} & Mehrfachselektion aus \texttt{OPTION}-Element \\[.5ex]
%    \texttt{OPTION} & \\[.5ex]
    \texttt{TEXTAREA} & Texteditor \\[.5ex]
    & \texttt{NAME}, \texttt{ROWS}, \texttt{COLS} \\[.5ex]
  \end{tabular}

\newpage

Was passiert beim Abschicken \textit{(submit)} eines Formulars?
\begin{List}[ListType=itemize]
  \ListItem Client kodiert Formulardaten als URL
  \ListItem Server erkennt URL als CGI-Skript
    und ruft CGI-Skript auf
  \ListItem Kodierte Daten werden in Kommandozeile/Umgebungsvariablen
    übergeben 
  \ListItem Ergebnis wird an den Client zurückgeschickt
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Ein einfaches Beispiel}, Label=para14_2_7_cgi_bsp]

\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgsfrag_cgi_bsp1]
\begin{scode}
<form method=get action=http://www...de/cgi-lokal/test>
Name: <input type=text name=name size=20 maxlength=30>
Tick: <input name=ticked value=y type=checkbox>
      <input type=submit>
</form> 
\end{scode}
\end{ProgramFragment}
\begin{center}
  \includegraphics[height=5cm]{img/simple-form}
\end{center}  

\end{Paragraph}


\begin{Paragraph}[Title={Kodierung der Daten}, Label=para14_2_8_kodierung_dat]

\begin{List}[ListType=itemize]
  \ListItem Bei \texttt{ACTION=mailto:<adress>} wird Dokument geschickt
  \ListItem \texttt{GET} übergibt Argumente in URL, \\
        \texttt{POST} in Umgebungsvariablen
  \ListItem \texttt{GET} für Anfragen, \texttt{POST} für Änderungen
%%    \hfill \textit{Hmmm\ldots?}

  \ListItem Beispiel vorherige Seite: 

    Methode \texttt{GET}: \verb"test?name=Hello+there%3f&ticked=y"  

    Methode \texttt{POST}: Umgebungsvar. \texttt{name}: \verb"Hello+there%3f",
    \texttt{ticked}: \texttt{y} 
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Server Side Web Scripting in Haskell},
    Label=para14_2_9_server_side] %% (Erik Meijer)}

\begin{List}[ListType=itemize]
\ListItem 
Ziel: Trennung von Funktionalität und Repräsentation
\begin{center}
\includegraphics[height=6cm]{fig/encaps-cgi}  
\end{center}
\texttt{wrapper} dekodiert URL, erzeugt HTML-Text
\ListItem Trennung von Funktionalität und Abstraktion
\ListItem Flexibilität: leicht auf anderes Format (e.g. ASP) anzupassen
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={MIME und HTML in Haskell},
    Label=para14_2_10_mime_html]

\begin{List}[ListType=itemize]
\ListItem \texttt{MIME}-Dokumente repräsentiert durch Typklasse \texttt{MIME}
\ListItem HTML ist ein abstrakter Datentyp \texttt{HTML}
  \begin{List}[ListType=itemize]
  \ListItem \texttt{HTML} ist Instanz von \texttt{MIME}
  \ListItem Vordefinierte \emph{Kombinatoren}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell, Label=prgxfrag_mime_html1]
\begin{xcode}
prose                 :: String -> HTML
h1,h2,h3,h4,h5,h6,h7  :: String -> HTML
href                  :: URL -> [HTML] -> HTML
\end{xcode}
\end{ProgramFragment}
\end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Server Side Scripting Made Very Easy},
    Label=para14_2_14_server_side_easy]

\begin{List}[ListType=itemize]
 \ListItem  Anfragen vom Typ \verb"Request = [(Name, Value)]" 

 \ListItem  Skriptfunktion liefert Wert vom Typ \texttt{CgiOut a}:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgsfrag_server_side_easy]
\begin{scode}
module Main (main) where

import CGI

helloWorldHTML :: [(Name,Value)] -> HTML
helloWorldHTML env = 
   page "Hello World" [] [h1 "Hello World!"]
main :: IO ()
main = wrapper (\env -> 
       do{return (Content{mime= helloWorldHTML env})})
\end{scode}
\end{ProgramFragment}
%helloWorldText :: [(Name,Value)] -> TextPlain
%helloWorldText env = TextPlain "Hello World!"
%main :: IO ()
%main = wrapper (\env -> return (Content{mime = helloWorldText env}))
\end{List}


\end{Paragraph}


\begin{Paragraph}[Title={Das PI3-Evaluationssystem},
    Label=para14_2_15_pi3_eval]

\begin{List}[ListType=itemize]
\ListItem \href{http://www.informatik.uni-bremen.de/~cxl/pi3/eval/QForm.html}
           {Das Formular}
\ListItem Gemeinsame Daten: \texttt{EvalData.hs}
\ListItem CGI-Skript: \texttt{Answer.hs}
\ListItem Auswertung: \texttt{Process.hs} \hfill
  \RunXTerm{Zeigen}
  \\[2ex]
  \includegraphics[height=6cm]{fig/eval}
\end{List}

\end{Paragraph}


\end{Section}













\begin{comment}

%% Hier TestForm.html, evalasp.cgi

\begin{t-slide}{Beispiel: \texttt{TestForm.html}}
\begin{center}
   \epsfig{file=test_form.eps,height=11cm}      
\end{center}  
\end{t-slide}
\begin{t-slide}{Beispiel: \texttt{TestForm.html}}
\begin{center}
   \epsfig{file=test_form_eval.eps,height=5cm}
\end{center}  
\end{t-slide}

\begin{t-slide}{Noch ein Beispiel: \texttt{Counter.cgi} (Erik Meijer)}
\begin{verbatim}
main :: IO ()
main = wrapper (\env -> return (Content{mime = counter env}))

counter :: [(Name,Value)] -> HTML
counter env =
   page "Counter" []
      [ h1 "Click me!"
      , gui counterScript [submit "Count" (show (read n + 1))]
      ] where n = fromMaybe "0" (lookup "Count" env)

counterScript :: String
counterScript = "http://www.informatik.uni-bremen.de/cgi-lokal/cxl/
                Counter.cgi" 
\end{verbatim}
\end{t-slide}

\end{comment}







%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root"
%%% End: 

%%%% input replacer: Ende von slides-14-cgi.tex %%%%



%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Zum Abschluß}, Label={section14_3_abschluss}]

\begin{Paragraph}[Title={Concurrent Haskell}, Label=para14_3_1_conc_haskell]

\begin{List}[ListType=itemize]
\ListItem \emph{Threads} in Haskell:
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_conc_haskell1]
\begin{xcode}
  forkIO :: IO () -> IO ThreadID
  killThread :: ThreadID -> IO ()
\end{xcode}
\end{ProgramFragment}
\ListItem Zusätzliche Primitive zur Synchronisation
\ListItem Erleichtert Programmierung \emph{reaktiver Systeme}
  \begin{List}[ListType=itemize]
  \ListItem Benutzerschnittstellen, Netzapplikationen, \ldots{}
  \end{List}
\ListItem hugs: \emph{kooperativ}, ghc: \emph{präemptiv}

\newpage

\ListItem Beispiel: \RunXTerm{Zeigen}
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgfrag_conc_haskell2]
\begin{code}
module Main where

import Concurrent

write :: Char -> IO ()
write c = putChar c >> write c

main :: IO ()
main = forkIO (write 'X') >> write '.' 
\end{code}
\end{ProgramFragment}
\end{List}


%\newslide{Der Haskell Web Server}

%\begin{itemize}
%\item Ein RFC-2616 konformanter Webserver
% (Peyton Jones, Marlow 2000)

%\item Beispiel für ein
%  \begin{itemize}
%  \item nebenläufiges,
%  \item robustes,
%  \item fehlertolerantes,
%  \item performantes System.
%  \end{itemize}
%\item Umfang: ca. 1500 LOC, "`written with minimal effort"'
%\item Performance: ca. 100 repl/s bis 700 repl
%\end{itemize}

\end{Paragraph}


\begin{Paragraph}[Title={Grafische Benutzerschnittstellen},
    Label=para14_3_2_graf_benutz_schnittst]

\begin{List}[ListType=itemize]
\ListItem \emph{HTk}
  \begin{List}[ListType=itemize]
  \ListItem Verkapselung von Tcl/Tk in Haskell
  \ListItem Nebenläufig mit \emph{Events} 
  \ListItem Entwickelt an der AG BKB (Dissertation E.~Karlsen)
  \ListItem Mächtig, abstrakte Schnittstelle, mittelprächtige Grafik
  \end{List}
\ListItem \emph{GTk+HS}
  \begin{List}[ListType=itemize]
  \ListItem Verkapselung von GTk+ in Haskell
  \ListItem Zustandsbasiert mit call-backs
  \ListItem Entwickelt an der UNSW (M.~Chakravarty)
  \ListItem Neueres Toolkit, ästethischer, nicht ganz so mächtig
  \end{List}
\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Grafische Benutzerschnittstellen mit HTk},
  Label=para14_3_3_graf_benutz_schnittst_htk]

\begin{List}[ListType=itemize]
\ListItem Statischer Teil: Aufbau des GUI
  \begin{List}[ListType=itemize]
  \ListItem Hauptfenster öffnen 
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_graf_benutz_schnittst_htk1]
\begin{xcode}
main:: IO ()
main =
  do main <- initHTk []
\end{xcode}
\end{ProgramFragment}
\ListItem Knopf erzeugen und in Hauptfenster plazieren
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_graf_benutz_schnittst_htk2]
  \begin{xcode}    
       b <- newButton main [text "Press me!"] 
       pack b []
\end{xcode}
\end{ProgramFragment}
\end{List}

\newpage

\ListItem Dynamischer Teil: Verhalten während der Laufzeit
\begin{List}[ListType=itemize]  
  \ListItem Knopfdruck als Event
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_graf_benutz_schnittst_htk3]
\begin{xcode}
     click <- clicked b
\end{xcode}
\end{ProgramFragment}
   \ListItem Eventhandler aufsetzen
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_graf_benutz_schnittst_htk4]
\begin{xcode}
     spawnEvent 
      (forever 
\end{xcode}
\end{ProgramFragment}
   \ListItem Eventhandler defininieren
\begin{ProgramFragment}[Title={}, Formalism=\Haskell,
    Label=prgxfrag_graf_benutz_schnittst_htk5]
\begin{xcode}
        (click >>> do nu_label <- mapM randomRIO 
                                   (replicate 5 ('a','z'))
                      b # text nu_label))
     finishHTk  
\end{xcode}
\end{ProgramFragment}
   \end{List}
 \ListItem \MMlinkApplication{Zeigen.}{simple1}
       \MMlinkApplication{(Etwas längeres Beispiel.)}{hsMines2}
\end{List}

\end{Paragraph}


\end{Section}


%%%%%%%%%%%%%%%%%%%%%%


\begin{Section}[Title={Rückblick}, Label={section14_4_rueckblick}]

\begin{Paragraph}[Title={Grundlagen der funktionalen Programmierung},
       Label=para14_4_1_rueckbl_grundlag]

\begin{List}[ListType=itemize]
  \ListItem Definition von Funktionen durch rekursive Gleichungen
  \ListItem Auswertung durch Reduktion von Ausdrücken
  \ListItem Typisierung und Polymorphie
  \ListItem Funktionen höherer Ordnung
  \ListItem Algebraische Datentypen
  \ListItem Beweis durch strukturelle und Fixpunktinduktion

%%%  \end{itemize}

\newpage

\ListItem Fortgeschrittene Features:
  \begin{List}[ListType=itemize]
  \ListItem Modellierung von Zustandsabhängigkeit durch \texttt{IO}
  \ListItem Überladene Funktionen durch Typklassen
  \ListItem Unendliche Datenstrukturen und verzögerte Auswertung
  \end{List}

\ListItem Beispiele:
  \begin{List}[ListType=itemize]
  \ListItem Parserkombinatoren
  \ListItem Grafikprogrammierung
  \ListItem Animation
  \end{List}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Zusammenfassung Haskell},
  Label=para14_4_2_zusfas_haskell]

\begin{minipage}[t]{12cm}
Stärken:
  \begin{List}[ListType=itemize]
  \ListItem Abstraktion durch
    \begin{List}[ListType=itemize]
    \ListItem Polymorphie und Typsystem
    \ListItem algebraische Datentypen
    \ListItem Funktionen höherer Ordnung
    \end{List}
  \ListItem Flexible Syntax
  \ListItem Haskell als Meta-Sprache
  \ListItem Ausgereifter Compiler
  \ListItem Viele Büchereien
  \end{List}
\end{minipage}
\hspace*{1ex}
\begin{minipage}[t]{12cm}
Schwächen:
  \begin{List}[ListType=itemize]
  \ListItem Komplexität      
  \ListItem Dokumentation
    \begin{List}[ListType=itemize]
    \ListItem z.B. im Vergleich zu Java's APIs
    \end{List}
  \ListItem Büchereien
  \ListItem Noch viel im Fluß
    \begin{List}[ListType=itemize]
    \ListItem Tools ändern sich
    \end{List}
  \end{List}
\end{minipage}

\end{Paragraph}


\begin{Paragraph}[Title={Warum funktionale Programmierung lernen?},
    Label=para14_4_3_warum_funkt_prg]

\begin{List}[ListType=itemize]
\ListItem Abstraktion \\
  \begin{List}[ListType=itemize]
  \ListItem Denken in Algorithmen, nicht in Programmiersprachen
  \end{List}

\ListItem FP konzentriert sich auf \emph{wesentlichen} Elemente moderner 
  Programmierung: \\
  \begin{List}[ListType=itemize]
  \ListItem Typisierung und Spezifikation
  \ListItem Datenabstraktion
  \ListItem Modularisierung und Dekomposition
  \end{List}

\ListItem Blick über den Tellerrand --- Blick in die Zukunft \\
  \begin{List}[ListType=itemize]
  \ListItem Studium $\neq$ Programmierkurs--- was kommt in 10 Jahren?
  \end{List}

  {\flushright{}\emph{Hat es sich gelohnt?}\par{}}

\end{List}

\end{Paragraph}


\begin{Paragraph}[Title={Hilfe!}, Label=para14_4_4_hilfe]

\begin{List}[ListType=itemize]
 \ListItem Haskell: primäre Entwicklungssprache an der AG BKB
   \begin{List}[ListType=itemize]
   \ListItem Entwicklungsumgebung für formale Methoden (Uniform Workbench)
   \ListItem Werkzeuge für die Spezifikationssprache CASL (Tool Set CATS)
   \end{List}
 \ListItem Wir suchen \emph{studentische Hilfskräfte}
   \begin{List}[ListType=itemize]
   \ListItem für diese Projekte
   \end{List}
 \ListItem Wir bieten:
   \begin{List}[ListType=itemize]
     \ListItem Angenehmes Arbeitsumfeld
     \ListItem Interessante Tätigkeit
   \end{List}
 \ListItem Wir suchen \emph{Tutoren für PI3}
   \begin{List}[ListType=itemize]
     \ListItem im WS 03/04  --- \emph{meldet Euch!}
   \end{List}
\end{List}

\centerslidebody{}
\end{Paragraph}


\begin{Paragraph}[Title={}, Label=para14_4_5_tschuess]

\begin{center}
  Tschüß! \hspace*{2ex}
  \vspace{2ex} \par{}
   \hspace*{15ex}\includegraphics[height=3cm]{img/wp}
\end{center}

\end{Paragraph}


\end{Section}


\end{Section} % end Vorlesung 14


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "root.tex"
%%% End: 
%%%% input replacer: Ende von slides-14.tex %%%%
\clearpage 


\end{Package}

\end{document}


%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
%%%% input replacer: Ende von root.tex %%%%
