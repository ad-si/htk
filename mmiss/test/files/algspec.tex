\documentclass[landscape, slides, light]{mmiss2}

\usepackage{latexsym}
\usepackage{casl}

\newcommand{\gram}[1]{{\texttt{#1}}}
\newcommand{\power}{\hat{\ }}
\newcommand{\annoimplies}{\%{\bf implies}\ }
\newcommand{\annodef}{\%{\bf def}\ }
\newcommand{\annocons}{\%{\bf conservatively}\ }
\newcommand{\annoprec}{\%{\bf prec}\ }
\newcommand{\annorassoc}{\%{\bf right\ assoc}\ }
\newcommand{\annolassoc}{\%{\bf left\ assoc}\ }
\newcommand{\annobrackets}{{\bf brackets}\ }


\begin{document}
\begin{Package}[MMISS_Latex2]{pack1}{Algebraic
Specification -- \\ adapted as example of ML2\\ by M. D.}{Date=12.09.2002,Version=5,PreviousVersion=4,Authors={Markus
Roggenbach},PriorAuthors={Markus
Roggenbach},ShortAuthor={M. Roggenbach},ShortTitle={Algebraic Specification},Comment=Test,Language=en-GB,LevelOfDetail=LectureNotes,InteractionLevel=Hyper}

\begin{Section}[MMISS_Latex2]{Chapter1}{Introduction}{Date=12.09.2002,Version=5,PreviousVersion=4,Authors={Markus
Roggenbach},PriorAuthors={Markus
Roggenbach},ShortAuthor={M. Roggenbach},ShortTitle={Algebraic Specification},Comment=Test,Language=en-GB,LevelOfDetail=LectureNotes,InteractionLevel=Hyper}
\begin{Introduction}{Introduction1.1}{Overview}{}
The following text has the purpose to explain formal
specifications to the reader. It also provides some simple examples
and descriptions of formal specifications. At the end of this text some
basic mathematical concepts as semigroups
\ForwardLink{Definition1.4.1}{}, monoids
\ForwardLink{Definition1.4.2}{} and groups
\ForwardLink{Definition1.4.3}{} are given.
\end{Introduction}
\begin{Section}{Section1.1}{Formal Methods in Software Design}{}
\begin{Paragraph}{para11}{}{}
\begin{center}
``Use of mathematics in software development''\\
\end{center}
main activities:
\begin{List}{List1.1.1}{itemize}{}
\ListItem{}
{\Emphasis{ writing} formal specifications  \pause}
\ListItem{}
{\Emphasis{ proving} properties about formal specifications \pause}
\ListItem{}
{\Emphasis{ constructing} a program by mathematical \\
            manipulation of a formal specification \pause}
\ListItem{}
{\Emphasis{ verifying} a program by mathematical argument}
\end{List}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.1.1}{Non Formal, Semi Formal, Formal}{}

\begin{TextFragment}{TextFragment1.1.1}{}
``It has been widely accepted that \Emphasis{ syntax} can be mathematically
defined for quite some time, but there has been more resistance to the
mathematical definition of \Emphasis{ semantics}.''
\end{TextFragment}

(quoted freely from \cite{bowen99})
\end{Paragraph}
\begin{Paragraph}{Paragraph1.1.2}{}{}
\Emphasis{ non formal}:\\
in natural languague \\
(open to arbitrary new symbols)\\
\newline
\Emphasis{ formal}: \\
in a (fixed) language with \\
mathematically defined {\bf Syntax} and {\bf Semantics}\\

\Emphasis{ semi formal}: \\
in a language with
\begin{List}{List1.1.2}{itemize}{}
\ListItem{}
 {{\bf Syntax} definition by mathematical methods}
\ListItem{} 
{{\bf Semantics} definition in natural language or by tool}
\end{List}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.1.3}{Specifications}{}
Specification: ``description by properties''\\

Main question on specifications:\\
``What happens if \dots'' \\ \\

Specifications should be \pause
\begin{List}{List1.1.3}{itemize}{}
\ListItem{}
{complete \pause}
\ListItem{}
{precise \pause}
\ListItem{}
{consistent (no contradictions)}
\end{List}
\end{Paragraph}
\begin{Paragraph}{Paragraph1.1.4}{Why formal Specifications?}{}
\begin{List}{List1.1.4}{itemize}{}
\ListItem{}
{formal specifications are \Emphasis{precise}  \\
          (non formal and sometimes even semi formal \\
          specifications are open to re-interpretation)\pause}


\ListItem{}
{syntactical and semantical \Emphasis{correctness} \\
          independent of tools \pause}

\ListItem{}
{\Emphasis{mathematical methods} \\
          (consistency, completeness)}
\end{List}
\end{Paragraph}
\begin{Paragraph}{Paragraph1.1.5}{Limitations of Formal Methods}{}
\begin{center}
``The world is not a formal system.''
\end{center}
\hfill \\
I. Modelling means Abstraction \\
(only ``essentials'' are considered)\\
\hfill \\
II. Errors within Formalisms.
\end{Paragraph}
\begin{Paragraph}{Paragraph1.1.6}{}{}

III. Behaviour of a Program depends on\\
\begin{List}{List1.1.5}{itemize}{}
\ListItem{}
{Compiler}
\ListItem{}
{Operating System}
\ListItem{}
{Computer Hardware}
\ListItem{}
{Embedding in a Technical Process}
\ListItem{}
{Human Operator}
\end{List}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.1.7}{Waterfall Model}{}

\begin{Table}{Table1.1.1}{Waterfall Model}{}
{\small
\begin{center}
\begin{tabular}{lcl}

               & Requirement Elicitation & \\ 
               & and Analysis            &\\
& $\uparrow$ $\downarrow$ &\\
Nat.~Lang.   & Non Formal Specification &\\
& $\uparrow$ $\downarrow$ & Validation \\

\Emphasis{Spec.~Lang.}  & Formal Specification & \\
& $\uparrow$ $\downarrow$ & ``Inv.~\& Verify'' or\\

Progr.~Lang. & Implementation & Transformation \\
& $\uparrow$ $\downarrow$ &\\

& Test & \\

& $\uparrow$ $\downarrow$ &\\

& Maintenance& \\

\end{tabular}
\end{center}
}
\end{Table}

\end{Paragraph}
\begin{Paragraph}{Paragraph1.1.8}{Specification Languages}{}

\begin{TextFragment}{TextFragment1.1.2}{}
\begin{center}
  ``No single technique is adequate to address \\
  all issues of complex system development.''
\end{center}
\end{TextFragment}
\hfill \\
Classification of Specification Languages:\\

\begin{List}{List1.1.6}{itemize}{}
\ListItem{}
{Model-oriented: Z, VDM}
\ListItem{}
{Property-oriented: Larch, OBJ, \Emphasis{CASL}}
\ListItem{}
{Process algebras:
\begin{Table}{Table1.1.6.1}{Process algebras}{}
\begin{tabular}[t]{l}
CCS, \Emphasis{CSP}, $\pi$-calculus
\end{tabular}
\end{Table}}
\end{List}
\end{Paragraph}

\bibliographystyle{abbrv}
\bibliography{lecture.bib}

\end{Section}

\begin{Section}{Section1.2}{Elements of Formal Specifications}{}
\begin{Paragraph}{para12}{}{}
\begin{center}
\Emphasis{ Aim of Formal Specifications}
\end{center}
\vspace{1cm}
\begin{center}
\begin{Table}{Table1.2.1}{Specification}{}
\begin{tabular}{c}
Non Formal Specification \\
$\uparrow$ $\downarrow$ \\
\Emphasis{Formal Specification}  \\
$\uparrow$ $\downarrow$ \\
Implementation \\
\end{tabular}\\
\end{Table}

\end{center}
\vspace{1cm}
extract the ``essentials'' of
\begin{List}{List1.2.1}{itemize}{}
\ListItem{}
{a non formal specification}
\ListItem{}
{all desirable implementations}
\end{List}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.1}{ Running Example: Database}{}
Non Formal Specification:
\\ \\
Write a Java program that implements a database with \\
$\bullet$ ``Name'' and \\
$\bullet$ ``Telephone Number'' \\
as entries.
\end{Paragraph}

\begin{Section}{Section1.2.1}{Example for Program}{}
\begin{Paragraph}{para1b}{}{}
The following example demonstrates the Java implementation of a
database.
\end{Paragraph}
\begin{Paragraph}{Paragraph1.2.1.1}{How to begin?}{}
A Java program usually starts with some declarations of classes and
subroutines.
\newline
\hfill \\
\hfill \\
\hfill \\
\IncludeProgramFragment{ProgramFragment1.2.1.1.1}{}
\end{Paragraph}
\begin{Paragraph}{Paragraph1.2.1.2}{How to proceed?}{}
Having completed the list of declarations one usually continues with
the source code of some auxiliary functions.
\newline
\hfill \\
\hfill \\
\hfill \\
\IncludeProgramFragment{ProgramFragment1.2.1.1.2}{}
\end{Paragraph}
\begin{Paragraph}{Paragraph1.2.1.3}{The complete program}{}
The source code would then look as follows.
\newline
\hfill \\
\hfill \\
\hfill \\
\begin{Program}[Java_Prog]{Program1.2.1.1}{(Useless) Database}{}
\begin{ProgramFragment}[Java_Prog]{ProgramFragment1.2.1.1.1}{}{}
\tiny
\begin{verbatim}
import Useless.*;



class T_dbu implements T_db_Interface {



  private static final T_name name = new T_name();

  private final T_num number = new T_num();

  private final T_dbu next = this;



  public void initial(){

    return;

  }



  public T_num look_up(T_name search_name){

    return number;

  }



  public void update(T_name ins_name, T_num ins_num){

    return ;

  }



  public void remove(T_name rem_name){

    return ;

  }



\end{verbatim}
\normalsize
\end{ProgramFragment}
\begin{ProgramFragment}[Java_Prog]{ProgramFragment1.2.1.1.2}{}{}
\tiny
\begin{verbatim}
  // Hilfs-Operationen



  public static void opt() {

    System.out.println("Choose one of the following options :\n");

    System.out.println(" (1) initial - create an empty database");

    System.out.println(" (2) update  - update or insert an entry");

    System.out.println(" (3) look_up - search a number by name");

    System.out.println(" (4) remove  - remove an entry");

    System.out.println(" (5) quit    - leave this program \n");

  }



  public static T_name getName(){

    System.out.print("\nPlease enter the name : ");

    String input = Input.readString();

    T_name t_name = new T_name();

    //    t_name.setData(input);

    return t_name;

  }



\end{verbatim}
\normalsize
\end{ProgramFragment}
\begin{ProgramFragment}[Java_Prog]{ProgramFragment1.2.1.1.3}{}{}
\tiny
\begin{verbatim}
  public static void main(String args[]) {

    T_dbu data = new T_dbu();

    boolean init = false;

    boolean end = false;

    System.out.println("Implementation of T_db_interface.java on list-structures:n");

    System.out.println("Attention: You can work with one database at the time only.");

    System.out.println("           If you create a new database, any old information is lost.\n");

    do {

      opt();

      System.out.print("Your Choice : ");  

      int input1 = Input.readInt();

      switch(input1) {



      case 1 :

        System.out.println("Creating a new database ... \n");

        data.initial();

        init = true;

        break;



      case 2 :

        if(init == false){

          System.out.println("Please create a new database first (1) !\n");

          break;

        }

        System.out.println("Update/insert an entry");

        T_name up_name = getName();

        int input2;

        do {

          System.out.print("\nPlease enter the number : ");

          input2 = Input.readInt();

          if (input2 == 0)

            System.out.println("\n Sorry this is not a valid number!");

        } while(input2 == 0);   

        T_num up_num = new T_num();

        //

        data.update(up_name, up_num);

        System.out.println("Done. \n");

        break;

      

      case 3 :

        if(init == false){

          System.out.println("Please create a new database first (1) !\n");

          break;

        }

        System.out.println("Search a number");  

        T_name lo_name = getName();

        int num1 = data.look_up(lo_name).getData();

        System.out.println("The name is : "+lo_name.getData()+"\n"); 

        System.out.println("The number is : "+num1+"\n"); 

        break;



      case 4 :

        if(init == false){

          System.out.println("Please create a new database first (1) !\n");

          break;

        }

        System.out.println("Remove an entry");  

        T_name rem_name = getName();

        data.remove(rem_name);

        System.out.println("Done. \n");

        break;



      case 5 :

        System.out.print("Do you really want to quit (y/n)? ");

        String input3 = Input.readString();

        if (input3.equalsIgnoreCase("y"))

          end = true;

        break;



      default :

        System.out.print("That's not a valid input. \n");

      }

    } while (end == false);

    System.out.print("Bye...\n");

  }

}


\end{verbatim}
\normalsize
\end{ProgramFragment}
\end{Program}
\end{Paragraph}
\end{Section}

\begin{Paragraph}{Paragraph1.2.2}{}{}
\begin{center}
{\Large Essential for Programs}
\end{center}
distinguish between functions of the
\begin{List}{List1.2.2}{itemize}{}
\ListItem{}
{\Emphasis{interface} \\ (functions that can be used
``safely'')}
\ListItem{}
{\Emphasis{implementation} \\ (functions that make sense \\
           only in a particular realization)}
\end{List}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.3}{ Formal Specification -- First Element}{}
Formal Specifications describe an \Emphasis{Interface} -- \\
written down as \Emphasis{Signature}, i.e.~a list consisting of the\\
\begin{List}{List1.2.3}{itemize}{}
\ListItem{}
{Name and}
\ListItem{}
{Profile}
\end{List}
of all functions.
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.4}{Interfaces and Programming Languages}{}
PL supporting Interfaces: \\
C++, Modula, ML, Haskell, Java, Eiffel, \dots \\ 
PL not supporting Interfaces: \\
Fortran, Pascal, C, Lisp, \dots
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.5}{Specifying the Interface in CASL}{}

\vspace{1cm}

\begin{ProgramFragment}[CASL_Spec]{CASL_Spec 2.1}{Database}{}

\begin{SpecDefn}{Database} =
\I{}
\begin{Items}                 
\I\Sorts \(\[ Database; String; Nat\] \)
\I\Ops
\( \[
   initial  & ~:~ & Database;\\
   look\_up & ~:~ & Database \* String \tfun Nat;\\
   update   & ~:~ & Database \* String \* Nat \tfun Database\\
\] \)
\end{Items}
\I\End
\end{SpecDefn}

\end{ProgramFragment}

\end{Paragraph}


\begin{Paragraph}{Paragraph1.2.6}{}{}
\begin{center}
{\Large Formal Specifications -- Second Element}
\end{center}
\hfill \\
A formal specification includes beside the \\
\begin{Table}{Table1.2.2}{Formal Specification}{}
\begin{tabular}{rl}
(i)  & signature \\
(ii) & a description of the functions' properties. \\
\end{tabular}
\end{Table}
\\
Programming Languages fail for (ii): \\
Expressing properties of a function involves implementation details.
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.7}{}{}
\begin{center}
{\Large Interface and Properties in CASL}
\end{center}

\begin{ProgramFragment}[CASL_Spec]{CASL_Spec 2.2}{Database}{}

\begin{SpecDefn}{Database} =
\I{}
\begin{Items}
\I\Sort
\( \[
   Database; String; Nat\\
\] \)

\I\Ops

\( \[
   initial  & ~:~ & Database;\\
   0        & ~:~ & Nat; \\
   look\_up & ~:~ & Database \* String \tfun Nat;\\
   update   & ~:~ & Database \* String \* Nat \tfun Database\\
\] \)

\I{}

\I\Vars

\( 
   s    : Database;
   n    :Nat;
   v, w : String
\)

\I\. \%[initial] \( look\_up( initial, v ) ~=~ 0 \)

\I\. \%[look\_up\_1]
\( \[
v ~=~ w ~\imp~ \\
look\_up( update( s, v, n ), w ) ~=~ n 
\]\)

\I\. \%[look\_up\_2]
\(\[ 
\neg~ v ~=~ w ~\imp~ \\
look\_up( update( s, v, n ), w ) ~=~ look\_up( s, w ) 
\]\)

\end{Items}                  
\I\End
\end{SpecDefn}

\end{ProgramFragment}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.8}{}{}
\vfill
\begin{center}
{\Large Useless Database}
\end{center}

\vspace{1cm}
\begin{center}
\MMstartApplication{Start Database}{Applications/MBandt/imp2/start_xterm.sh}
\end{center}

\vfill
\end{Paragraph}


\begin{Paragraph}{Paragraph1.2.9}{}{}
\begin{center}
{\Large Formal Specifications =}\\
{\Large Abstract Datatypes} (see also \cite{ehrich96})
\end{center}
\hfill \\
An Abstract Datatype consists of a \\
\begin{Table}{Table1.2.3}{Abstract Datatype}{}
\begin{tabular}{rl}
(i)   & Signature,\\
(ii)  & a description of the functions' properties, \\
(iii) & a description of the domains.
\end{tabular}
\end{Table}
\end{Paragraph}

\begin{Paragraph}{Paragraph1.2.10}{}{}
\begin{center}
{\Large A Domain Description in CASL}
\end{center}

\vspace{1cm}

\begin{ProgramFragment}[CASL_Spec]{CASL_Spec 2.3}{Natural Numbers}{}

\begin{SpecDefn}{Nat} =
\I{}
\begin{Items}
\I\Free\Types \
\(\[
Nat & \ ::= & \ 0 \, |  \, \Sort \ Pos; \\
Pos & \ ::= & \ suc(pre:Nat)
\]\)
\end{Items}
\I\End
\end{SpecDefn}

\end{ProgramFragment}

\end{Paragraph}

\end{Section}

\begin{Section}{Section1.3}{Bibliographic Remarks}{}
\begin{Paragraph}{para13}{}{}
\begin{List}{List1.3.1}{itemize}{}
\ListItem{}
Formal Methods: \\

\begin{TextFragment}{TextFragment1.3.1}{}
J.P.~Bowen, M.G.~Hinchey: {\it High-Integrity System Specification and Design,}
Springer, 1999.
\end{TextFragment}

\ListItem{}
Algebraic Specification: Loeckx, Ehrich, Wolf: {\it
Specification of Abstract Data Types,} Wiley \& Teubner, 1996.
\ListItem{}
CASL und CoFI: 
\begin{verbatim}
http://www.brics.dk/Projects/CoFI/
\end{verbatim}
\end{List}
\end{Paragraph}

\end{Section}

\begin{Section}{Section1.4}{Mathematical Background}{}
\begin{Paragraph}{para14}{}{}
\begin{Definition}[Algebra]{Definition1.4.1}{Semigroup}{}
Let $S$ be  set of elements together with a given binary operation. If $S$
is closed under the given operation and the given operation is
associative, then we call $S$ a semigroup under the given operation.
\end{Definition}
\newline
\begin{Definition}[Algebra]{Definition1.4.2}{Monoid}{}
Let $M$ be a semigroup. If there is an element $e \in M$ with
$em=me=m$ for all $m \in M$, then $e \in M$ is said to be an identity
element in relation to the operation. We call such a semigroup $M$ a
monoid and $e \in M$ the identity element of the monoid.
\end{Definition}
\newline
\begin{Definition}[Algebra]{Definition1.4.3}{Group}{}
Let $G$ be a monoid in which one finds a $\hat{g} \in G$ with
$\hat{g}g=g\hat{g}=e$ ($e \in G$ is the identity element of $G$) for
every $g \in G$. We call $\hat{g} \in G$ the
\Define{Define1.4.3.1}{inverse }{} element of $g \in G$ in relation to
the operation. The inverse element of a given
element $g \in G$ is denoted by $g^{-1}$. We call such a monoid $G$ a
group. Thus a group is a monoid in which every element has an inverse.
\end{Definition}
\newline
\begin{Theorem}[Algebra]{Theorem1.4.1}{Uniqueness 1a}{}
The identity element of a monoid $M$ is unique.
\end{Theorem}

\begin{Proof}[Algebra]{Proof1.4.1.1}{Contradiction}{}
Suppose there is a monoid $M$ with two different identity elements $e_{1}
\in M$ and $e_{2} \in M$. Then the following equation holds:
\begin{displaymath}
e_{1}=e_{1}e_{2}=e_{1}e_{2}=e_{2}
\end{displaymath}
So we conclude $e_{1}=e_{2}$. This is a contradiction to the
assumption. This means, that our assumption must be false. Therefore
the identity element of a monoid is unique.
\end{Proof}

\begin{Corollary}[Algebra]{Corollary1.4.1.1}{Uniqueness 1b}{}
The identity element of a group is unique.
\end{Corollary}
\newline
\begin{Theorem}[Algebra]{Theorem1.4.2}{Uniqueness 2}{}
The inverse element of a given element $g$ of a group $G$ is unique.
\end{Theorem}

\begin{Proof}[Algebra]{Proof1.4.2.1}{Contradiction}{}
Suppose there is a group $G$ and a $g \in G$  with two different
inverse elements $g_{1} \in G$ and $g_{2} \in G$ for $g \in G$. Then
the following equation holds:
\begin{displaymath}
g_{1}=g_{1}gg_{2}=g_{1}gg_{2}=g_{2}
\end{displaymath}
So we conclude $g_{1}=g_{2}$. This is a contradiction to the
assumption. This means, that our assumption must be false. This holds
for any $g \in G$ of any group $G$. Therefore the inverse element of a
given $g \in G$ in an arbitrary group G is always unique.
\end{Proof}
\newline
\begin{Assertion}[Algebra]{Assertion1.4.1}{Finite Groups}{}
Finite groups can be categorized. 
\end{Assertion}

\begin{Conjecture}[Specifications]{Conjecture1.4.1}{Mathematics of
Specifications}{}
Group-like objects are of the utmost significance for the mathematical
description of specifications.
\end{Conjecture}
\newline
\hfill \\
This is of course only a first glimpse at the subject. There is much
more to say, but that would definitely exceed the scope of this text.
\end{Paragraph}
\begin{Paragraph}{para15}{Remark}{}
Group-like objects as monoids and semigroups are less restrictive than
groups, because they do not require the existence of an
\Reference{Define1.4.3.1}{inverse}. But they are also more difficult
\Link{Assertion1.4.1}{} to handle.
\end{Paragraph}
\end{Section}

\end{Section}

\end{Package}
\end{document}














