<?xml version="1.0" encoding="UTF-8"?>

<!-- DTD for PGIP, the Proof General Interface Protocol		   -->
<!-- Author:  David Aspinall, LFCS, University of Edinburgh        -->
<!-- Version: $Id$     -->

<!-- Status:  Incomplete.					   -->
<!-- For commentary, see the Proof General Kit white paper,        -->
<!-- available from http://www.proofgeneral.org/kit		   -->

<!-- Changes cxl: -->
<!-- - merged pgip and pgml because HaXML can't handle external refs ?!? -->
<!-- - added provercmds and controlcmds to PGIP --> 
<!-- - added termdisplay to pgml, to display things like theorems and such -->

<!-- DTD for PGML, the Proof General Markup Language		   -->
<!-- Author:  David Aspinall, LFCS, University of Edinburgh	   -->
<!-- Version: $Id$     -->

<!-- Status:  Complete but experimental version.		   -->
<!-- For commentary, see the Proof General Kit white paper,        -->
<!-- available from http://www.proofgeneral.org/kit		   -->


<!ELEMENT pgml (statedisplay | termdisplay | information | warning | error)*>
<!ATTLIST pgml 
	    version CDATA #IMPLIED>

<!ENTITY % pgmlmsg "pgml">

<!ELEMENT statedisplay (statepart)*>
<!ATTLIST statedisplay 
	   systemid CDATA #IMPLIED
	   name	    CDATA #IMPLIED
           kind	    CDATA #IMPLIED>

<!ENTITY % termitem       "action | term | type | atom | sym">
<!ENTITY % nonactionitem  "term | type | atom | sym">

<!ELEMENT information (#PCDATA | %termitem;)*>
<!ATTLIST information
	   name	    CDATA #IMPLIED
           kind	    CDATA #IMPLIED>

<!ELEMENT warning (#PCDATA | %termitem;)*>
<!ATTLIST warning
	   name	    CDATA #IMPLIED
           kind	    CDATA #IMPLIED>

<!ELEMENT error (#PCDATA | %termitem;)*>
<!ATTLIST error
	   name	    CDATA #IMPLIED
           kind	    CDATA #IMPLIED>

<!ELEMENT statepart (#PCDATA | %termitem;)*>
<!ATTLIST statepart 
	   systemid CDATA #IMPLIED
	   name     CDATA #IMPLIED
	   kind	    CDATA #IMPLIED>

<!ELEMENT termdisplay (#PCDATA | %termitem;)*>
<!ATTLIST termdisplay
	   systemid CDATA #IMPLIED
	   name     CDATA #IMPLIED
	   kind	    CDATA #IMPLIED>

<!ELEMENT term (#PCDATA | %termitem;)*>
<!ATTLIST term 
           pos  CDATA #IMPLIED 
           kind CDATA #IMPLIED>

<!-- maybe combine this with term and add extra attr to term? -->
<!ELEMENT type (#PCDATA | %termitem;)*>
<!ATTLIST type 
	   kind CDATA #IMPLIED>

<!ELEMENT action (#PCDATA | %nonactionitem;)*>
<!ATTLIST action 
	   kind CDATA #IMPLIED>

<!ELEMENT atom (#PCDATA)>
<!ATTLIST atom 
	   kind CDATA #IMPLIED 
	   fullname CDATA #IMPLIED>

<!ELEMENT sym  (#PCDATA)>
<!ATTLIST sym  
	   name CDATA #IMPLIED
	   alt  CDATA #IMPLIED>

<!ELEMENT br EMPTY>






<!-- 
<!-- STATUS/ERROR MESSAGES -->
<!-- ===================== -->


<!ELEMENT information (#PCDATA)>
<!ATTLIST information
	   kind		CDATA #IMPLIED
	   location	CDATA #IMPLIED>

<!-- kind=message,urgentmessage,display -->

<!ELEMENT error (#PCDATA)>
<!ATTLIST error
	   kind		CDATA #IMPLIED
	   location	CDATA #IMPLIED>

<!-- kind=warning,fatal,interrupt -->

<!-- This is how it should be: 
  <!ENTITY % pgml SYSTEM "pgml.dtd">  
  -->

<!ELEMENT response (pgml)>
<!ATTLIST response 
           cmdid CDATA #IMPLIED>

<!ENTITY % proverstatus "information | error | response">

<!-- COMMANDS               -->
<!-- ====================== -->

<!-- Experimental: structured prover commands -->

<!-- tacticcmd and backcmd change the prover state, othercmds do not -->

<!-- A tactic can have a focus (subgoal, path to inner term &c) -->
<!ELEMENT tacticcmd (#PCDATA)>
<!ATTLIST tacticcmd 
           focus CDATA #IMPLIED>

<!-- Backtracking -->
<!ELEMENT backcmd EMPTY>

<!-- Any other command -->
<!ELEMENT othercmd (#PCDATA)>

<!ELEMENT provercmd (tacticcmd | backcmd | othercmd)> 
<!ATTLIST provercmd
           cmdid CDATA #IMPLIED>

<!-- These (and the provercmd above) inherently use the prover state. -->

<!ELEMENT goalcmd (#PCDATA)>

<!ELEMENT undocmd EMPTY>

<!-- the content is the name of the resulting theorem ??? -->
<!ELEMENT closecmd (#PCDATA)> 

<!ELEMENT abortcmd EMPTY>

<!ELEMENT savecmd EMPTY>
<!ATTLIST savecmd 
           goalid CDATA #REQUIRED>

<!ELEMENT restorecmd EMPTY>
<!ATTLIST restorecmd 
           goalid CDATA #REQUIRED>

<!ELEMENT controlcmd (goalcmd | undocmd | closecmd | abortcmd | 
                      savecmd | restorecmd )>
<!ATTLIST controlcmd 
           id CDATA #IMPLIED>


<!ELEMENT loadcmd (#PCDATA)> <!-- experimental -->

<!ENTITY % command "provercmd | controlcmd">

<!-- CONFIGURATION MESSAGES -->
<!-- ====================== -->

<!ENTITY % kitconfig  "usespgml | haspref | prefval | idtable | 
			addid | delid | menuadd | menudel | guiconfig ">

<!ELEMENT usespgml EMPTY>
<!ATTLIST usespgml 
	   version CDATA #IMPLIED>

<!ELEMENT haspref EMPTY>
<!ATTLIST haspref 
	   type     CDATA #IMPLIED
	   default  CDATA #IMPLIED
	   class    CDATA #IMPLIED>

<!ELEMENT prefval (#PCDATA)>
<!ATTLIST prefval
	   name     CDATA #IMPLIED>

<!ELEMENT idtable (#PCDATA)>
<!ATTLIST idtable
	   class    CDATA #IMPLIED>

<!ELEMENT addid (#PCDATA)>
<!ATTLIST addid
	   class    CDATA #IMPLIED>

<!ELEMENT delid (#PCDATA)>
<!ATTLIST delid
	   class    CDATA #IMPLIED>

<!ELEMENT menuadd (#PCDATA)>
<!ATTLIST menuadd
	   path	    CDATA #IMPLIED
	   name	    CDATA #IMPLIED>	   	

<!ELEMENT menudel (#PCDATA)>
<!ATTLIST menudel
	   path	    CDATA #IMPLIED
	   name	    CDATA #IMPLIED>	   	

<!-- gui configuration -->	   

<!-- the PCDATA is the icon, base64-encoded --> 
<!ELEMENT objtype (#PCDATA)>
<!ATTLIST objtype 
           name CDATA #REQUIRED>

<!ELEMENT opn (opsrc, optrg, opcmd)>
<!ATTLIST opn
           name CDATA #REQUIRED>

<!-- source types as space-separated list; target type is a single type -->
<!ELEMENT opsrc (#PCDATA)>
<!ELEMENT optrg (#PCDATA)>
<!-- the prover command, with a printf "%1"-style substitution of arguments -->
<!ELEMENT opcmd (#PCDATA)>

<!-- proof operations (no target sort) -->
<!ELEMENT proofopn (opsrc, opcmd)>
<!ATTLIST opn
           name CDATA #REQUIRED>

<!-- interactive operations-- require some input -->
<!ELEMENT iopn (inputform, opsrc, optrg, opcmd)>
<!ATTLIST iopn
           name CDATA #REQUIRED>

<!-- an input form is a list of fields -->
<!ELEMENT inputform (field)+>
<!-- and a field has a type (int, string, bool, choice(c1...cn)) -->
<!-- and a name; under that name, it will be substituted into the command -->
<!-- Ex. field name=number  opcmd="rtac %1 %number" -->
<!-- the PCDATA is the prompt for the input field -->
<!ELEMENT field (#PCDATA)>
<!ATTLIST field
           type CDATA #REQUIRED
           name CDATA #REQUIRED>
           
<!ELEMENT guiconfig (objtype*, opn*, iopn*, proofopn*) >
	   
<!ENTITY % proverconfig  "askpgml | askprefs | resetprefs | 
			  setpref | getpref">

<!ELEMENT askpgml EMPTY>

<!ELEMENT askprefs EMPTY>
<!ATTLIST askprefs
	   class   CDATA #IMPLIED>

<!ELEMENT resetprefs EMPTY>
<!ATTLIST resetprefs
	   class   CDATA #IMPLIED>

<!ELEMENT setpref EMPTY>
<!ATTLIST setpref
	   class   CDATA #IMPLIED>

<!ELEMENT getpref EMPTY>
<!ATTLIST getpref
	   class   CDATA #IMPLIED>





<!ELEMENT br EMPTY>



<!-- Messages sent to proof assistant (class "pa") -->

<!ENTITY % provermsg	"%proverconfig;">

<!-- Messages sent to PG Kit components -->

<!ENTITY % kitmsg     "%kitconfig; | %proverstatus;">

<!ELEMENT pgip (%provermsg; | %kitmsg;)* >
<!ATTLIST pgip
	    version CDATA #IMPLIED 
	    class   CDATA #IMPLIED
	    origin  CDATA #IMPLIED
	    id	    CDATA #IMPLIED>


