{- (This automatically generated by delhs from the GHC source.  Note -
   it compiles under Hugs. -}







module Maybes (
--      Maybe(..), -- no, it's in 1.3
        MaybeErr(..),

        allMaybes,
        firstJust,
        expectJust,
        maybeToBool,

        assocMaybe,
        mkLookupFun, mkLookupFunDef,

        failMaB,
        failMaybe,
        seqMaybe,
        returnMaB,
        returnMaybe,
        thenMaB


        , findJust
        , foldlMaybeErrs
        , listMaybeErrs

    ) where


import Maybe -- renamer will tell us if there are any conflicts

import Debug(debug)










maybeToBool :: Maybe a -> Bool
maybeToBool Nothing  = False
maybeToBool (Just _) = True










allMaybes :: [Maybe a] -> Maybe [a]
allMaybes [] = Just []
allMaybes (Nothing : _)  = Nothing
allMaybes (Just x  : ms) = case (allMaybes ms) of
                             Nothing -> Nothing
                             Just xs -> Just (x:xs)






firstJust :: [Maybe a] -> Maybe a
firstJust [] = Nothing
firstJust (Just x  : _) = Just x
firstJust (Nothing : ms) = firstJust ms



findJust :: (a -> Maybe b) -> [a] -> Maybe b
findJust _ []     = Nothing
findJust f (a:as) = case f a of
                      Nothing -> findJust f as
                      b  -> b



expectJust :: String -> Maybe a -> a
{-# INLINE expectJust #-}
expectJust _   (Just x) = x
expectJust err Nothing  = error ("expectJust " ++ err)





seqMaybe :: Maybe a -> Maybe a -> Maybe a
seqMaybe v@(Just _) _  = v
seqMaybe Nothing    my = my

returnMaybe :: a -> Maybe a
returnMaybe = Just

failMaybe :: Maybe a
failMaybe = Nothing









assocMaybe :: (Eq a) => [(a,b)] -> a -> Maybe b

assocMaybe alist key
  = lookup alist
  where
    lookup []             = Nothing
    lookup ((tv,ty):rest) = if key == tv then Just ty else lookup rest










mkLookupFun :: (key -> key -> Bool)     -- Equality predicate
            -> [(key,val)]              -- The assoc list
            -> key                      -- The key
            -> Maybe val                -- The corresponding value

mkLookupFun eq alist s
  = case [a | (s',a) <- alist, s' `eq` s] of
      []    -> Nothing
      (a:_) -> Just a

mkLookupFunDef :: (key -> key -> Bool)  -- Equality predicate
               -> [(key,val)]           -- The assoc list
               -> val                   -- Value to return on failure
               -> key                   -- The key
               -> val                   -- The corresponding value

mkLookupFunDef eq alist deflt s
  = case [a | (s',a) <- alist, s' `eq` s] of
      []    -> deflt
      (a:_) -> a









data MaybeErr val err = Succeeded val | Failed err



thenMaB :: MaybeErr val1 err -> (val1 -> MaybeErr val2 err) -> MaybeErr val2 err
thenMaB m k
  = case m of
      Succeeded v -> k v
      Failed e    -> Failed e

returnMaB :: val -> MaybeErr val err
returnMaB v = Succeeded v

failMaB :: err -> MaybeErr val err
failMaB e = Failed e








listMaybeErrs :: [MaybeErr val err] -> MaybeErr [val] [err]
listMaybeErrs
  = foldr combine (Succeeded [])
  where
    combine (Succeeded v) (Succeeded vs) = Succeeded (v:vs)
    combine (Failed err)  (Succeeded _)  = Failed [err]
    combine (Succeeded _) (Failed errs)  = Failed errs
    combine (Failed err)  (Failed errs)  = Failed (err:errs)







foldlMaybeErrs :: (acc -> input -> MaybeErr acc err)
               -> acc
               -> [input]
               -> MaybeErr acc [err]

foldlMaybeErrs k accum ins = do_it [] accum ins
  where
    do_it []   acc []     = Succeeded acc
    do_it errs _   []     = Failed errs
    do_it errs acc (v:vs) = case (k acc v) of
                              Succeeded acc' -> do_it errs       acc' vs
                              Failed err     -> do_it (err:errs) acc  vs

